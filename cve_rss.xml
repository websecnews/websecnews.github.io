<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>New CVE from cve.org feed</title><link>https://github.com/test.xml</link><description>Last 2 days CVE feed!</description><atom:link href="https://github.com/test.xml" rel="self"/><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><language>en</language><lastBuildDate>Mon, 30 Dec 2024 09:44:50 +0000</lastBuildDate><item><title>CVE-2024-47917 | Mobotix - CWE-79: Improper Neutralization of Input During Web Page Generation (&amp;#x27;Cross-site Scripting&amp;#x27;)</title><link>https://www.cve.org/CVERecord?id=CVE-2024-47917</link><description>CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</description><pubDate>Mon, 30 Dec 2024 09:44:52 +0000</pubDate></item><item><title>CVE-2024-22063 | ZTE ZENIC ONE R58 product has a CSV injection vulnerability</title><link>https://www.cve.org/CVERecord?id=CVE-2024-22063</link><description>The ZENIC ONE R58 products by ZTE Corporation have a command injection vulnerability. An authenticated attacker can exploit this vulnerability to tamper with messages, inject malicious code, and subsequently launch attacks on related devices.</description><pubDate>Mon, 30 Dec 2024 09:37:51 +0000</pubDate></item><item><title>CVE-2024-13039 | code-projects Simple Chat System add_user.php sql injection</title><link>https://www.cve.org/CVERecord?id=CVE-2024-13039</link><description>A vulnerability was found in code-projects Simple Chat System 1.0. It has been rated as critical. Affected by this issue is some unknown functionality of the file /add_user.php. The manipulation of the argument name/email/password/number leads to sql injection. The attack may be launched remotely. The exploit has been disclosed to the public and may be used.</description><pubDate>Mon, 30 Dec 2024 04:35:19 +0000</pubDate></item><item><title>CVE-2024-13038 | CodeAstro Simple Loan Management System Login index.php sql injection</title><link>https://www.cve.org/CVERecord?id=CVE-2024-13038</link><description>A vulnerability was found in CodeAstro Simple Loan Management System 1.0. It has been declared as critical. Affected by this vulnerability is an unknown functionality of the file /index.php of the component Login. The manipulation of the argument email leads to sql injection. The attack can be launched remotely. The exploit has been disclosed to the public and may be used.</description><pubDate>Mon, 30 Dec 2024 04:18:31 +0000</pubDate></item><item><title>CVE-2024-13037 | 1000 Projects Attendance Tracking Management System report.php attendance_report sql injection</title><link>https://www.cve.org/CVERecord?id=CVE-2024-13037</link><description>A vulnerability was found in 1000 Projects Attendance Tracking Management System 1.0. It has been classified as critical. Affected is the function attendance_report of the file /admin/report.php. The manipulation of the argument course_id leads to sql injection. It is possible to launch the attack remotely. The exploit has been disclosed to the public and may be used.</description><pubDate>Mon, 30 Dec 2024 03:44:17 +0000</pubDate></item><item><title>CVE-2024-13036 | code-projects Chat System update_room.php sql injection</title><link>https://www.cve.org/CVERecord?id=CVE-2024-13036</link><description>A vulnerability was found in code-projects Chat System 1.0 and classified as critical. This issue affects some unknown processing of the file /admin/update_room.php. The manipulation of the argument id/name/password leads to sql injection. The attack may be initiated remotely. The exploit has been disclosed to the public and may be used.</description><pubDate>Mon, 30 Dec 2024 03:30:36 +0000</pubDate></item><item><title>CVE-2024-13035 | code-projects Chat System update_user.php sql injection</title><link>https://www.cve.org/CVERecord?id=CVE-2024-13035</link><description>A vulnerability has been found in code-projects Chat System 1.0 and classified as critical. This vulnerability affects unknown code of the file /admin/update_user.php. The manipulation of the argument id leads to sql injection. The attack can be initiated remotely. The exploit has been disclosed to the public and may be used.</description><pubDate>Mon, 30 Dec 2024 03:02:42 +0000</pubDate></item><item><title>CVE-2024-13033 | code-projects Chat System chatroom.php cross site scripting</title><link>https://www.cve.org/CVERecord?id=CVE-2024-13033</link><description>A vulnerability, which was classified as problematic, has been found in code-projects Chat System 1.0. Affected by this issue is some unknown functionality of the file /admin/chatroom.php. The manipulation of the argument id leads to cross site scripting. The attack may be launched remotely. The exploit has been disclosed to the public and may be used.</description><pubDate>Mon, 30 Dec 2024 02:23:46 +0000</pubDate></item><item><title>CVE-2024-13034 | code-projects Chat System update_user.php cross site scripting</title><link>https://www.cve.org/CVERecord?id=CVE-2024-13034</link><description>A vulnerability, which was classified as problematic, was found in code-projects Chat System 1.0. This affects an unknown part of the file /admin/update_user.php. The manipulation of the argument name leads to cross site scripting. It is possible to initiate the attack remotely. The exploit has been disclosed to the public and may be used.</description><pubDate>Mon, 30 Dec 2024 02:23:46 +0000</pubDate></item><item><title>CVE-2024-13032 | Antabot White-Jotter Article Editor editor server-side request forgery</title><link>https://www.cve.org/CVERecord?id=CVE-2024-13032</link><description>A vulnerability classified as problematic was found in Antabot White-Jotter up to 0.2.2. Affected by this vulnerability is an unknown functionality of the file /admin/content/editor of the component Article Editor. The manipulation of the argument articleCover leads to server-side request forgery. The attack can be launched remotely. The exploit has been disclosed to the public and may be used.</description><pubDate>Mon, 30 Dec 2024 02:23:47 +0000</pubDate></item><item><title>CVE-2024-13031 | Antabot White-Jotter Article Content Editor editor cross site scripting</title><link>https://www.cve.org/CVERecord?id=CVE-2024-13031</link><description>A vulnerability classified as problematic has been found in Antabot White-Jotter up to 0.2.2. Affected is an unknown function of the file /admin/content/editor of the component Article Content Editor. The manipulation leads to cross site scripting. It is possible to launch the attack remotely. The exploit has been disclosed to the public and may be used.</description><pubDate>Mon, 30 Dec 2024 01:05:20 +0000</pubDate></item><item><title>CVE-2024-13030 | D-Link DIR-823G Web Management Interface HNAP1 SetVirtualServerSettings access control</title><link>https://www.cve.org/CVERecord?id=CVE-2024-13030</link><description>A vulnerability was found in D-Link DIR-823G 1.0.2B05_20181207. It has been rated as critical. This issue affects the function SetAutoRebootSettings/SetClientInfo/SetDMZSettings/SetFirewallSettings/SetParentsControlInfo/SetQoSSettings/SetVirtualServerSettings of the file /HNAP1/ of the component Web Management Interface. The manipulation leads to improper access controls. The attack may be initiated remotely. The exploit has been disclosed to the public and may be used.</description><pubDate>Mon, 30 Dec 2024 01:05:21 +0000</pubDate></item><item><title>CVE-2024-13029 | Antabot White-Jotter Edit Book book server-side request forgery</title><link>https://www.cve.org/CVERecord?id=CVE-2024-13029</link><description>A vulnerability, which was classified as problematic, was found in Antabot White-Jotter up to 0.2.2. Affected is an unknown function of the file /admin/content/book of the component Edit Book Handler. The manipulation leads to server-side request forgery. It is possible to launch the attack remotely. The exploit has been disclosed to the public and may be used.</description><pubDate>Sun, 29 Dec 2024 23:36:05 +0000</pubDate></item><item><title>CVE-2024-13028 | Antabot White-Jotter login observable response discrepancy</title><link>https://www.cve.org/CVERecord?id=CVE-2024-13028</link><description>A vulnerability, which was classified as problematic, has been found in Antabot White-Jotter up to 0.2.2. This issue affects some unknown processing of the file /login. The manipulation of the argument username leads to observable response discrepancy. The attack may be initiated remotely. The complexity of an attack is rather high. The exploitation is known to be difficult. The exploit has been disclosed to the public and may be used.</description><pubDate>Sun, 29 Dec 2024 23:17:43 +0000</pubDate></item><item><title>CVE-2024-13025 | Codezips College Management System faculty.php sql injection</title><link>https://www.cve.org/CVERecord?id=CVE-2024-13025</link><description>A vulnerability was found in Codezips College Management System 1.0. It has been classified as critical. Affected is an unknown function of the file /Front-end/faculty.php. The manipulation of the argument book_name/book_author leads to sql injection. It is possible to launch the attack remotely. The exploit has been disclosed to the public and may be used.</description><pubDate>Sun, 29 Dec 2024 22:39:28 +0000</pubDate></item><item><title>CVE-2024-13024 | Codezips Blood Bank Management System campaign.php sql injection</title><link>https://www.cve.org/CVERecord?id=CVE-2024-13024</link><description>A vulnerability was found in Codezips Blood Bank Management System 1.0 and classified as critical. This issue affects some unknown processing of the file /campaign.php. The manipulation of the argument cname leads to sql injection. The attack may be initiated remotely. The exploit has been disclosed to the public and may be used. Other parameters might be affected as well.</description><pubDate>Sun, 29 Dec 2024 21:10:24 +0000</pubDate></item><item><title>CVE-2024-13023 | PHPGurukul Maid Hiring Management System Search Maid Page search-maid.php cross site scripting</title><link>https://www.cve.org/CVERecord?id=CVE-2024-13023</link><description>A vulnerability has been found in PHPGurukul Maid Hiring Management System 1.0 and classified as problematic. This vulnerability affects unknown code of the file /admin/search-maid.php of the component Search Maid Page. The manipulation of the argument searchdata leads to cross site scripting. The attack can be initiated remotely. The exploit has been disclosed to the public and may be used.</description><pubDate>Sun, 29 Dec 2024 20:35:20 +0000</pubDate></item><item><title>CVE-2024-13022 | taisan tarzan-cms Article Management UploadController.java UploadResponse unrestricted upload</title><link>https://www.cve.org/CVERecord?id=CVE-2024-13022</link><description>A vulnerability, which was classified as critical, was found in taisan tarzan-cms 1.0.0. This affects the function UploadResponse of the file src/main/java/com/tarzan/cms/modules/admin/controller/common/UploadController.java of the component Article Management. The manipulation of the argument file leads to unrestricted upload. It is possible to initiate the attack remotely. The exploit has been disclosed to the public and may be used.</description><pubDate>Sun, 29 Dec 2024 20:12:45 +0000</pubDate></item><item><title>CVE-2024-13021 | SourceCodester Road Accident Map Marker add-mark.php cross site scripting</title><link>https://www.cve.org/CVERecord?id=CVE-2024-13021</link><description>A vulnerability, which was classified as problematic, has been found in SourceCodester Road Accident Map Marker 1.0. Affected by this issue is some unknown functionality of the file /endpoint/add-mark.php. The manipulation of the argument mark_name leads to cross site scripting. The attack may be launched remotely. The exploit has been disclosed to the public and may be used. Other parameters might be affected as well.</description><pubDate>Sun, 29 Dec 2024 19:35:56 +0000</pubDate></item><item><title>CVE-2024-13020 | code-projects Chat System chatroom.php sql injection</title><link>https://www.cve.org/CVERecord?id=CVE-2024-13020</link><description>A vulnerability classified as critical was found in code-projects Chat System 1.0. Affected by this vulnerability is an unknown functionality of the file /admin/chatroom.php. The manipulation of the argument id leads to sql injection. The attack can be launched remotely. The exploit has been disclosed to the public and may be used.</description><pubDate>Sun, 29 Dec 2024 19:11:56 +0000</pubDate></item><item><title>CVE-2024-13019 | code-projects Chat System Chat Room Page update_room.php cross site scripting</title><link>https://www.cve.org/CVERecord?id=CVE-2024-13019</link><description>A vulnerability classified as problematic has been found in code-projects Chat System 1.0. Affected is an unknown function of the file /admin/update_room.php of the component Chat Room Page. The manipulation of the argument name leads to cross site scripting. It is possible to launch the attack remotely.</description><pubDate>Sun, 29 Dec 2024 18:35:59 +0000</pubDate></item><item><title>CVE-2024-13018 | PHPGurukul Maid Hiring Management System profile.php cross site scripting</title><link>https://www.cve.org/CVERecord?id=CVE-2024-13018</link><description>A vulnerability was found in PHPGurukul Maid Hiring Management System 1.0. It has been rated as problematic. This issue affects some unknown processing of the file /admin/profile.php. The manipulation of the argument name leads to cross site scripting. The attack may be initiated remotely.</description><pubDate>Sun, 29 Dec 2024 18:19:24 +0000</pubDate></item><item><title>CVE-2024-13017 | PHPGurukul Maid Hiring Management System About Us Page aboutus.php cross site scripting</title><link>https://www.cve.org/CVERecord?id=CVE-2024-13017</link><description>A vulnerability was found in PHPGurukul Maid Hiring Management System 1.0. It has been declared as problematic. This vulnerability affects unknown code of the file /admin/aboutus.php of the component About Us Page. The manipulation of the argument title leads to cross site scripting. The attack can be initiated remotely.</description><pubDate>Sun, 29 Dec 2024 17:13:18 +0000</pubDate></item><item><title>CVE-2024-13016 | PHPGurukul Maid Hiring Management System edit-category.php sql injection</title><link>https://www.cve.org/CVERecord?id=CVE-2024-13016</link><description>A vulnerability was found in PHPGurukul Maid Hiring Management System 1.0. It has been classified as critical. This affects an unknown part of the file /admin/edit-category.php. The manipulation of the argument editid leads to sql injection. It is possible to initiate the attack remotely. The exploit has been disclosed to the public and may be used.</description><pubDate>Sun, 29 Dec 2024 16:18:40 +0000</pubDate></item><item><title>CVE-2024-13015 | PHPGurukul Maid Hiring Management System search-booking-request.php cross site scripting</title><link>https://www.cve.org/CVERecord?id=CVE-2024-13015</link><description>A vulnerability was found in PHPGurukul Maid Hiring Management System 1.0 and classified as problematic. Affected by this issue is some unknown functionality of the file /admin/search-booking-request.php. The manipulation of the argument searchdata leads to cross site scripting. The attack may be launched remotely.</description><pubDate>Sun, 29 Dec 2024 15:38:13 +0000</pubDate></item><item><title>CVE-2024-13014 | PHPGurukul Maid Hiring Management System search-maid.php sql injection</title><link>https://www.cve.org/CVERecord?id=CVE-2024-13014</link><description>A vulnerability has been found in PHPGurukul Maid Hiring Management System 1.0 and classified as critical. Affected by this vulnerability is an unknown functionality of the file /admin/search-maid.php. The manipulation of the argument searchdata leads to sql injection. The attack can be launched remotely. The exploit has been disclosed to the public and may be used.</description><pubDate>Sun, 29 Dec 2024 15:07:36 +0000</pubDate></item><item><title>CVE-2024-13013 | PHPGurukul Maid Hiring Management System Contact Us Page contactus.php cross site scripting</title><link>https://www.cve.org/CVERecord?id=CVE-2024-13013</link><description>A vulnerability, which was classified as problematic, was found in PHPGurukul Maid Hiring Management System 1.0. Affected is an unknown function of the file /admin/contactus.php of the component Contact Us Page. The manipulation of the argument page title leads to cross site scripting. It is possible to launch the attack remotely. The exploit has been disclosed to the public and may be used.</description><pubDate>Sun, 29 Dec 2024 13:41:35 +0000</pubDate></item><item><title>CVE-2024-13012 | code-projects Hostel Management System registration.php cross site scripting</title><link>https://www.cve.org/CVERecord?id=CVE-2024-13012</link><description>A vulnerability, which was classified as problematic, has been found in code-projects Hostel Management System 1.0. This issue affects some unknown processing of the file /admin/registration.php. The manipulation of the argument fname/mname/lname leads to cross site scripting. The attack may be initiated remotely.</description><pubDate>Sun, 29 Dec 2024 12:27:14 +0000</pubDate></item><item><title>CVE-2024-56720 | bpf, sockmap: Several fixes to bpf_msg_pop_data</title><link>https://www.cve.org/CVERecord?id=CVE-2024-56720</link><description>In the Linux kernel, the following vulnerability has been resolved:

bpf, sockmap: Several fixes to bpf_msg_pop_data

Several fixes to bpf_msg_pop_data,
1. In sk_msg_shift_left, we should put_page
2. if (len == 0), return early is better
3. pop the entire sk_msg (last == msg-&gt;sg.size) should be supported
4. Fix for the value of variable "a"
5. In sk_msg_shift_left, after shifting, i has already pointed to the next
element. Addtional sk_msg_iter_var_next may result in BUG.</description><pubDate>Sun, 29 Dec 2024 11:37:16 +0000</pubDate></item><item><title>CVE-2024-56721 | x86/CPU/AMD: Terminate the erratum_1386_microcode array</title><link>https://www.cve.org/CVERecord?id=CVE-2024-56721</link><description>In the Linux kernel, the following vulnerability has been resolved:

x86/CPU/AMD: Terminate the erratum_1386_microcode array

The erratum_1386_microcode array requires an empty entry at the end.
Otherwise x86_match_cpu_with_stepping() will continue iterate the array after
it ended.

Add an empty entry to erratum_1386_microcode to its end.</description><pubDate>Sun, 29 Dec 2024 11:37:16 +0000</pubDate></item><item><title>CVE-2024-56722 | RDMA/hns: Fix cpu stuck caused by printings during reset</title><link>https://www.cve.org/CVERecord?id=CVE-2024-56722</link><description>In the Linux kernel, the following vulnerability has been resolved:

RDMA/hns: Fix cpu stuck caused by printings during reset

During reset, cmd to destroy resources such as qp, cq, and mr may fail,
and error logs will be printed. When a large number of resources are
destroyed, there will be lots of printings, and it may lead to a cpu
stuck.

Delete some unnecessary printings and replace other printing functions
in these paths with the ratelimited version.</description><pubDate>Sun, 29 Dec 2024 11:37:17 +0000</pubDate></item><item><title>CVE-2024-56723 | mfd: intel_soc_pmic_bxtwc: Use IRQ domain for PMIC devices</title><link>https://www.cve.org/CVERecord?id=CVE-2024-56723</link><description>In the Linux kernel, the following vulnerability has been resolved:

mfd: intel_soc_pmic_bxtwc: Use IRQ domain for PMIC devices

While design wise the idea of converting the driver to use
the hierarchy of the IRQ chips is correct, the implementation
has (inherited) flaws. This was unveiled when platform_get_irq()
had started WARN() on IRQ 0 that is supposed to be a Linux
IRQ number (also known as vIRQ).

Rework the driver to respect IRQ domain when creating each MFD
device separately, as the domain is not the same for all of them.</description><pubDate>Sun, 29 Dec 2024 11:37:17 +0000</pubDate></item><item><title>CVE-2024-56724 | mfd: intel_soc_pmic_bxtwc: Use IRQ domain for TMU device</title><link>https://www.cve.org/CVERecord?id=CVE-2024-56724</link><description>In the Linux kernel, the following vulnerability has been resolved:

mfd: intel_soc_pmic_bxtwc: Use IRQ domain for TMU device

While design wise the idea of converting the driver to use
the hierarchy of the IRQ chips is correct, the implementation
has (inherited) flaws. This was unveiled when platform_get_irq()
had started WARN() on IRQ 0 that is supposed to be a Linux
IRQ number (also known as vIRQ).

Rework the driver to respect IRQ domain when creating each MFD
device separately, as the domain is not the same for all of them.</description><pubDate>Sun, 29 Dec 2024 11:37:17 +0000</pubDate></item><item><title>CVE-2024-56725 | octeontx2-pf: handle otx2_mbox_get_rsp errors in otx2_dcbnl.c</title><link>https://www.cve.org/CVERecord?id=CVE-2024-56725</link><description>In the Linux kernel, the following vulnerability has been resolved:

octeontx2-pf: handle otx2_mbox_get_rsp errors in otx2_dcbnl.c

Add error pointer check after calling otx2_mbox_get_rsp().</description><pubDate>Sun, 29 Dec 2024 11:37:18 +0000</pubDate></item><item><title>CVE-2024-56726 | octeontx2-pf: handle otx2_mbox_get_rsp errors in cn10k.c</title><link>https://www.cve.org/CVERecord?id=CVE-2024-56726</link><description>In the Linux kernel, the following vulnerability has been resolved:

octeontx2-pf: handle otx2_mbox_get_rsp errors in cn10k.c

Add error pointer check after calling otx2_mbox_get_rsp().</description><pubDate>Sun, 29 Dec 2024 11:37:18 +0000</pubDate></item><item><title>CVE-2024-56727 | octeontx2-pf: handle otx2_mbox_get_rsp errors in otx2_flows.c</title><link>https://www.cve.org/CVERecord?id=CVE-2024-56727</link><description>In the Linux kernel, the following vulnerability has been resolved:

octeontx2-pf: handle otx2_mbox_get_rsp errors in otx2_flows.c

Adding error pointer check after calling otx2_mbox_get_rsp().</description><pubDate>Sun, 29 Dec 2024 11:37:19 +0000</pubDate></item><item><title>CVE-2024-56728 | octeontx2-pf: handle otx2_mbox_get_rsp errors in otx2_ethtool.c</title><link>https://www.cve.org/CVERecord?id=CVE-2024-56728</link><description>In the Linux kernel, the following vulnerability has been resolved:

octeontx2-pf: handle otx2_mbox_get_rsp errors in otx2_ethtool.c

Add error pointer check after calling otx2_mbox_get_rsp().</description><pubDate>Sun, 29 Dec 2024 11:37:19 +0000</pubDate></item><item><title>CVE-2024-56729 | smb: Initialize cfid-&amp;gt;tcon before performing network ops</title><link>https://www.cve.org/CVERecord?id=CVE-2024-56729</link><description>In the Linux kernel, the following vulnerability has been resolved:

smb: Initialize cfid-&gt;tcon before performing network ops

Avoid leaking a tcon ref when a lease break races with opening the
cached directory. Processing the leak break might take a reference to
the tcon in cached_dir_lease_break() and then fail to release the ref in
cached_dir_offload_close, since cfid-&gt;tcon is still NULL.</description><pubDate>Sun, 29 Dec 2024 11:37:19 +0000</pubDate></item><item><title>CVE-2024-56730 | net/9p/usbg: fix handling of the failed kzalloc() memory allocation</title><link>https://www.cve.org/CVERecord?id=CVE-2024-56730</link><description>In the Linux kernel, the following vulnerability has been resolved:

net/9p/usbg: fix handling of the failed kzalloc() memory allocation

On the linux-next, next-20241108 vanilla kernel, the coccinelle tool gave the
following error report:

./net/9p/trans_usbg.c:912:5-11: ERROR: allocation function on line 911 returns
NULL not ERR_PTR on failure

kzalloc() failure is fixed to handle the NULL return case on the memory exhaustion.</description><pubDate>Sun, 29 Dec 2024 11:37:20 +0000</pubDate></item><item><title>CVE-2024-56739 | rtc: check if __rtc_read_time was successful in rtc_timer_do_work()</title><link>https://www.cve.org/CVERecord?id=CVE-2024-56739</link><description>In the Linux kernel, the following vulnerability has been resolved:

rtc: check if __rtc_read_time was successful in rtc_timer_do_work()

If the __rtc_read_time call fails,, the struct rtc_time tm; may contain
uninitialized data, or an illegal date/time read from the RTC hardware.

When calling rtc_tm_to_ktime later, the result may be a very large value
(possibly KTIME_MAX). If there are periodic timers in rtc-&gt;timerqueue,
they will continually expire, may causing kernel softlockup.</description><pubDate>Sun, 29 Dec 2024 11:37:20 +0000</pubDate></item><item><title>CVE-2024-56740 | nfs/localio: must clear res.replen in nfs_local_read_done</title><link>https://www.cve.org/CVERecord?id=CVE-2024-56740</link><description>In the Linux kernel, the following vulnerability has been resolved:

nfs/localio: must clear res.replen in nfs_local_read_done

Otherwise memory corruption can occur due to NFSv3 LOCALIO reads
leaving garbage in res.replen:
- nfs3_read_done() copies that into server-&gt;read_hdrsize; from there
  nfs3_proc_read_setup() copies it to args.replen in new requests.
- nfs3_xdr_enc_read3args() passes that to rpc_prepare_reply_pages()
  which includes it in hdrsize for xdr_init_pages, so that rq_rcv_buf
  contains a ridiculous len.
- This is copied to rq_private_buf and xs_read_stream_request()
  eventually passes the kvec to sock_recvmsg() which receives incoming
  data into entirely the wrong place.

This is easily reproduced with NFSv3 LOCALIO that is servicing reads
when it is made to pivot back to using normal RPC.  This switch back
to using normal NFSv3 with RPC can occur for a few reasons but this
issue was exposed with a test that stops and then restarts the NFSv3
server while LOCALIO is performing heavy read IO.</description><pubDate>Sun, 29 Dec 2024 11:37:21 +0000</pubDate></item><item><title>CVE-2024-56741 | apparmor: test: Fix memory leak for aa_unpack_strdup()</title><link>https://www.cve.org/CVERecord?id=CVE-2024-56741</link><description>In the Linux kernel, the following vulnerability has been resolved:

apparmor: test: Fix memory leak for aa_unpack_strdup()

The string allocated by kmemdup() in aa_unpack_strdup() is not
freed and cause following memory leaks, free them to fix it.

	unreferenced object 0xffffff80c6af8a50 (size 8):
	  comm "kunit_try_catch", pid 225, jiffies 4294894407
	  hex dump (first 8 bytes):
	    74 65 73 74 69 6e 67 00                          testing.
	  backtrace (crc 5eab668b):
	    [&lt;0000000001e3714d&gt;] kmemleak_alloc+0x34/0x40
	    [&lt;000000006e6c7776&gt;] __kmalloc_node_track_caller_noprof+0x300/0x3e0
	    [&lt;000000006870467c&gt;] kmemdup_noprof+0x34/0x60
	    [&lt;000000001176bb03&gt;] aa_unpack_strdup+0xd0/0x18c
	    [&lt;000000008ecde918&gt;] policy_unpack_test_unpack_strdup_with_null_name+0xf8/0x3ec
	    [&lt;0000000032ef8f77&gt;] kunit_try_run_case+0x13c/0x3ac
	    [&lt;00000000f3edea23&gt;] kunit_generic_run_threadfn_adapter+0x80/0xec
	    [&lt;00000000adf936cf&gt;] kthread+0x2e8/0x374
	    [&lt;0000000041bb1628&gt;] ret_from_fork+0x10/0x20
	unreferenced object 0xffffff80c2a29090 (size 8):
	  comm "kunit_try_catch", pid 227, jiffies 4294894409
	  hex dump (first 8 bytes):
	    74 65 73 74 69 6e 67 00                          testing.
	  backtrace (crc 5eab668b):
	    [&lt;0000000001e3714d&gt;] kmemleak_alloc+0x34/0x40
	    [&lt;000000006e6c7776&gt;] __kmalloc_node_track_caller_noprof+0x300/0x3e0
	    [&lt;000000006870467c&gt;] kmemdup_noprof+0x34/0x60
	    [&lt;000000001176bb03&gt;] aa_unpack_strdup+0xd0/0x18c
	    [&lt;0000000046a45c1a&gt;] policy_unpack_test_unpack_strdup_with_name+0xd0/0x3c4
	    [&lt;0000000032ef8f77&gt;] kunit_try_run_case+0x13c/0x3ac
	    [&lt;00000000f3edea23&gt;] kunit_generic_run_threadfn_adapter+0x80/0xec
	    [&lt;00000000adf936cf&gt;] kthread+0x2e8/0x374
	    [&lt;0000000041bb1628&gt;] ret_from_fork+0x10/0x20</description><pubDate>Sun, 29 Dec 2024 11:37:21 +0000</pubDate></item><item><title>CVE-2024-56742 | vfio/mlx5: Fix an unwind issue in mlx5vf_add_migration_pages()</title><link>https://www.cve.org/CVERecord?id=CVE-2024-56742</link><description>In the Linux kernel, the following vulnerability has been resolved:

vfio/mlx5: Fix an unwind issue in mlx5vf_add_migration_pages()

Fix an unwind issue in mlx5vf_add_migration_pages().

If a set of pages is allocated but fails to be added to the SG table,
they need to be freed to prevent a memory leak.

Any pages successfully added to the SG table will be freed as part of
mlx5vf_free_data_buffer().</description><pubDate>Sun, 29 Dec 2024 11:37:21 +0000</pubDate></item><item><title>CVE-2024-56743 | nfs_common: must not hold RCU while calling nfsd_file_put_local</title><link>https://www.cve.org/CVERecord?id=CVE-2024-56743</link><description>In the Linux kernel, the following vulnerability has been resolved:

nfs_common: must not hold RCU while calling nfsd_file_put_local

Move holding the RCU from nfs_to_nfsd_file_put_local to
nfs_to_nfsd_net_put.  It is the call to nfs_to-&gt;nfsd_serv_put that
requires the RCU anyway (the puts for nfsd_file and netns were
combined to avoid an extra indirect reference but that
micro-optimization isn't possible now).

This fixes xfstests generic/013 and it triggering:

"Voluntary context switch within RCU read-side critical section!"

[  143.545738] Call Trace:
[  143.546206]  
[  143.546625]  ? show_regs+0x6d/0x80
[  143.547267]  ? __warn+0x91/0x140
[  143.547951]  ? rcu_note_context_switch+0x496/0x5d0
[  143.548856]  ? report_bug+0x193/0x1a0
[  143.549557]  ? handle_bug+0x63/0xa0
[  143.550214]  ? exc_invalid_op+0x1d/0x80
[  143.550938]  ? asm_exc_invalid_op+0x1f/0x30
[  143.551736]  ? rcu_note_context_switch+0x496/0x5d0
[  143.552634]  ? wakeup_preempt+0x62/0x70
[  143.553358]  __schedule+0xaa/0x1380
[  143.554025]  ? _raw_spin_unlock_irqrestore+0x12/0x40
[  143.554958]  ? try_to_wake_up+0x1fe/0x6b0
[  143.555715]  ? wake_up_process+0x19/0x20
[  143.556452]  schedule+0x2e/0x120
[  143.557066]  schedule_preempt_disabled+0x19/0x30
[  143.557933]  rwsem_down_read_slowpath+0x24d/0x4a0
[  143.558818]  ? xfs_efi_item_format+0x50/0xc0 [xfs]
[  143.559894]  down_read+0x4e/0xb0
[  143.560519]  xlog_cil_commit+0x1b2/0xbc0 [xfs]
[  143.561460]  ? _raw_spin_unlock+0x12/0x30
[  143.562212]  ? xfs_inode_item_precommit+0xc7/0x220 [xfs]
[  143.563309]  ? xfs_trans_run_precommits+0x69/0xd0 [xfs]
[  143.564394]  __xfs_trans_commit+0xb5/0x330 [xfs]
[  143.565367]  xfs_trans_roll+0x48/0xc0 [xfs]
[  143.566262]  xfs_defer_trans_roll+0x57/0x100 [xfs]
[  143.567278]  xfs_defer_finish_noroll+0x27a/0x490 [xfs]
[  143.568342]  xfs_defer_finish+0x1a/0x80 [xfs]
[  143.569267]  xfs_bunmapi_range+0x4d/0xb0 [xfs]
[  143.570208]  xfs_itruncate_extents_flags+0x13d/0x230 [xfs]
[  143.571353]  xfs_free_eofblocks+0x12e/0x190 [xfs]
[  143.572359]  xfs_file_release+0x12d/0x140 [xfs]
[  143.573324]  __fput+0xe8/0x2d0
[  143.573922]  __fput_sync+0x1d/0x30
[  143.574574]  nfsd_filp_close+0x33/0x60 [nfsd]
[  143.575430]  nfsd_file_free+0x96/0x150 [nfsd]
[  143.576274]  nfsd_file_put+0xf7/0x1a0 [nfsd]
[  143.577104]  nfsd_file_put_local+0x18/0x30 [nfsd]
[  143.578070]  nfs_close_local_fh+0x101/0x110 [nfs_localio]
[  143.579079]  __put_nfs_open_context+0xc9/0x180 [nfs]
[  143.580031]  nfs_file_clear_open_context+0x4a/0x60 [nfs]
[  143.581038]  nfs_file_release+0x3e/0x60 [nfs]
[  143.581879]  __fput+0xe8/0x2d0
[  143.582464]  __fput_sync+0x1d/0x30
[  143.583108]  __x64_sys_close+0x41/0x80
[  143.583823]  x64_sys_call+0x189a/0x20d0
[  143.584552]  do_syscall_64+0x64/0x170
[  143.585240]  entry_SYSCALL_64_after_hwframe+0x76/0x7e
[  143.586185] RIP: 0033:0x7f3c5153efd7</description><pubDate>Sun, 29 Dec 2024 11:37:22 +0000</pubDate></item><item><title>CVE-2024-56744 | f2fs: fix to avoid potential deadlock in f2fs_record_stop_reason()</title><link>https://www.cve.org/CVERecord?id=CVE-2024-56744</link><description>In the Linux kernel, the following vulnerability has been resolved:

f2fs: fix to avoid potential deadlock in f2fs_record_stop_reason()

syzbot reports deadlock issue of f2fs as below:

======================================================
WARNING: possible circular locking dependency detected
6.12.0-rc3-syzkaller-00087-gc964ced77262 #0 Not tainted
------------------------------------------------------
kswapd0/79 is trying to acquire lock:
ffff888011824088 (&amp;amp;sbi-&gt;sb_lock){++++}-{3:3}, at: f2fs_down_write fs/f2fs/f2fs.h:2199 [inline]
ffff888011824088 (&amp;amp;sbi-&gt;sb_lock){++++}-{3:3}, at: f2fs_record_stop_reason+0x52/0x1d0 fs/f2fs/super.c:4068

but task is already holding lock:
ffff88804bd92610 (sb_internal#2){.+.+}-{0:0}, at: f2fs_evict_inode+0x662/0x15c0 fs/f2fs/inode.c:842

which lock already depends on the new lock.

the existing dependency chain (in reverse order) is:

-&gt; #2 (sb_internal#2){.+.+}-{0:0}:
       lock_acquire+0x1ed/0x550 kernel/locking/lockdep.c:5825
       percpu_down_read include/linux/percpu-rwsem.h:51 [inline]
       __sb_start_write include/linux/fs.h:1716 [inline]
       sb_start_intwrite+0x4d/0x1c0 include/linux/fs.h:1899
       f2fs_evict_inode+0x662/0x15c0 fs/f2fs/inode.c:842
       evict+0x4e8/0x9b0 fs/inode.c:725
       f2fs_evict_inode+0x1a4/0x15c0 fs/f2fs/inode.c:807
       evict+0x4e8/0x9b0 fs/inode.c:725
       dispose_list fs/inode.c:774 [inline]
       prune_icache_sb+0x239/0x2f0 fs/inode.c:963
       super_cache_scan+0x38c/0x4b0 fs/super.c:223
       do_shrink_slab+0x701/0x1160 mm/shrinker.c:435
       shrink_slab+0x1093/0x14d0 mm/shrinker.c:662
       shrink_one+0x43b/0x850 mm/vmscan.c:4818
       shrink_many mm/vmscan.c:4879 [inline]
       lru_gen_shrink_node mm/vmscan.c:4957 [inline]
       shrink_node+0x3799/0x3de0 mm/vmscan.c:5937
       kswapd_shrink_node mm/vmscan.c:6765 [inline]
       balance_pgdat mm/vmscan.c:6957 [inline]
       kswapd+0x1ca3/0x3700 mm/vmscan.c:7226
       kthread+0x2f0/0x390 kernel/kthread.c:389
       ret_from_fork+0x4b/0x80 arch/x86/kernel/process.c:147
       ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244

-&gt; #1 (fs_reclaim){+.+.}-{0:0}:
       lock_acquire+0x1ed/0x550 kernel/locking/lockdep.c:5825
       __fs_reclaim_acquire mm/page_alloc.c:3834 [inline]
       fs_reclaim_acquire+0x88/0x130 mm/page_alloc.c:3848
       might_alloc include/linux/sched/mm.h:318 [inline]
       prepare_alloc_pages+0x147/0x5b0 mm/page_alloc.c:4493
       __alloc_pages_noprof+0x16f/0x710 mm/page_alloc.c:4722
       alloc_pages_mpol_noprof+0x3e8/0x680 mm/mempolicy.c:2265
       alloc_pages_noprof mm/mempolicy.c:2345 [inline]
       folio_alloc_noprof+0x128/0x180 mm/mempolicy.c:2352
       filemap_alloc_folio_noprof+0xdf/0x500 mm/filemap.c:1010
       do_read_cache_folio+0x2eb/0x850 mm/filemap.c:3787
       read_mapping_folio include/linux/pagemap.h:1011 [inline]
       f2fs_commit_super+0x3c0/0x7d0 fs/f2fs/super.c:4032
       f2fs_record_stop_reason+0x13b/0x1d0 fs/f2fs/super.c:4079
       f2fs_handle_critical_error+0x2ac/0x5c0 fs/f2fs/super.c:4174
       f2fs_write_inode+0x35f/0x4d0 fs/f2fs/inode.c:785
       write_inode fs/fs-writeback.c:1503 [inline]
       __writeback_single_inode+0x711/0x10d0 fs/fs-writeback.c:1723
       writeback_single_inode+0x1f3/0x660 fs/fs-writeback.c:1779
       sync_inode_metadata+0xc4/0x120 fs/fs-writeback.c:2849
       f2fs_release_file+0xa8/0x100 fs/f2fs/file.c:1941
       __fput+0x23f/0x880 fs/file_table.c:431
       task_work_run+0x24f/0x310 kernel/task_work.c:228
       resume_user_mode_work include/linux/resume_user_mode.h:50 [inline]
       exit_to_user_mode_loop kernel/entry/common.c:114 [inline]
       exit_to_user_mode_prepare include/linux/entry-common.h:328 [inline]
       __syscall_exit_to_user_mode_work kernel/entry/common.c:207 [inline]
       syscall_exit_to_user_mode+0x168/0x370 kernel/entry/common.c:218
       do_syscall_64+0x100/0x230 arch/x86/entry/common.c:89
       entry_SYSCALL_64_after_hwframe+0x77/0x7f
---truncated---</description><pubDate>Sun, 29 Dec 2024 11:37:22 +0000</pubDate></item><item><title>CVE-2024-56745 | PCI: Fix reset_method_store() memory leak</title><link>https://www.cve.org/CVERecord?id=CVE-2024-56745</link><description>In the Linux kernel, the following vulnerability has been resolved:

PCI: Fix reset_method_store() memory leak

In reset_method_store(), a string is allocated via kstrndup() and assigned
to the local "options". options is then used in with strsep() to find
spaces:

  while ((name = strsep(&amp;amp;options, " ")) != NULL) {

If there are no remaining spaces, then options is set to NULL by strsep(),
so the subsequent kfree(options) doesn't free the memory allocated via
kstrndup().

Fix by using a separate tmp_options to iterate with strsep() so options is
preserved.</description><pubDate>Sun, 29 Dec 2024 11:37:22 +0000</pubDate></item><item><title>CVE-2024-56746 | fbdev: sh7760fb: Fix a possible memory leak in sh7760fb_alloc_mem()</title><link>https://www.cve.org/CVERecord?id=CVE-2024-56746</link><description>In the Linux kernel, the following vulnerability has been resolved:

fbdev: sh7760fb: Fix a possible memory leak in sh7760fb_alloc_mem()

When information such as info-&gt;screen_base is not ready, calling
sh7760fb_free_mem() does not release memory correctly. Call
dma_free_coherent() instead.</description><pubDate>Sun, 29 Dec 2024 11:37:23 +0000</pubDate></item><item><title>CVE-2024-56747 | scsi: qedi: Fix a possible memory leak in qedi_alloc_and_init_sb()</title><link>https://www.cve.org/CVERecord?id=CVE-2024-56747</link><description>In the Linux kernel, the following vulnerability has been resolved:

scsi: qedi: Fix a possible memory leak in qedi_alloc_and_init_sb()

Hook "qedi_ops-&gt;common-&gt;sb_init = qed_sb_init" does not release the DMA
memory sb_virt when it fails. Add dma_free_coherent() to free it. This
is the same way as qedr_alloc_mem_sb() and qede_alloc_mem_sb().</description><pubDate>Sun, 29 Dec 2024 11:37:23 +0000</pubDate></item><item><title>CVE-2024-56748 | scsi: qedf: Fix a possible memory leak in qedf_alloc_and_init_sb()</title><link>https://www.cve.org/CVERecord?id=CVE-2024-56748</link><description>In the Linux kernel, the following vulnerability has been resolved:

scsi: qedf: Fix a possible memory leak in qedf_alloc_and_init_sb()

Hook "qed_ops-&gt;common-&gt;sb_init = qed_sb_init" does not release the DMA
memory sb_virt when it fails. Add dma_free_coherent() to free it. This
is the same way as qedr_alloc_mem_sb() and qede_alloc_mem_sb().</description><pubDate>Sun, 29 Dec 2024 11:37:23 +0000</pubDate></item><item><title>CVE-2024-56749 | dlm: fix dlm_recover_members refcount on error</title><link>https://www.cve.org/CVERecord?id=CVE-2024-56749</link><description>In the Linux kernel, the following vulnerability has been resolved:

dlm: fix dlm_recover_members refcount on error

If dlm_recover_members() fails we don't drop the references of the
previous created root_list that holds and keep all rsbs alive during the
recovery. It might be not an unlikely event because ping_members() could
run into an -EINTR if another recovery progress was triggered again.</description><pubDate>Sun, 29 Dec 2024 11:37:24 +0000</pubDate></item><item><title>CVE-2024-56750 | erofs: fix blksize &amp;lt; PAGE_SIZE for file-backed mounts</title><link>https://www.cve.org/CVERecord?id=CVE-2024-56750</link><description>In the Linux kernel, the following vulnerability has been resolved:

erofs: fix blksize &lt; PAGE_SIZE for file-backed mounts

Adjust sb-&gt;s_blocksize{,_bits} directly for file-backed
mounts when the fs block size is smaller than PAGE_SIZE.

Previously, EROFS used sb_set_blocksize(), which caused
a panic if bdev-backed mounts is not used.</description><pubDate>Sun, 29 Dec 2024 11:37:24 +0000</pubDate></item><item><title>CVE-2024-56751 | ipv6: release nexthop on device removal</title><link>https://www.cve.org/CVERecord?id=CVE-2024-56751</link><description>In the Linux kernel, the following vulnerability has been resolved:

ipv6: release nexthop on device removal

The CI is hitting some aperiodic hangup at device removal time in the
pmtu.sh self-test:

unregister_netdevice: waiting for veth_A-R1 to become free. Usage count = 6
ref_tracker: veth_A-R1@ffff888013df15d8 has 1/5 users at
	dst_init+0x84/0x4a0
	dst_alloc+0x97/0x150
	ip6_dst_alloc+0x23/0x90
	ip6_rt_pcpu_alloc+0x1e6/0x520
	ip6_pol_route+0x56f/0x840
	fib6_rule_lookup+0x334/0x630
	ip6_route_output_flags+0x259/0x480
	ip6_dst_lookup_tail.constprop.0+0x5c2/0x940
	ip6_dst_lookup_flow+0x88/0x190
	udp_tunnel6_dst_lookup+0x2a7/0x4c0
	vxlan_xmit_one+0xbde/0x4a50 [vxlan]
	vxlan_xmit+0x9ad/0xf20 [vxlan]
	dev_hard_start_xmit+0x10e/0x360
	__dev_queue_xmit+0xf95/0x18c0
	arp_solicit+0x4a2/0xe00
	neigh_probe+0xaa/0xf0

While the first suspect is the dst_cache, explicitly tracking the dst
owing the last device reference via probes proved such dst is held by
the nexthop in the originating fib6_info.

Similar to commit f5b51fe804ec ("ipv6: route: purge exception on
removal"), we need to explicitly release the originating fib info when
disconnecting a to-be-removed device from a live ipv6 dst: move the
fib6_info cleanup into ip6_dst_ifdown().

Tested running:

./pmtu.sh cleanup_ipv6_exception

in a tight loop for more than 400 iterations with no spat, running an
unpatched kernel  I observed a splat every ~10 iterations.</description><pubDate>Sun, 29 Dec 2024 11:37:25 +0000</pubDate></item><item><title>CVE-2024-56752 | drm/nouveau/gr/gf100: Fix missing unlock in gf100_gr_chan_new()</title><link>https://www.cve.org/CVERecord?id=CVE-2024-56752</link><description>In the Linux kernel, the following vulnerability has been resolved:

drm/nouveau/gr/gf100: Fix missing unlock in gf100_gr_chan_new()

When the call to gf100_grctx_generate() fails, unlock gr-&gt;fecs.mutex
before returning the error.

Fixes smatch warning:

drivers/gpu/drm/nouveau/nvkm/engine/gr/gf100.c:480 gf100_gr_chan_new() warn: inconsistent returns '&amp;amp;gr-&gt;fecs.mutex'.</description><pubDate>Sun, 29 Dec 2024 11:37:25 +0000</pubDate></item><item><title>CVE-2024-56753 | drm/amdgpu/gfx9: Add Cleaner Shader Deinitialization in gfx_v9_0 Module</title><link>https://www.cve.org/CVERecord?id=CVE-2024-56753</link><description>In the Linux kernel, the following vulnerability has been resolved:

drm/amdgpu/gfx9: Add Cleaner Shader Deinitialization in gfx_v9_0 Module

This commit addresses an omission in the previous patch related to the
cleaner shader support for GFX9 hardware. Specifically, it adds the
necessary deinitialization code for the cleaner shader in the
gfx_v9_0_sw_fini function.

The added line amdgpu_gfx_cleaner_shader_sw_fini(adev); ensures that any
allocated resources for the cleaner shader are freed correctly, avoiding
potential memory leaks and ensuring that the GPU state is clean for the
next initialization sequence.</description><pubDate>Sun, 29 Dec 2024 11:37:25 +0000</pubDate></item><item><title>CVE-2024-56754 | crypto: caam - Fix the pointer passed to caam_qi_shutdown()</title><link>https://www.cve.org/CVERecord?id=CVE-2024-56754</link><description>In the Linux kernel, the following vulnerability has been resolved:

crypto: caam - Fix the pointer passed to caam_qi_shutdown()

The type of the last parameter given to devm_add_action_or_reset() is
"struct caam_drv_private *", but in caam_qi_shutdown(), it is casted to
"struct device *".

Pass the correct parameter to devm_add_action_or_reset() so that the
resources are released as expected.</description><pubDate>Sun, 29 Dec 2024 11:37:26 +0000</pubDate></item><item><title>CVE-2024-56755 | netfs/fscache: Add a memory barrier for FSCACHE_VOLUME_CREATING</title><link>https://www.cve.org/CVERecord?id=CVE-2024-56755</link><description>In the Linux kernel, the following vulnerability has been resolved:

netfs/fscache: Add a memory barrier for FSCACHE_VOLUME_CREATING

In fscache_create_volume(), there is a missing memory barrier between the
bit-clearing operation and the wake-up operation. This may cause a
situation where, after a wake-up, the bit-clearing operation hasn't been
detected yet, leading to an indefinite wait. The triggering process is as
follows:

  [cookie1]                [cookie2]                  [volume_work]
fscache_perform_lookup
  fscache_create_volume
                        fscache_perform_lookup
                          fscache_create_volume
			                        fscache_create_volume_work
                                                  cachefiles_acquire_volume
                                                  clear_and_wake_up_bit
    test_and_set_bit
                            test_and_set_bit
                              goto maybe_wait
      goto no_wait

In the above process, cookie1 and cookie2 has the same volume. When cookie1
enters the -no_wait- process, it will clear the bit and wake up the waiting
process. If a barrier is missing, it may cause cookie2 to remain in the
-wait- process indefinitely.

In commit 3288666c7256 ("fscache: Use clear_and_wake_up_bit() in
fscache_create_volume_work()"), barriers were added to similar operations
in fscache_create_volume_work(), but fscache_create_volume() was missed.

By combining the clear and wake operations into clear_and_wake_up_bit() to
fix this issue.</description><pubDate>Sun, 29 Dec 2024 11:37:26 +0000</pubDate></item><item><title>CVE-2024-56756 | nvme-pci: fix freeing of the HMB descriptor table</title><link>https://www.cve.org/CVERecord?id=CVE-2024-56756</link><description>In the Linux kernel, the following vulnerability has been resolved:

nvme-pci: fix freeing of the HMB descriptor table

The HMB descriptor table is sized to the maximum number of descriptors
that could be used for a given device, but __nvme_alloc_host_mem could
break out of the loop earlier on memory allocation failure and end up
using less descriptors than planned for, which leads to an incorrect
size passed to dma_free_coherent.

In practice this was not showing up because the number of descriptors
tends to be low and the dma coherent allocator always allocates and
frees at least a page.</description><pubDate>Sun, 29 Dec 2024 11:37:27 +0000</pubDate></item><item><title>CVE-2024-13008 | code-projects Responsive Hotel Site newsletter.php sql injection</title><link>https://www.cve.org/CVERecord?id=CVE-2024-13008</link><description>A vulnerability has been found in code-projects Responsive Hotel Site 1.0 and classified as critical. Affected by this vulnerability is an unknown functionality of the file /admin/newsletter.php. The manipulation of the argument eid leads to sql injection. The attack can be launched remotely. The exploit has been disclosed to the public and may be used.</description><pubDate>Sun, 29 Dec 2024 09:40:44 +0000</pubDate></item><item><title>CVE-2024-56710 | ceph: fix memory leak in ceph_direct_read_write()</title><link>https://www.cve.org/CVERecord?id=CVE-2024-56710</link><description>In the Linux kernel, the following vulnerability has been resolved:

ceph: fix memory leak in ceph_direct_read_write()

The bvecs array which is allocated in iter_get_bvecs_alloc() is leaked
and pages remain pinned if ceph_alloc_sparse_ext_map() fails.

There is no need to delay the allocation of sparse_ext map until after
the bvecs array is set up, so fix this by moving sparse_ext allocation
a bit earlier.  Also, make a similar adjustment in __ceph_sync_read()
for consistency (a leak of the same kind in __ceph_sync_read() has been
addressed differently).</description><pubDate>Sun, 29 Dec 2024 08:57:57 +0000</pubDate></item><item><title>CVE-2024-56711 | drm/panel: himax-hx83102: Add a check to prevent NULL pointer dereference</title><link>https://www.cve.org/CVERecord?id=CVE-2024-56711</link><description>In the Linux kernel, the following vulnerability has been resolved:

drm/panel: himax-hx83102: Add a check to prevent NULL pointer dereference

drm_mode_duplicate() could return NULL due to lack of memory,
which will then call NULL pointer dereference. Add a check to
prevent it.</description><pubDate>Sun, 29 Dec 2024 08:57:58 +0000</pubDate></item><item><title>CVE-2024-56712 | udmabuf: fix memory leak on last export_udmabuf() error path</title><link>https://www.cve.org/CVERecord?id=CVE-2024-56712</link><description>In the Linux kernel, the following vulnerability has been resolved:

udmabuf: fix memory leak on last export_udmabuf() error path

In export_udmabuf(), if dma_buf_fd() fails because the FD table is full, a
dma_buf owning the udmabuf has already been created; but the error handling
in udmabuf_create() will tear down the udmabuf without doing anything about
the containing dma_buf.

This leaves a dma_buf in memory that contains a dangling pointer; though
that doesn't seem to lead to anything bad except a memory leak.

Fix it by moving the dma_buf_fd() call out of export_udmabuf() so that we
can give it different error handling.

Note that the shape of this code changed a lot in commit 5e72b2b41a21
("udmabuf: convert udmabuf driver to use folios"); but the memory leak
seems to have existed since the introduction of udmabuf.</description><pubDate>Sun, 29 Dec 2024 08:57:58 +0000</pubDate></item><item><title>CVE-2024-56713 | net: netdevsim: fix nsim_pp_hold_write()</title><link>https://www.cve.org/CVERecord?id=CVE-2024-56713</link><description>In the Linux kernel, the following vulnerability has been resolved:

net: netdevsim: fix nsim_pp_hold_write()

nsim_pp_hold_write() has two problems:

1) It may return with rtnl held, as found by syzbot.

2) Its return value does not propagate an error if any.</description><pubDate>Sun, 29 Dec 2024 08:57:59 +0000</pubDate></item><item><title>CVE-2024-56714 | ionic: no double destroy workqueue</title><link>https://www.cve.org/CVERecord?id=CVE-2024-56714</link><description>In the Linux kernel, the following vulnerability has been resolved:

ionic: no double destroy workqueue

There are some FW error handling paths that can cause us to
try to destroy the workqueue more than once, so let's be sure
we're checking for that.

The case where this popped up was in an AER event where the
handlers got called in such a way that ionic_reset_prepare()
and thus ionic_dev_teardown() got called twice in a row.
The second time through the workqueue was already destroyed,
and destroy_workqueue() choked on the bad wq pointer.

We didn't hit this in AER handler testing before because at
that time we weren't using a private workqueue.  Later we
replaced the use of the system workqueue with our own private
workqueue but hadn't rerun the AER handler testing since then.</description><pubDate>Sun, 29 Dec 2024 08:57:59 +0000</pubDate></item><item><title>CVE-2024-56715 | ionic: Fix netdev notifier unregister on failure</title><link>https://www.cve.org/CVERecord?id=CVE-2024-56715</link><description>In the Linux kernel, the following vulnerability has been resolved:

ionic: Fix netdev notifier unregister on failure

If register_netdev() fails, then the driver leaks the netdev notifier.
Fix this by calling ionic_lif_unregister() on register_netdev()
failure. This will also call ionic_lif_unregister_phc() if it has
already been registered.</description><pubDate>Sun, 29 Dec 2024 08:58:00 +0000</pubDate></item><item><title>CVE-2024-56716 | netdevsim: prevent bad user input in nsim_dev_health_break_write()</title><link>https://www.cve.org/CVERecord?id=CVE-2024-56716</link><description>In the Linux kernel, the following vulnerability has been resolved:

netdevsim: prevent bad user input in nsim_dev_health_break_write()

If either a zero count or a large one is provided, kernel can crash.</description><pubDate>Sun, 29 Dec 2024 08:58:00 +0000</pubDate></item><item><title>CVE-2024-56717 | net: mscc: ocelot: fix incorrect IFH SRC_PORT field in ocelot_ifh_set_basic()</title><link>https://www.cve.org/CVERecord?id=CVE-2024-56717</link><description>In the Linux kernel, the following vulnerability has been resolved:

net: mscc: ocelot: fix incorrect IFH SRC_PORT field in ocelot_ifh_set_basic()

Packets injected by the CPU should have a SRC_PORT field equal to the
CPU port module index in the Analyzer block (ocelot-&gt;num_phys_ports).

The blamed commit copied the ocelot_ifh_set_basic() call incorrectly
from ocelot_xmit_common() in net/dsa/tag_ocelot.c. Instead of calling
with "x", it calls with BIT_ULL(x), but the field is not a port mask,
but rather a single port index.

[ side note: this is the technical debt of code duplication :( ]

The error used to be silent and doesn't appear to have other
user-visible manifestations, but with new changes in the packing
library, it now fails loudly as follows:

------------[ cut here ]------------
Cannot store 0x40 inside bits 46-43 - will truncate
sja1105 spi2.0: xmit timed out
WARNING: CPU: 1 PID: 102 at lib/packing.c:98 __pack+0x90/0x198
sja1105 spi2.0: timed out polling for tstamp
CPU: 1 UID: 0 PID: 102 Comm: felix_xmit
Tainted: G        W        N 6.13.0-rc1-00372-gf706b85d972d-dirty #2605
Call trace:
 __pack+0x90/0x198 (P)
 __pack+0x90/0x198 (L)
 packing+0x78/0x98
 ocelot_ifh_set_basic+0x260/0x368
 ocelot_port_inject_frame+0xa8/0x250
 felix_port_deferred_xmit+0x14c/0x258
 kthread_worker_fn+0x134/0x350
 kthread+0x114/0x138

The code path pertains to the ocelot switchdev driver and to the felix
secondary DSA tag protocol, ocelot-8021q. Here seen with ocelot-8021q.

The messenger (packing) is not really to blame, so fix the original
commit instead.</description><pubDate>Sun, 29 Dec 2024 08:58:01 +0000</pubDate></item><item><title>CVE-2024-56718 | net/smc: protect link down work from execute after lgr freed</title><link>https://www.cve.org/CVERecord?id=CVE-2024-56718</link><description>In the Linux kernel, the following vulnerability has been resolved:

net/smc: protect link down work from execute after lgr freed

link down work may be scheduled before lgr freed but execute
after lgr freed, which may result in crash. So it is need to
hold a reference before shedule link down work, and put the
reference after work executed or canceled.

The relevant crash call stack as follows:
 list_del corruption. prev-&gt;next should be ffffb638c9c0fe20,
    but was 0000000000000000
 ------------[ cut here ]------------
 kernel BUG at lib/list_debug.c:51!
 invalid opcode: 0000 [#1] SMP NOPTI
 CPU: 6 PID: 978112 Comm: kworker/6:119 Kdump: loaded Tainted: G #1
 Hardware name: Alibaba Cloud Alibaba Cloud ECS, BIOS 2221b89 04/01/2014
 Workqueue: events smc_link_down_work [smc]
 RIP: 0010:__list_del_entry_valid.cold+0x31/0x47
 RSP: 0018:ffffb638c9c0fdd8 EFLAGS: 00010086
 RAX: 0000000000000054 RBX: ffff942fb75e5128 RCX: 0000000000000000
 RDX: ffff943520930aa0 RSI: ffff94352091fc80 RDI: ffff94352091fc80
 RBP: 0000000000000000 R08: 0000000000000000 R09: ffffb638c9c0fc38
 R10: ffffb638c9c0fc30 R11: ffffffffa015eb28 R12: 0000000000000002
 R13: ffffb638c9c0fe20 R14: 0000000000000001 R15: ffff942f9cd051c0
 FS:  0000000000000000(0000) GS:ffff943520900000(0000) knlGS:0000000000000000
 CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
 CR2: 00007f4f25214000 CR3: 000000025fbae004 CR4: 00000000007706e0
 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
 PKRU: 55555554
 Call Trace:
  rwsem_down_write_slowpath+0x17e/0x470
  smc_link_down_work+0x3c/0x60 [smc]
  process_one_work+0x1ac/0x350
  worker_thread+0x49/0x2f0
  ? rescuer_thread+0x360/0x360
  kthread+0x118/0x140
  ? __kthread_bind_mask+0x60/0x60
  ret_from_fork+0x1f/0x30</description><pubDate>Sun, 29 Dec 2024 08:58:01 +0000</pubDate></item><item><title>CVE-2024-56719 | net: stmmac: fix TSO DMA API usage causing oops</title><link>https://www.cve.org/CVERecord?id=CVE-2024-56719</link><description>In the Linux kernel, the following vulnerability has been resolved:

net: stmmac: fix TSO DMA API usage causing oops

Commit 66600fac7a98 ("net: stmmac: TSO: Fix unbalanced DMA map/unmap
for non-paged SKB data") moved the assignment of tx_skbuff_dma[]'s
members to be later in stmmac_tso_xmit().

The buf (dma cookie) and len stored in this structure are passed to
dma_unmap_single() by stmmac_tx_clean(). The DMA API requires that
the dma cookie passed to dma_unmap_single() is the same as the value
returned from dma_map_single(). However, by moving the assignment
later, this is not the case when priv-&gt;dma_cap.addr64 &gt; 32 as "des"
is offset by proto_hdr_len.

This causes problems such as:

  dwc-eth-dwmac 2490000.ethernet eth0: Tx DMA map failed

and with DMA_API_DEBUG enabled:

  DMA-API: dwc-eth-dwmac 2490000.ethernet: device driver tries to +free DMA memory it has not allocated [device address=0x000000ffffcf65c0] [size=66 bytes]

Fix this by maintaining "des" as the original DMA cookie, and use
tso_des to pass the offset DMA cookie to stmmac_tso_allocator().

Full details of the crashes can be found at:
https://lore.kernel.org/all/d8112193-0386-4e14-b516-37c2d838171a@nvidia.com/
https://lore.kernel.org/all/klkzp5yn5kq5efgtrow6wbvnc46bcqfxs65nz3qy77ujr5turc@bwwhelz2l4dw/</description><pubDate>Sun, 29 Dec 2024 08:58:02 +0000</pubDate></item><item><title>CVE-2024-56709 | io_uring: check if iowq is killed before queuing</title><link>https://www.cve.org/CVERecord?id=CVE-2024-56709</link><description>In the Linux kernel, the following vulnerability has been resolved:

io_uring: check if iowq is killed before queuing

task work can be executed after the task has gone through io_uring
termination, whether it's the final task_work run or the fallback path.
In this case, task work will find -&gt;io_wq being already killed and
null'ed, which is a problem if it then tries to forward the request to
io_queue_iowq(). Make io_queue_iowq() fail requests in this case.

Note that it also checks PF_KTHREAD, because the user can first close
a DEFER_TASKRUN ring and shortly after kill the task, in which case
-&gt;iowq check would race.</description><pubDate>Sun, 29 Dec 2024 08:50:40 +0000</pubDate></item><item><title>CVE-2024-13007 | Codezips Event Management System contact.php sql injection</title><link>https://www.cve.org/CVERecord?id=CVE-2024-13007</link><description>A vulnerability, which was classified as critical, was found in Codezips Event Management System 1.0. Affected is an unknown function of the file /contact.php. The manipulation of the argument title leads to sql injection. It is possible to launch the attack remotely. The exploit has been disclosed to the public and may be used.</description><pubDate>Sun, 29 Dec 2024 08:43:43 +0000</pubDate></item><item><title>CVE-2024-13006 | 1000 Projects Human Resource Management System employeeview.php sql injection</title><link>https://www.cve.org/CVERecord?id=CVE-2024-13006</link><description>A vulnerability, which was classified as critical, has been found in 1000 Projects Human Resource Management System 1.0. This issue affects some unknown processing of the file /employeeview.php. The manipulation of the argument search leads to sql injection. The attack may be initiated remotely. The exploit has been disclosed to the public and may be used.</description><pubDate>Sun, 29 Dec 2024 08:18:58 +0000</pubDate></item><item><title>CVE-2024-13005 | 1000 Projects Attendance Tracking Management System attendance_action.php sql injection</title><link>https://www.cve.org/CVERecord?id=CVE-2024-13005</link><description>A vulnerability classified as critical was found in 1000 Projects Attendance Tracking Management System 1.0. This vulnerability affects unknown code of the file /admin/attendance_action.php. The manipulation of the argument attendance_id leads to sql injection. The attack can be initiated remotely. The exploit has been disclosed to the public and may be used.</description><pubDate>Sun, 29 Dec 2024 07:37:28 +0000</pubDate></item><item><title>CVE-2024-56737 | GNU GRUB (aka GRUB2) through 2.12 has a heap-based buffer overflow in fs/hfs.c via crafted sblock data in an HFS filesystem.</title><link>https://www.cve.org/CVERecord?id=CVE-2024-56737</link><description>GNU GRUB (aka GRUB2) through 2.12 has a heap-based buffer overflow in fs/hfs.c via crafted sblock data in an HFS filesystem.</description><pubDate>Sun, 29 Dec 2024 06:47:55 +0000</pubDate></item><item><title>CVE-2024-56738 | GNU GRUB (aka GRUB2) through 2.12 does not use a constant-time algorithm for grub_crypto_memcmp and thus allows side-channel attacks.</title><link>https://www.cve.org/CVERecord?id=CVE-2024-56738</link><description>GNU GRUB (aka GRUB2) through 2.12 does not use a constant-time algorithm for grub_crypto_memcmp and thus allows side-channel attacks.</description><pubDate>Sun, 29 Dec 2024 06:47:56 +0000</pubDate></item><item><title>CVE-2024-13004 | PHPGurukul Complaint Management System category.php sql injection</title><link>https://www.cve.org/CVERecord?id=CVE-2024-13004</link><description>A vulnerability classified as critical has been found in PHPGurukul Complaint Management System 1.0. This affects an unknown part of the file /admin/category.php. The manipulation of the argument state leads to sql injection. It is possible to initiate the attack remotely. The exploit has been disclosed to the public and may be used.</description><pubDate>Sun, 29 Dec 2024 06:39:31 +0000</pubDate></item><item><title>CVE-2018-25107 | The Crypt::Random::Source package before 0.13 for Perl has a fallback to the built-in rand() function, which is not a secure source of rando...</title><link>https://www.cve.org/CVERecord?id=CVE-2018-25107</link><description>The Crypt::Random::Source package before 0.13 for Perl has a fallback to the built-in rand() function, which is not a secure source of random bits.</description><pubDate>Sun, 29 Dec 2024 06:39:32 +0000</pubDate></item><item><title>CVE-2024-12238 | Ninja Forms – The Contact Form Builder That Grows With You &amp;lt;= 3.8.22 - Authenticated (Subscriber+) Arbitrary Shortcode Execution</title><link>https://www.cve.org/CVERecord?id=CVE-2024-12238</link><description>The The Ninja Forms – The Contact Form Builder That Grows With You plugin for WordPress is vulnerable to arbitrary shortcode execution in all versions up to, and including, 3.8.22. This is due to the software allowing users to execute an action that does not properly validate a value before running do_shortcode. This makes it possible for authenticated attackers, with Subscriber-level access and above, to execute arbitrary shortcodes.</description><pubDate>Sun, 29 Dec 2024 05:28:07 +0000</pubDate></item><item><title>CVE-2024-13003 | 1000 Projects Portfolio Management System MCA update_ed.php sql injection</title><link>https://www.cve.org/CVERecord?id=CVE-2024-13003</link><description>A vulnerability was found in 1000 Projects Portfolio Management System MCA 1.0. It has been rated as critical. Affected by this issue is some unknown functionality of the file /update_ed.php. The manipulation of the argument e_id leads to sql injection. The attack may be launched remotely. The exploit has been disclosed to the public and may be used.</description><pubDate>Sun, 29 Dec 2024 04:30:24 +0000</pubDate></item><item><title>CVE-2024-13002 | 1000 Projects Bookstore Management System order_process.php sql injection</title><link>https://www.cve.org/CVERecord?id=CVE-2024-13002</link><description>A vulnerability was found in 1000 Projects Bookstore Management System 1.0. It has been declared as critical. Affected by this vulnerability is an unknown functionality of the file /order_process.php. The manipulation of the argument fnm leads to sql injection. The attack can be launched remotely. The exploit has been disclosed to the public and may be used.</description><pubDate>Sun, 29 Dec 2024 03:47:28 +0000</pubDate></item><item><title>CVE-2024-13001 | PHPGurukul Small CRM index.php sql injection</title><link>https://www.cve.org/CVERecord?id=CVE-2024-13001</link><description>A vulnerability was found in PHPGurukul Small CRM 1.0. It has been classified as critical. Affected is an unknown function of the file /admin/index.php. The manipulation of the argument email leads to sql injection. It is possible to launch the attack remotely. The exploit has been disclosed to the public and may be used.</description><pubDate>Sun, 29 Dec 2024 03:08:43 +0000</pubDate></item><item><title>CVE-2024-13000 | PHPGurukul Small CRM quote-details.php sql injection</title><link>https://www.cve.org/CVERecord?id=CVE-2024-13000</link><description>A vulnerability was found in PHPGurukul Small CRM 1.0 and classified as critical. This issue affects some unknown processing of the file /admin/quote-details.php. The manipulation of the argument id leads to sql injection. The attack may be initiated remotely. The exploit has been disclosed to the public and may be used.</description><pubDate>Sun, 29 Dec 2024 03:08:44 +0000</pubDate></item><item><title>CVE-2024-12999 | PHPGurukul Small CRM edit-user.php sql injection</title><link>https://www.cve.org/CVERecord?id=CVE-2024-12999</link><description>A vulnerability has been found in PHPGurukul Small CRM 1.0 and classified as critical. This vulnerability affects unknown code of the file /admin/edit-user.php. The manipulation of the argument id leads to sql injection. The attack can be initiated remotely. The exploit has been disclosed to the public and may be used.</description><pubDate>Sun, 29 Dec 2024 02:36:30 +0000</pubDate></item><item><title>CVE-2024-12998 | code-projects Online Car Rental System GET Parameter index.php cross site scripting</title><link>https://www.cve.org/CVERecord?id=CVE-2024-12998</link><description>A vulnerability, which was classified as problematic, was found in code-projects Online Car Rental System 1.0. This affects an unknown part of the file /index.php of the component GET Parameter Handler. The manipulation leads to cross site scripting. It is possible to initiate the attack remotely. The exploit has been disclosed to the public and may be used.</description><pubDate>Sat, 28 Dec 2024 21:38:16 +0000</pubDate></item><item><title>CVE-2024-56512 | Apache NiFi: Missing Complete Authorization for Parameter and Service References</title><link>https://www.cve.org/CVERecord?id=CVE-2024-56512</link><description>Apache NiFi 1.10.0 through 2.0.0 are missing fine-grained authorization checking for Parameter Contexts, referenced Controller Services, and referenced Parameter Providers, when creating new Process Groups.

Creating a new Process Group can include binding to a Parameter Context, but in cases where the Process Group did not reference any Parameter values, the framework did not check user authorization for the bound Parameter Context. Missing authorization for a bound Parameter Context enabled clients to download non-sensitive Parameter values after creating the Process Group.

Creating a new Process Group can also include referencing existing Controller Services or Parameter Providers. The framework did not check user authorization for referenced Controller Services or Parameter Providers, enabling clients to create Process Groups and use these components that were otherwise unauthorized.

This vulnerability is limited in scope to authenticated users authorized to create Process Groups. The scope is further limited to deployments with component-based authorization policies. Upgrading to Apache NiFi 2.1.0 is the recommended mitigation, which includes authorization checking for Parameter and Controller Service references on Process Group creation.</description><pubDate>Sat, 28 Dec 2024 16:30:39 +0000</pubDate></item><item><title>CVE-2024-12995 | ruifang-tech Rebuild Project Tasks Section tasks cross site scripting</title><link>https://www.cve.org/CVERecord?id=CVE-2024-12995</link><description>A vulnerability classified as problematic has been found in ruifang-tech Rebuild 3.8.6. This affects an unknown part of the file /project/050-9000000000000001/tasks of the component Project Tasks Section. The manipulation of the argument description leads to cross site scripting. It is possible to initiate the attack remotely. The exploit has been disclosed to the public and may be used. The vendor was contacted early about this disclosure but did not respond in any way.</description><pubDate>Sat, 28 Dec 2024 13:35:55 +0000</pubDate></item><item><title>CVE-2024-12994 | running-elephant Datart File Upload import extractModel deserialization</title><link>https://www.cve.org/CVERecord?id=CVE-2024-12994</link><description>A vulnerability was found in running-elephant Datart 1.0.0-rc3. It has been rated as critical. Affected by this issue is the function extractModel of the file /import of the component File Upload. The manipulation of the argument file leads to deserialization. The attack may be launched remotely. The exploit has been disclosed to the public and may be used. The vendor was contacted early about this disclosure but did not respond in any way.</description><pubDate>Sat, 28 Dec 2024 13:13:10 +0000</pubDate></item><item><title>CVE-2024-56676 | thermal: testing: Initialize some variables annoteded with _free()</title><link>https://www.cve.org/CVERecord?id=CVE-2024-56676</link><description>In the Linux kernel, the following vulnerability has been resolved:

thermal: testing: Initialize some variables annoteded with _free()

Variables annotated with __free() need to be initialized if the function
can return before they get updated for the first time or the attempt to
free the memory pointed to by them upon function return may crash the
kernel.

Fix this issue in some places in the thermal testing code.</description><pubDate>Sat, 28 Dec 2024 09:54:44 +0000</pubDate></item><item><title>CVE-2024-56677 | powerpc/fadump: Move fadump_cma_init to setup_arch() after initmem_init()</title><link>https://www.cve.org/CVERecord?id=CVE-2024-56677</link><description>In the Linux kernel, the following vulnerability has been resolved:

powerpc/fadump: Move fadump_cma_init to setup_arch() after initmem_init()

During early init CMA_MIN_ALIGNMENT_BYTES can be PAGE_SIZE,
since pageblock_order is still zero and it gets initialized
later during initmem_init() e.g.
setup_arch() -&gt; initmem_init() -&gt; sparse_init() -&gt; set_pageblock_order()

One such use case where this causes issue is -
early_setup() -&gt; early_init_devtree() -&gt; fadump_reserve_mem() -&gt; fadump_cma_init()

This causes CMA memory alignment check to be bypassed in
cma_init_reserved_mem(). Then later cma_activate_area() can hit
a VM_BUG_ON_PAGE(pfn &amp; ((1 &lt;&lt; order) - 1)) if the reserved memory
area was not pageblock_order aligned.

Fix it by moving the fadump_cma_init() after initmem_init(),
where other such cma reservations also gets called.


==============
page: refcount:0 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x10010
flags: 0x13ffff800000000(node=1|zone=0|lastcpupid=0x7ffff) CMA
raw: 013ffff800000000 5deadbeef0000100 5deadbeef0000122 0000000000000000
raw: 0000000000000000 0000000000000000 00000000ffffffff 0000000000000000
page dumped because: VM_BUG_ON_PAGE(pfn &amp; ((1 &lt;&lt; order) - 1))
------------[ cut here ]------------
kernel BUG at mm/page_alloc.c:778!

Call Trace:
__free_one_page+0x57c/0x7b0 (unreliable)
free_pcppages_bulk+0x1a8/0x2c8
free_unref_page_commit+0x3d4/0x4e4
free_unref_page+0x458/0x6d0
init_cma_reserved_pageblock+0x114/0x198
cma_init_reserved_areas+0x270/0x3e0
do_one_initcall+0x80/0x2f8
kernel_init_freeable+0x33c/0x530
kernel_init+0x34/0x26c
ret_from_kernel_user_thread+0x14/0x1c</description><pubDate>Sat, 28 Dec 2024 09:54:45 +0000</pubDate></item><item><title>CVE-2024-56678 | powerpc/mm/fault: Fix kfence page fault reporting</title><link>https://www.cve.org/CVERecord?id=CVE-2024-56678</link><description>In the Linux kernel, the following vulnerability has been resolved:

powerpc/mm/fault: Fix kfence page fault reporting

copy_from_kernel_nofault() can be called when doing read of /proc/kcore.
/proc/kcore can have some unmapped kfence objects which when read via
copy_from_kernel_nofault() can cause page faults. Since *_nofault()
functions define their own fixup table for handling fault, use that
instead of asking kfence to handle such faults.

Hence we search the exception tables for the nip which generated the
fault. If there is an entry then we let the fixup table handler handle the
page fault by returning an error from within ___do_page_fault().

This can be easily triggered if someone tries to do dd from /proc/kcore.
eg. dd if=/proc/kcore of=/dev/null bs=1M

Some example false negatives:

  ===============================
  BUG: KFENCE: invalid read in copy_from_kernel_nofault+0x9c/0x1a0
  Invalid read at 0xc0000000fdff0000:
   copy_from_kernel_nofault+0x9c/0x1a0
   0xc00000000665f950
   read_kcore_iter+0x57c/0xa04
   proc_reg_read_iter+0xe4/0x16c
   vfs_read+0x320/0x3ec
   ksys_read+0x90/0x154
   system_call_exception+0x120/0x310
   system_call_vectored_common+0x15c/0x2ec

  BUG: KFENCE: use-after-free read in copy_from_kernel_nofault+0x9c/0x1a0
  Use-after-free read at 0xc0000000fe050000 (in kfence-#2):
   copy_from_kernel_nofault+0x9c/0x1a0
   0xc00000000665f950
   read_kcore_iter+0x57c/0xa04
   proc_reg_read_iter+0xe4/0x16c
   vfs_read+0x320/0x3ec
   ksys_read+0x90/0x154
   system_call_exception+0x120/0x310
   system_call_vectored_common+0x15c/0x2ec</description><pubDate>Sat, 28 Dec 2024 09:54:45 +0000</pubDate></item><item><title>CVE-2024-56679 | octeontx2-pf: handle otx2_mbox_get_rsp errors in otx2_common.c</title><link>https://www.cve.org/CVERecord?id=CVE-2024-56679</link><description>In the Linux kernel, the following vulnerability has been resolved:

octeontx2-pf: handle otx2_mbox_get_rsp errors in otx2_common.c

Add error pointer check after calling otx2_mbox_get_rsp().</description><pubDate>Sat, 28 Dec 2024 09:54:45 +0000</pubDate></item><item><title>CVE-2024-56680 | media: intel/ipu6: do not handle interrupts when device is disabled</title><link>https://www.cve.org/CVERecord?id=CVE-2024-56680</link><description>In the Linux kernel, the following vulnerability has been resolved:

media: intel/ipu6: do not handle interrupts when device is disabled

Some IPU6 devices have shared interrupts. We need to handle properly
case when interrupt is triggered from other device on shared irq line
and IPU6 itself disabled. In such case we get 0xffffffff from
ISR_STATUS register and handle all irq's cases, for what we are not
not prepared and usually hang the whole system.

To avoid the issue use pm_runtime_get_if_active() to check if
the device is enabled and prevent suspending it when we handle irq
until the end of irq. Additionally use synchronize_irq() in suspend</description><pubDate>Sat, 28 Dec 2024 09:54:46 +0000</pubDate></item><item><title>CVE-2024-56681 | crypto: bcm - add error check in the ahash_hmac_init function</title><link>https://www.cve.org/CVERecord?id=CVE-2024-56681</link><description>In the Linux kernel, the following vulnerability has been resolved:

crypto: bcm - add error check in the ahash_hmac_init function

The ahash_init functions may return fails. The ahash_hmac_init should
not return ok when ahash_init returns error. For an example, ahash_init
will return -ENOMEM when allocation memory is error.</description><pubDate>Sat, 28 Dec 2024 09:54:46 +0000</pubDate></item><item><title>CVE-2024-56682 | irqchip/riscv-aplic: Prevent crash when MSI domain is missing</title><link>https://www.cve.org/CVERecord?id=CVE-2024-56682</link><description>In the Linux kernel, the following vulnerability has been resolved:

irqchip/riscv-aplic: Prevent crash when MSI domain is missing

If the APLIC driver is probed before the IMSIC driver, the parent MSI
domain will be missing, which causes a NULL pointer dereference in
msi_create_device_irq_domain().

Avoid this by deferring probe until the parent MSI domain is available. Use
dev_err_probe() to avoid printing an error message when returning
-EPROBE_DEFER.</description><pubDate>Sat, 28 Dec 2024 09:54:47 +0000</pubDate></item><item><title>CVE-2024-56683 | drm/vc4: hdmi: Avoid hang with debug registers when suspended</title><link>https://www.cve.org/CVERecord?id=CVE-2024-56683</link><description>In the Linux kernel, the following vulnerability has been resolved:

drm/vc4: hdmi: Avoid hang with debug registers when suspended

Trying to read /sys/kernel/debug/dri/1/hdmi1_regs
when the hdmi is disconnected results in a fatal system hang.

This is due to the pm suspend code disabling the dvp clock.
That is just a gate of the 108MHz clock in DVP_HT_RPI_MISC_CONFIG,
which results in accesses hanging AXI bus.

Protect against this.</description><pubDate>Sat, 28 Dec 2024 09:54:47 +0000</pubDate></item><item><title>CVE-2024-56684 | mailbox: mtk-cmdq: fix wrong use of sizeof in cmdq_get_clocks()</title><link>https://www.cve.org/CVERecord?id=CVE-2024-56684</link><description>In the Linux kernel, the following vulnerability has been resolved:

mailbox: mtk-cmdq: fix wrong use of sizeof in cmdq_get_clocks()

It should be size of the struct clk_bulk_data, not data pointer pass to
devm_kcalloc().</description><pubDate>Sat, 28 Dec 2024 09:54:47 +0000</pubDate></item><item><title>CVE-2024-56685 | ASoC: mediatek: Check num_codecs is not zero to avoid panic during probe</title><link>https://www.cve.org/CVERecord?id=CVE-2024-56685</link><description>In the Linux kernel, the following vulnerability has been resolved:

ASoC: mediatek: Check num_codecs is not zero to avoid panic during probe

Following commit 13f58267cda3 ("ASoC: soc.h: don't create dummy
Component via COMP_DUMMY()"), COMP_DUMMY() became an array with zero
length, and only gets populated with the dummy struct after the card is
registered. Since the sound card driver's probe happens before the card
registration, accessing any of the members of a dummy component during
probe will result in undefined behavior.

This can be observed in the mt8188 and mt8195 machine sound drivers. By
omitting a dai link subnode in the sound card's node in the Devicetree,
the default uninitialized dummy codec is used, and when its dai_name
pointer gets passed to strcmp() it results in a null pointer dereference
and a kernel panic.

In addition to that, set_card_codec_info() in the generic helpers file,
mtk-soundcard-driver.c, will populate a dai link with a dummy codec when
a dai link node is present in DT but with no codec property.

The result is that at probe time, a dummy codec can either be
uninitialized with num_codecs = 0, or be an initialized dummy codec,
with num_codecs = 1 and dai_name = "snd-soc-dummy-dai". In order to
accommodate for both situations, check that num_codecs is not zero
before accessing the codecs' fields but still check for the codec's dai
name against "snd-soc-dummy-dai" as needed.

While at it, also drop the check that dai_name is not null in the mt8192
driver, introduced in commit 4d4e1b6319e5 ("ASoC: mediatek: mt8192:
Check existence of dai_name before dereferencing"), as it is actually
redundant given the preceding num_codecs != 0 check.</description><pubDate>Sat, 28 Dec 2024 09:54:48 +0000</pubDate></item><item><title>CVE-2024-56686 | ext4: fix race in buffer_head read fault injection</title><link>https://www.cve.org/CVERecord?id=CVE-2024-56686</link><description>In the Linux kernel, the following vulnerability has been resolved:

ext4: fix race in buffer_head read fault injection

When I enabled ext4 debug for fault injection testing, I encountered the
following warning:

  EXT4-fs error (device sda): ext4_read_inode_bitmap:201: comm fsstress:
         Cannot read inode bitmap - block_group = 8, inode_bitmap = 1051
  WARNING: CPU: 0 PID: 511 at fs/buffer.c:1181 mark_buffer_dirty+0x1b3/0x1d0

The root cause of the issue lies in the improper implementation of ext4's
buffer_head read fault injection. The actual completion of buffer_head
read and the buffer_head fault injection are not atomic, which can lead
to the uptodate flag being cleared on normally used buffer_heads in race
conditions.

[CPU0]           [CPU1]         [CPU2]
ext4_read_inode_bitmap
  ext4_read_bh()
  
                 ext4_read_inode_bitmap
                   if (buffer_uptodate(bh))
                     return bh
                               jbd2_journal_commit_transaction
                                 __jbd2_journal_refile_buffer
                                   __jbd2_journal_unfile_buffer
                                     __jbd2_journal_temp_unlink_buffer
  ext4_simulate_fail_bh()
    clear_buffer_uptodate
                                      mark_buffer_dirty
                                        
                                        WARN_ON_ONCE(!buffer_uptodate(bh))

The best approach would be to perform fault injection in the IO completion
callback function, rather than after IO completion. However, the IO
completion callback function cannot get the fault injection code in sb.

Fix it by passing the result of fault injection into the bh read function,
we simulate faults within the bh read function itself. This requires adding
an extra parameter to the bh read functions that need fault injection.</description><pubDate>Sat, 28 Dec 2024 09:54:48 +0000</pubDate></item><item><title>CVE-2024-56687 | usb: musb: Fix hardware lockup on first Rx endpoint request</title><link>https://www.cve.org/CVERecord?id=CVE-2024-56687</link><description>In the Linux kernel, the following vulnerability has been resolved:

usb: musb: Fix hardware lockup on first Rx endpoint request

There is a possibility that a request's callback could be invoked from
usb_ep_queue() (call trace below, supplemented with missing calls):

req-&gt;complete from usb_gadget_giveback_request
	(drivers/usb/gadget/udc/core.c:999)
usb_gadget_giveback_request from musb_g_giveback
	(drivers/usb/musb/musb_gadget.c:147)
musb_g_giveback from rxstate
	(drivers/usb/musb/musb_gadget.c:784)
rxstate from musb_ep_restart
	(drivers/usb/musb/musb_gadget.c:1169)
musb_ep_restart from musb_ep_restart_resume_work
	(drivers/usb/musb/musb_gadget.c:1176)
musb_ep_restart_resume_work from musb_queue_resume_work
	(drivers/usb/musb/musb_core.c:2279)
musb_queue_resume_work from musb_gadget_queue
	(drivers/usb/musb/musb_gadget.c:1241)
musb_gadget_queue from usb_ep_queue
	(drivers/usb/gadget/udc/core.c:300)

According to the docstring of usb_ep_queue(), this should not happen:

"Note that @req's -&gt;complete() callback must never be called from within
usb_ep_queue() as that can create deadlock situations."

In fact, a hardware lockup might occur in the following sequence:

1. The gadget is initialized using musb_gadget_enable().
2. Meanwhile, a packet arrives, and the RXPKTRDY flag is set, raising an
   interrupt.
3. If IRQs are enabled, the interrupt is handled, but musb_g_rx() finds an
   empty queue (next_request() returns NULL). The interrupt flag has
   already been cleared by the glue layer handler, but the RXPKTRDY flag
   remains set.
4. The first request is enqueued using usb_ep_queue(), leading to the call
   of req-&gt;complete(), as shown in the call trace above.
5. If the callback enables IRQs and another packet is waiting, step (3)
   repeats. The request queue is empty because usb_g_giveback() removes the
   request before invoking the callback.
6. The endpoint remains locked up, as the interrupt triggered by hardware
   setting the RXPKTRDY flag has been handled, but the flag itself remains
   set.

For this scenario to occur, it is only necessary for IRQs to be enabled at
some point during the complete callback. This happens with the USB Ethernet
gadget, whose rx_complete() callback calls netif_rx(). If called in the
task context, netif_rx() disables the bottom halves (BHs). When the BHs are
re-enabled, IRQs are also enabled to allow soft IRQs to be processed. The
gadget itself is initialized at module load (or at boot if built-in), but
the first request is enqueued when the network interface is brought up,
triggering rx_complete() in the task context via ioctl(). If a packet
arrives while the interface is down, it can prevent the interface from
receiving any further packets from the USB host.

The situation is quite complicated with many parties involved. This
particular issue can be resolved in several possible ways:

1. Ensure that callbacks never enable IRQs. This would be difficult to
   enforce, as discovering how netif_rx() interacts with interrupts was
   already quite challenging and u_ether is not the only function driver.
   Similar "bugs" could be hidden in other drivers as well.
2. Disable MUSB interrupts in musb_g_giveback() before calling the callback
   and re-enable them afterwars (by calling musb_{dis,en}able_interrupts(),
   for example). This would ensure that MUSB interrupts are not handled
   during the callback, even if IRQs are enabled. In fact, it would allow
   IRQs to be enabled when releasing the lock. However, this feels like an
   inelegant hack.
3. Modify the interrupt handler to clear the RXPKTRDY flag if the request
   queue is empty. While this approach also feels like a hack, it wastes
   CPU time by attempting to handle incoming packets when the software is
   not ready to process them.
4. Flush the Rx FIFO instead of calling rxstate() in musb_ep_restart().
   This ensures that the hardware can receive packets when there is at
   least one request in the queue. Once I
---truncated---</description><pubDate>Sat, 28 Dec 2024 09:54:49 +0000</pubDate></item><item><title>CVE-2024-56688 | sunrpc: clear XPRT_SOCK_UPD_TIMEOUT when reset transport</title><link>https://www.cve.org/CVERecord?id=CVE-2024-56688</link><description>In the Linux kernel, the following vulnerability has been resolved:

sunrpc: clear XPRT_SOCK_UPD_TIMEOUT when reset transport

Since transport-&gt;sock has been set to NULL during reset transport,
XPRT_SOCK_UPD_TIMEOUT also needs to be cleared. Otherwise, the
xs_tcp_set_socket_timeouts() may be triggered in xs_tcp_send_request()
to dereference the transport-&gt;sock that has been set to NULL.</description><pubDate>Sat, 28 Dec 2024 09:54:49 +0000</pubDate></item><item><title>CVE-2024-56689 | PCI: endpoint: epf-mhi: Avoid NULL dereference if DT lacks &amp;#x27;mmio&amp;#x27;</title><link>https://www.cve.org/CVERecord?id=CVE-2024-56689</link><description>In the Linux kernel, the following vulnerability has been resolved:

PCI: endpoint: epf-mhi: Avoid NULL dereference if DT lacks 'mmio'

If platform_get_resource_byname() fails and returns NULL because DT lacks
an 'mmio' property for the MHI endpoint, dereferencing res-&gt;start will
cause a NULL pointer access. Add a check to prevent it.

[kwilczynski: error message update per the review feedback]
[bhelgaas: commit log]</description><pubDate>Sat, 28 Dec 2024 09:54:50 +0000</pubDate></item><item><title>CVE-2024-56690 | crypto: pcrypt - Call crypto layer directly when padata_do_parallel() return -EBUSY</title><link>https://www.cve.org/CVERecord?id=CVE-2024-56690</link><description>In the Linux kernel, the following vulnerability has been resolved:

crypto: pcrypt - Call crypto layer directly when padata_do_parallel() return -EBUSY

Since commit 8f4f68e788c3 ("crypto: pcrypt - Fix hungtask for
PADATA_RESET"), the pcrypt encryption and decryption operations return
-EAGAIN when the CPU goes online or offline. In alg_test(), a WARN is
generated when pcrypt_aead_decrypt() or pcrypt_aead_encrypt() returns
-EAGAIN, the unnecessary panic will occur when panic_on_warn set 1.
Fix this issue by calling crypto layer directly without parallelization
in that case.</description><pubDate>Sat, 28 Dec 2024 09:54:50 +0000</pubDate></item><item><title>CVE-2024-56691 | mfd: intel_soc_pmic_bxtwc: Use IRQ domain for USB Type-C device</title><link>https://www.cve.org/CVERecord?id=CVE-2024-56691</link><description>In the Linux kernel, the following vulnerability has been resolved:

mfd: intel_soc_pmic_bxtwc: Use IRQ domain for USB Type-C device

While design wise the idea of converting the driver to use
the hierarchy of the IRQ chips is correct, the implementation
has (inherited) flaws. This was unveiled when platform_get_irq()
had started WARN() on IRQ 0 that is supposed to be a Linux
IRQ number (also known as vIRQ).

Rework the driver to respect IRQ domain when creating each MFD
device separately, as the domain is not the same for all of them.</description><pubDate>Sat, 28 Dec 2024 09:54:50 +0000</pubDate></item><item><title>CVE-2024-56692 | f2fs: fix to do sanity check on node blkaddr in truncate_node()</title><link>https://www.cve.org/CVERecord?id=CVE-2024-56692</link><description>In the Linux kernel, the following vulnerability has been resolved:

f2fs: fix to do sanity check on node blkaddr in truncate_node()

syzbot reports a f2fs bug as below:

------------[ cut here ]------------
kernel BUG at fs/f2fs/segment.c:2534!
RIP: 0010:f2fs_invalidate_blocks+0x35f/0x370 fs/f2fs/segment.c:2534
Call Trace:
 truncate_node+0x1ae/0x8c0 fs/f2fs/node.c:909
 f2fs_remove_inode_page+0x5c2/0x870 fs/f2fs/node.c:1288
 f2fs_evict_inode+0x879/0x15c0 fs/f2fs/inode.c:856
 evict+0x4e8/0x9b0 fs/inode.c:723
 f2fs_handle_failed_inode+0x271/0x2e0 fs/f2fs/inode.c:986
 f2fs_create+0x357/0x530 fs/f2fs/namei.c:394
 lookup_open fs/namei.c:3595 [inline]
 open_last_lookups fs/namei.c:3694 [inline]
 path_openat+0x1c03/0x3590 fs/namei.c:3930
 do_filp_open+0x235/0x490 fs/namei.c:3960
 do_sys_openat2+0x13e/0x1d0 fs/open.c:1415
 do_sys_open fs/open.c:1430 [inline]
 __do_sys_openat fs/open.c:1446 [inline]
 __se_sys_openat fs/open.c:1441 [inline]
 __x64_sys_openat+0x247/0x2a0 fs/open.c:1441
 do_syscall_x64 arch/x86/entry/common.c:52 [inline]
 do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83
 entry_SYSCALL_64_after_hwframe+0x77/0x7f
RIP: 0010:f2fs_invalidate_blocks+0x35f/0x370 fs/f2fs/segment.c:2534

The root cause is: on a fuzzed image, blkaddr in nat entry may be
corrupted, then it will cause system panic when using it in
f2fs_invalidate_blocks(), to avoid this, let's add sanity check on
nat blkaddr in truncate_node().</description><pubDate>Sat, 28 Dec 2024 09:54:51 +0000</pubDate></item><item><title>CVE-2024-56693 | brd: defer automatic disk creation until module initialization succeeds</title><link>https://www.cve.org/CVERecord?id=CVE-2024-56693</link><description>In the Linux kernel, the following vulnerability has been resolved:

brd: defer automatic disk creation until module initialization succeeds

My colleague Wupeng found the following problems during fault injection:

BUG: unable to handle page fault for address: fffffbfff809d073
PGD 6e648067 P4D 123ec8067 PUD 123ec4067 PMD 100e38067 PTE 0
Oops: Oops: 0000 [#1] PREEMPT SMP KASAN NOPTI
CPU: 5 UID: 0 PID: 755 Comm: modprobe Not tainted 6.12.0-rc3+ #17
Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS
1.16.1-2.fc37 04/01/2014
RIP: 0010:__asan_load8+0x4c/0xa0
...
Call Trace:
 
 blkdev_put_whole+0x41/0x70
 bdev_release+0x1a3/0x250
 blkdev_release+0x11/0x20
 __fput+0x1d7/0x4a0
 task_work_run+0xfc/0x180
 syscall_exit_to_user_mode+0x1de/0x1f0
 do_syscall_64+0x6b/0x170
 entry_SYSCALL_64_after_hwframe+0x76/0x7e

loop_init() is calling loop_add() after __register_blkdev() succeeds and
is ignoring disk_add() failure from loop_add(), for loop_add() failure
is not fatal and successfully created disks are already visible to
bdev_open().

brd_init() is currently calling brd_alloc() before __register_blkdev()
succeeds and is releasing successfully created disks when brd_init()
returns an error. This can cause UAF for the latter two case:

case 1:
    T1:
modprobe brd
  brd_init
    brd_alloc(0) // success
      add_disk
        disk_scan_partitions
          bdev_file_open_by_dev // alloc file
          fput // won't free until back to userspace
    brd_alloc(1) // failed since mem alloc error inject
  // error path for modprobe will release code segment
  // back to userspace
  __fput
    blkdev_release
      bdev_release
        blkdev_put_whole
          bdev-&gt;bd_disk-&gt;fops-&gt;release // fops is freed now, UAF!

case 2:
    T1:                            T2:
modprobe brd
  brd_init
    brd_alloc(0) // success
                                   open(/dev/ram0)
    brd_alloc(1) // fail
  // error path for modprobe

                                   close(/dev/ram0)
                                   ...
                                   /* UAF! */
                                   bdev-&gt;bd_disk-&gt;fops-&gt;release

Fix this problem by following what loop_init() does. Besides,
reintroduce brd_devices_mutex to help serialize modifications to
brd_list.</description><pubDate>Sat, 28 Dec 2024 09:54:51 +0000</pubDate></item><item><title>CVE-2024-56694 | bpf: fix recursive lock when verdict program return SK_PASS</title><link>https://www.cve.org/CVERecord?id=CVE-2024-56694</link><description>In the Linux kernel, the following vulnerability has been resolved:

bpf: fix recursive lock when verdict program return SK_PASS

When the stream_verdict program returns SK_PASS, it places the received skb
into its own receive queue, but a recursive lock eventually occurs, leading
to an operating system deadlock. This issue has been present since v6.9.

'''
sk_psock_strp_data_ready
    write_lock_bh(&amp;amp;sk-&gt;sk_callback_lock)
    strp_data_ready
      strp_read_sock
        read_sock -&gt; tcp_read_sock
          strp_recv
            cb.rcv_msg -&gt; sk_psock_strp_read
              # now stream_verdict return SK_PASS without peer sock assign
              __SK_PASS = sk_psock_map_verd(SK_PASS, NULL)
              sk_psock_verdict_apply
                sk_psock_skb_ingress_self
                  sk_psock_skb_ingress_enqueue
                    sk_psock_data_ready
                      read_lock_bh(&amp;amp;sk-&gt;sk_callback_lock) &lt;= dead lock

'''

This topic has been discussed before, but it has not been fixed.
Previous discussion:
https://lore.kernel.org/all/6684a5864ec86_403d20898@john.notmuch</description><pubDate>Sat, 28 Dec 2024 09:54:52 +0000</pubDate></item><item><title>CVE-2024-56695 | drm/amdkfd: Use dynamic allocation for CU occupancy array in &amp;#x27;kfd_get_cu_occupancy()&amp;#x27;</title><link>https://www.cve.org/CVERecord?id=CVE-2024-56695</link><description>In the Linux kernel, the following vulnerability has been resolved:

drm/amdkfd: Use dynamic allocation for CU occupancy array in 'kfd_get_cu_occupancy()'

The `kfd_get_cu_occupancy` function previously declared a large
`cu_occupancy` array as a local variable, which could lead to stack
overflows due to excessive stack usage. This commit replaces the static
array allocation with dynamic memory allocation using `kcalloc`,
thereby reducing the stack size.

This change avoids the risk of stack overflows in kernel space,  in
scenarios where `AMDGPU_MAX_QUEUES` is large. The  allocated memory is
freed using `kfree` before the function returns  to prevent memory
leaks.

Fixes the below with gcc W=1:
drivers/gpu/drm/amd/amdgpu/../amdkfd/kfd_process.c: In function ‘kfd_get_cu_occupancy’:
drivers/gpu/drm/amd/amdgpu/../amdkfd/kfd_process.c:322:1: warning: the frame size of 1056 bytes is larger than 1024 bytes [-Wframe-larger-than=]
  322 | }
      | ^</description><pubDate>Sat, 28 Dec 2024 09:54:52 +0000</pubDate></item><item><title>CVE-2024-56696 | ALSA: core: Fix possible NULL dereference caused by kunit_kzalloc()</title><link>https://www.cve.org/CVERecord?id=CVE-2024-56696</link><description>In the Linux kernel, the following vulnerability has been resolved:

ALSA: core: Fix possible NULL dereference caused by kunit_kzalloc()

kunit_kzalloc() may return a NULL pointer, dereferencing it without
NULL check may lead to NULL dereference.
Add NULL checks for all the kunit_kzalloc() in sound_kunit.c</description><pubDate>Sat, 28 Dec 2024 09:54:53 +0000</pubDate></item><item><title>CVE-2024-56697 | drm/amdgpu: Fix the memory allocation issue in amdgpu_discovery_get_nps_info()</title><link>https://www.cve.org/CVERecord?id=CVE-2024-56697</link><description>In the Linux kernel, the following vulnerability has been resolved:

drm/amdgpu: Fix the memory allocation issue in amdgpu_discovery_get_nps_info()

Fix two issues with memory allocation in amdgpu_discovery_get_nps_info()
for mem_ranges:

 - Add a check for allocation failure to avoid dereferencing a null
   pointer.

 - As suggested by Christophe, use kvcalloc() for memory allocation,
   which checks for multiplication overflow.

Additionally, assign the output parameters nps_type and range_cnt after
the kvcalloc() call to prevent modifying the output parameters in case
of an error return.</description><pubDate>Sat, 28 Dec 2024 09:54:53 +0000</pubDate></item><item><title>CVE-2024-56698 | usb: dwc3: gadget: Fix looping of queued SG entries</title><link>https://www.cve.org/CVERecord?id=CVE-2024-56698</link><description>In the Linux kernel, the following vulnerability has been resolved:

usb: dwc3: gadget: Fix looping of queued SG entries

The dwc3_request-&gt;num_queued_sgs is decremented on completion. If a
partially completed request is handled, then the
dwc3_request-&gt;num_queued_sgs no longer reflects the total number of
num_queued_sgs (it would be cleared).

Correctly check the number of request SG entries remained to be prepare
and queued. Failure to do this may cause null pointer dereference when
accessing non-existent SG entry.</description><pubDate>Sat, 28 Dec 2024 09:54:53 +0000</pubDate></item><item><title>CVE-2024-56699 | s390/pci: Fix potential double remove of hotplug slot</title><link>https://www.cve.org/CVERecord?id=CVE-2024-56699</link><description>In the Linux kernel, the following vulnerability has been resolved:

s390/pci: Fix potential double remove of hotplug slot

In commit 6ee600bfbe0f ("s390/pci: remove hotplug slot when releasing the
device") the zpci_exit_slot() was moved from zpci_device_reserved() to
zpci_release_device() with the intention of keeping the hotplug slot
around until the device is actually removed.

Now zpci_release_device() is only called once all references are
dropped. Since the zPCI subsystem only drops its reference once the
device is in the reserved state it follows that zpci_release_device()
must only deal with devices in the reserved state. Despite that it
contains code to tear down from both configured and standby state. For
the standby case this already includes the removal of the hotplug slot
so would cause a double removal if a device was ever removed in
either configured or standby state.

Instead of causing a potential double removal in a case that should
never happen explicitly WARN_ON() if a device in non-reserved state is
released and get rid of the dead code cases.</description><pubDate>Sat, 28 Dec 2024 09:54:54 +0000</pubDate></item><item><title>CVE-2024-56700 | media: wl128x: Fix atomicity violation in fmc_send_cmd()</title><link>https://www.cve.org/CVERecord?id=CVE-2024-56700</link><description>In the Linux kernel, the following vulnerability has been resolved:

media: wl128x: Fix atomicity violation in fmc_send_cmd()

Atomicity violation occurs when the fmc_send_cmd() function is executed
simultaneously with the modification of the fmdev-&gt;resp_skb value.
Consider a scenario where, after passing the validity check within the
function, a non-null fmdev-&gt;resp_skb variable is assigned a null value.
This results in an invalid fmdev-&gt;resp_skb variable passing the validity
check. As seen in the later part of the function, skb = fmdev-&gt;resp_skb;
when the invalid fmdev-&gt;resp_skb passes the check, a null pointer
dereference error may occur at line 478, evt_hdr = (void *)skb-&gt;data;

To address this issue, it is recommended to include the validity check of
fmdev-&gt;resp_skb within the locked section of the function. This
modification ensures that the value of fmdev-&gt;resp_skb does not change
during the validation process, thereby maintaining its validity.

This possible bug is found by an experimental static analysis tool
developed by our team. This tool analyzes the locking APIs
to extract function pairs that can be concurrently executed, and then
analyzes the instructions in the paired functions to identify possible
concurrency bugs including data races and atomicity violations.</description><pubDate>Sat, 28 Dec 2024 09:54:54 +0000</pubDate></item><item><title>CVE-2024-56701 | powerpc/pseries: Fix dtl_access_lock to be a rw_semaphore</title><link>https://www.cve.org/CVERecord?id=CVE-2024-56701</link><description>In the Linux kernel, the following vulnerability has been resolved:

powerpc/pseries: Fix dtl_access_lock to be a rw_semaphore

The dtl_access_lock needs to be a rw_sempahore, a sleeping lock, because
the code calls kmalloc() while holding it, which can sleep:

  # echo 1 &gt; /proc/powerpc/vcpudispatch_stats
  BUG: sleeping function called from invalid context at include/linux/sched/mm.h:337
  in_atomic(): 1, irqs_disabled(): 0, non_block: 0, pid: 199, name: sh
  preempt_count: 1, expected: 0
  3 locks held by sh/199:
   #0: c00000000a0743f8 (sb_writers#3){.+.+}-{0:0}, at: vfs_write+0x324/0x438
   #1: c0000000028c7058 (dtl_enable_mutex){+.+.}-{3:3}, at: vcpudispatch_stats_write+0xd4/0x5f4
   #2: c0000000028c70b8 (dtl_access_lock){+.+.}-{2:2}, at: vcpudispatch_stats_write+0x220/0x5f4
  CPU: 0 PID: 199 Comm: sh Not tainted 6.10.0-rc4 #152
  Hardware name: IBM pSeries (emulated by qemu) POWER9 (raw) 0x4e1202 0xf000005 of:SLOF,HEAD hv:linux,kvm pSeries
  Call Trace:
    dump_stack_lvl+0x130/0x148 (unreliable)
    __might_resched+0x174/0x410
    kmem_cache_alloc_noprof+0x340/0x3d0
    alloc_dtl_buffers+0x124/0x1ac
    vcpudispatch_stats_write+0x2a8/0x5f4
    proc_reg_write+0xf4/0x150
    vfs_write+0xfc/0x438
    ksys_write+0x88/0x148
    system_call_exception+0x1c4/0x5a0
    system_call_common+0xf4/0x258</description><pubDate>Sat, 28 Dec 2024 09:54:55 +0000</pubDate></item><item><title>CVE-2024-56702 | bpf: Mark raw_tp arguments with PTR_MAYBE_NULL</title><link>https://www.cve.org/CVERecord?id=CVE-2024-56702</link><description>In the Linux kernel, the following vulnerability has been resolved:

bpf: Mark raw_tp arguments with PTR_MAYBE_NULL

Arguments to a raw tracepoint are tagged as trusted, which carries the
semantics that the pointer will be non-NULL.  However, in certain cases,
a raw tracepoint argument may end up being NULL. More context about this
issue is available in [0].

Thus, there is a discrepancy between the reality, that raw_tp arguments
can actually be NULL, and the verifier's knowledge, that they are never
NULL, causing explicit NULL checks to be deleted, and accesses to such
pointers potentially crashing the kernel.

To fix this, mark raw_tp arguments as PTR_MAYBE_NULL, and then special
case the dereference and pointer arithmetic to permit it, and allow
passing them into helpers/kfuncs; these exceptions are made for raw_tp
programs only. Ensure that we don't do this when ref_obj_id &gt; 0, as in
that case this is an acquired object and doesn't need such adjustment.

The reason we do mask_raw_tp_trusted_reg logic is because other will
recheck in places whether the register is a trusted_reg, and then
consider our register as untrusted when detecting the presence of the
PTR_MAYBE_NULL flag.

To allow safe dereference, we enable PROBE_MEM marking when we see loads
into trusted pointers with PTR_MAYBE_NULL.

While trusted raw_tp arguments can also be passed into helpers or kfuncs
where such broken assumption may cause issues, a future patch set will
tackle their case separately, as PTR_TO_BTF_ID (without PTR_TRUSTED) can
already be passed into helpers and causes similar problems. Thus, they
are left alone for now.

It is possible that these checks also permit passing non-raw_tp args
that are trusted PTR_TO_BTF_ID with null marking. In such a case,
allowing dereference when pointer is NULL expands allowed behavior, so
won't regress existing programs, and the case of passing these into
helpers is the same as above and will be dealt with later.

Also update the failure case in tp_btf_nullable selftest to capture the
new behavior, as the verifier will no longer cause an error when
directly dereference a raw tracepoint argument marked as __nullable.

  [0]: https://lore.kernel.org/bpf/ZrCZS6nisraEqehw@jlelli-thinkpadt14gen4.remote.csb</description><pubDate>Sat, 28 Dec 2024 09:54:55 +0000</pubDate></item><item><title>CVE-2024-56703 | ipv6: Fix soft lockups in fib6_select_path under high next hop churn</title><link>https://www.cve.org/CVERecord?id=CVE-2024-56703</link><description>In the Linux kernel, the following vulnerability has been resolved:

ipv6: Fix soft lockups in fib6_select_path under high next hop churn

Soft lockups have been observed on a cluster of Linux-based edge routers
located in a highly dynamic environment. Using the `bird` service, these
routers continuously update BGP-advertised routes due to frequently
changing nexthop destinations, while also managing significant IPv6
traffic. The lockups occur during the traversal of the multipath
circular linked-list in the `fib6_select_path` function, particularly
while iterating through the siblings in the list. The issue typically
arises when the nodes of the linked list are unexpectedly deleted
concurrently on a different core—indicated by their 'next' and
'previous' elements pointing back to the node itself and their reference
count dropping to zero. This results in an infinite loop, leading to a
soft lockup that triggers a system panic via the watchdog timer.

Apply RCU primitives in the problematic code sections to resolve the
issue. Where necessary, update the references to fib6_siblings to
annotate or use the RCU APIs.

Include a test script that reproduces the issue. The script
periodically updates the routing table while generating a heavy load
of outgoing IPv6 traffic through multiple iperf3 clients. It
consistently induces infinite soft lockups within a couple of minutes.

Kernel log:

 0 [ffffbd13003e8d30] machine_kexec at ffffffff8ceaf3eb
 1 [ffffbd13003e8d90] __crash_kexec at ffffffff8d0120e3
 2 [ffffbd13003e8e58] panic at ffffffff8cef65d4
 3 [ffffbd13003e8ed8] watchdog_timer_fn at ffffffff8d05cb03
 4 [ffffbd13003e8f08] __hrtimer_run_queues at ffffffff8cfec62f
 5 [ffffbd13003e8f70] hrtimer_interrupt at ffffffff8cfed756
 6 [ffffbd13003e8fd0] __sysvec_apic_timer_interrupt at ffffffff8cea01af
 7 [ffffbd13003e8ff0] sysvec_apic_timer_interrupt at ffffffff8df1b83d
--  --
 8 [ffffbd13003d3708] asm_sysvec_apic_timer_interrupt at ffffffff8e000ecb
    [exception RIP: fib6_select_path+299]
    RIP: ffffffff8ddafe7b  RSP: ffffbd13003d37b8  RFLAGS: 00000287
    RAX: ffff975850b43600  RBX: ffff975850b40200  RCX: 0000000000000000
    RDX: 000000003fffffff  RSI: 0000000051d383e4  RDI: ffff975850b43618
    RBP: ffffbd13003d3800   R8: 0000000000000000   R9: ffff975850b40200
    R10: 0000000000000000  R11: 0000000000000000  R12: ffffbd13003d3830
    R13: ffff975850b436a8  R14: ffff975850b43600  R15: 0000000000000007
    ORIG_RAX: ffffffffffffffff  CS: 0010  SS: 0018
 9 [ffffbd13003d3808] ip6_pol_route at ffffffff8ddb030c
10 [ffffbd13003d3888] ip6_pol_route_input at ffffffff8ddb068c
11 [ffffbd13003d3898] fib6_rule_lookup at ffffffff8ddf02b5
12 [ffffbd13003d3928] ip6_route_input at ffffffff8ddb0f47
13 [ffffbd13003d3a18] ip6_rcv_finish_core.constprop.0 at ffffffff8dd950d0
14 [ffffbd13003d3a30] ip6_list_rcv_finish.constprop.0 at ffffffff8dd96274
15 [ffffbd13003d3a98] ip6_sublist_rcv at ffffffff8dd96474
16 [ffffbd13003d3af8] ipv6_list_rcv at ffffffff8dd96615
17 [ffffbd13003d3b60] __netif_receive_skb_list_core at ffffffff8dc16fec
18 [ffffbd13003d3be0] netif_receive_skb_list_internal at ffffffff8dc176b3
19 [ffffbd13003d3c50] napi_gro_receive at ffffffff8dc565b9
20 [ffffbd13003d3c80] ice_receive_skb at ffffffffc087e4f5 [ice]
21 [ffffbd13003d3c90] ice_clean_rx_irq at ffffffffc0881b80 [ice]
22 [ffffbd13003d3d20] ice_napi_poll at ffffffffc088232f [ice]
23 [ffffbd13003d3d80] __napi_poll at ffffffff8dc18000
24 [ffffbd13003d3db8] net_rx_action at ffffffff8dc18581
25 [ffffbd13003d3e40] __do_softirq at ffffffff8df352e9
26 [ffffbd13003d3eb0] run_ksoftirqd at ffffffff8ceffe47
27 [ffffbd13003d3ec0] smpboot_thread_fn at ffffffff8cf36a30
28 [ffffbd13003d3ee8] kthread at ffffffff8cf2b39f
29 [ffffbd13003d3f28] ret_from_fork at ffffffff8ce5fa64
30 [ffffbd13003d3f50] ret_from_fork_asm at ffffffff8ce03cbb</description><pubDate>Sat, 28 Dec 2024 09:54:56 +0000</pubDate></item><item><title>CVE-2024-56704 | 9p/xen: fix release of IRQ</title><link>https://www.cve.org/CVERecord?id=CVE-2024-56704</link><description>In the Linux kernel, the following vulnerability has been resolved:

9p/xen: fix release of IRQ

Kernel logs indicate an IRQ was double-freed.

Pass correct device ID during IRQ release.

[Dominique: remove confusing variable reset to 0]</description><pubDate>Sat, 28 Dec 2024 09:54:56 +0000</pubDate></item><item><title>CVE-2024-56705 | media: atomisp: Add check for rgby_data memory allocation failure</title><link>https://www.cve.org/CVERecord?id=CVE-2024-56705</link><description>In the Linux kernel, the following vulnerability has been resolved:

media: atomisp: Add check for rgby_data memory allocation failure

In ia_css_3a_statistics_allocate(), there is no check on the allocation
result of the rgby_data memory. If rgby_data is not successfully
allocated, it may trigger the assert(host_stats-&gt;rgby_data) assertion in
ia_css_s3a_hmem_decode(). Adding a check to fix this potential issue.</description><pubDate>Sat, 28 Dec 2024 09:54:56 +0000</pubDate></item><item><title>CVE-2024-56706 | s390/cpum_sf: Fix and protect memory allocation of SDBs with mutex</title><link>https://www.cve.org/CVERecord?id=CVE-2024-56706</link><description>In the Linux kernel, the following vulnerability has been resolved:

s390/cpum_sf: Fix and protect memory allocation of SDBs with mutex

Reservation of the PMU hardware is done at first event creation
and is protected by a pair of mutex_lock() and mutex_unlock().
After reservation of the PMU hardware the memory
required for the PMUs the event is to be installed on is
allocated by allocate_buffers() and alloc_sampling_buffer().
This done outside of the mutex protection.
Without mutex protection two or more concurrent invocations of
perf_event_init() may run in parallel.
This can lead to allocation of Sample Data Blocks (SDBs)
multiple times for the same PMU.
Prevent this and protect memory allocation of SDBs by
mutex.</description><pubDate>Sat, 28 Dec 2024 09:54:57 +0000</pubDate></item><item><title>CVE-2024-56707 | octeontx2-pf: handle otx2_mbox_get_rsp errors in otx2_dmac_flt.c</title><link>https://www.cve.org/CVERecord?id=CVE-2024-56707</link><description>In the Linux kernel, the following vulnerability has been resolved:

octeontx2-pf: handle otx2_mbox_get_rsp errors in otx2_dmac_flt.c

Add error pointer checks after calling otx2_mbox_get_rsp().</description><pubDate>Sat, 28 Dec 2024 09:54:57 +0000</pubDate></item><item><title>CVE-2024-56708 | EDAC/igen6: Avoid segmentation fault on module unload</title><link>https://www.cve.org/CVERecord?id=CVE-2024-56708</link><description>In the Linux kernel, the following vulnerability has been resolved:

EDAC/igen6: Avoid segmentation fault on module unload

The segmentation fault happens because:

During modprobe:
1. In igen6_probe(), igen6_pvt will be allocated with kzalloc()
2. In igen6_register_mci(), mci-&gt;pvt_info will point to
   &amp;amp;igen6_pvt-&gt;imc[mc]

During rmmod:
1. In mci_release() in edac_mc.c, it will kfree(mci-&gt;pvt_info)
2. In igen6_remove(), it will kfree(igen6_pvt);

Fix this issue by setting mci-&gt;pvt_info to NULL to avoid the double
kfree.</description><pubDate>Sat, 28 Dec 2024 09:54:58 +0000</pubDate></item><item><title>CVE-2023-52718 | A connection hijacking vulnerability exists in some Huawei home routers. Successful exploitation of this vulnerability may cause DoS or info...</title><link>https://www.cve.org/CVERecord?id=CVE-2023-52718</link><description>A connection hijacking vulnerability exists in some Huawei home routers. Successful exploitation of this vulnerability may cause DoS or information leakage.(Vulnerability ID:HWPSIRT-2023-34408)

This vulnerability has been assigned a (CVE)ID:CVE-2023-52718</description><pubDate>Sat, 28 Dec 2024 07:27:17 +0000</pubDate></item><item><title>CVE-2023-7263 | Some Huawei home music system products have a path traversal vulnerability. Successful exploitation of this vulnerability may cause unauthor...</title><link>https://www.cve.org/CVERecord?id=CVE-2023-7263</link><description>Some Huawei home music system products have a path traversal vulnerability. Successful exploitation of this vulnerability may cause unauthorized file deletion or file permission change.(Vulnerability ID:HWPSIRT-2023-53450)

This vulnerability has been assigned a (CVE)ID:CVE-2023-7263</description><pubDate>Sat, 28 Dec 2024 07:18:50 +0000</pubDate></item><item><title>CVE-2023-7266 | Some Huawei home routers have a connection hijacking vulnerability. Successful exploitation of this vulnerability may cause DoS or informati...</title><link>https://www.cve.org/CVERecord?id=CVE-2023-7266</link><description>Some Huawei home routers have a connection hijacking vulnerability. Successful exploitation of this vulnerability may cause DoS or information leakage.(Vulnerability ID:HWPSIRT-2023-76605)
This vulnerability has been assigned a (CVE)ID:CVE-2023-7266</description><pubDate>Sat, 28 Dec 2024 07:18:51 +0000</pubDate></item><item><title>CVE-2022-48470 | Huawei HiLink AI Life product has an identity authentication bypass vulnerability. Successful exploitation of this vulnerability may allow a...</title><link>https://www.cve.org/CVERecord?id=CVE-2022-48470</link><description>Huawei HiLink AI Life product has an identity authentication bypass vulnerability. Successful exploitation of this vulnerability may allow attackers to access restricted functions.(Vulnerability ID:HWPSIRT-2022-42291)

This vulnerability has been assigned a (CVE)ID:CVE-2022-48470</description><pubDate>Sat, 28 Dec 2024 07:01:36 +0000</pubDate></item><item><title>CVE-2021-22484 | Some Huawei wearables have a vulnerability of not verifying the actual data size when reading data.




Successful exploitation of this vuln...</title><link>https://www.cve.org/CVERecord?id=CVE-2021-22484</link><description>Some Huawei wearables have a vulnerability of not verifying the actual data size when reading data.




Successful exploitation of this vulnerability may cause a server out of memory (OOM).</description><pubDate>Sat, 28 Dec 2024 06:54:27 +0000</pubDate></item><item><title>CVE-2021-37000 | Some Huawei wearables have a permission management vulnerability.</title><link>https://www.cve.org/CVERecord?id=CVE-2021-37000</link><description>Some Huawei wearables have a permission management vulnerability.</description><pubDate>Sat, 28 Dec 2024 06:54:27 +0000</pubDate></item><item><title>CVE-2020-1823 | There are multiple out of bounds (OOB) read vulnerabilities in the implementation of the Common Open Policy Service (COPS) protocol of some ...</title><link>https://www.cve.org/CVERecord?id=CVE-2020-1823</link><description>There are multiple out of bounds (OOB) read vulnerabilities in the implementation of the Common Open Policy Service (COPS) protocol of some Huawei products. The specific decoding function may occur out-of-bounds read when processes an incoming data packet. Successful exploit of these vulnerabilities may disrupt service on the affected device. (Vulnerability ID: HWPSIRT-2018-12275,HWPSIRT-2018-12276,HWPSIRT-2018-12277,HWPSIRT-2018-12278,HWPSIRT-2018-12279,HWPSIRT-2018-12280 and HWPSIRT-2018-12289)

The seven vulnerabilities have been assigned seven Common Vulnerabilities and Exposures (CVE) IDs: CVE-2020-1818, CVE-2020-1819, CVE-2020-1820, CVE-2020-1821, CVE-2020-1822, CVE-2020-1823 and CVE-2020-1824.</description><pubDate>Sat, 28 Dec 2024 06:39:23 +0000</pubDate></item><item><title>CVE-2020-1824 | There are multiple out of bounds (OOB) read vulnerabilities in the implementation of the Common Open Policy Service (COPS) protocol of some ...</title><link>https://www.cve.org/CVERecord?id=CVE-2020-1824</link><description>There are multiple out of bounds (OOB) read vulnerabilities in the implementation of the Common Open Policy Service (COPS) protocol of some Huawei products. The specific decoding function may occur out-of-bounds read when processes an incoming data packet. Successful exploit of these vulnerabilities may disrupt service on the affected device. (Vulnerability ID: HWPSIRT-2018-12275,HWPSIRT-2018-12276,HWPSIRT-2018-12277,HWPSIRT-2018-12278,HWPSIRT-2018-12279,HWPSIRT-2018-12280 and HWPSIRT-2018-12289)

The seven vulnerabilities have been assigned seven Common Vulnerabilities and Exposures (CVE) IDs: CVE-2020-1818, CVE-2020-1819, CVE-2020-1820, CVE-2020-1821, CVE-2020-1822, CVE-2020-1823 and CVE-2020-1824.</description><pubDate>Sat, 28 Dec 2024 06:39:23 +0000</pubDate></item><item><title>CVE-2020-1821 | There are multiple out of bounds (OOB) read vulnerabilities in the implementation of the Common Open Policy Service (COPS) protocol of some ...</title><link>https://www.cve.org/CVERecord?id=CVE-2020-1821</link><description>There are multiple out of bounds (OOB) read vulnerabilities in the implementation of the Common Open Policy Service (COPS) protocol of some Huawei products. The specific decoding function may occur out-of-bounds read when processes an incoming data packet. Successful exploit of these vulnerabilities may disrupt service on the affected device. (Vulnerability ID: HWPSIRT-2018-12275,HWPSIRT-2018-12276,HWPSIRT-2018-12277,HWPSIRT-2018-12278,HWPSIRT-2018-12279,HWPSIRT-2018-12280 and HWPSIRT-2018-12289)

The seven vulnerabilities have been assigned seven Common Vulnerabilities and Exposures (CVE) IDs: CVE-2020-1818, CVE-2020-1819, CVE-2020-1820, CVE-2020-1821, CVE-2020-1822, CVE-2020-1823 and CVE-2020-1824.</description><pubDate>Sat, 28 Dec 2024 06:39:24 +0000</pubDate></item><item><title>CVE-2020-1822 | There are multiple out of bounds (OOB) read vulnerabilities in the implementation of the Common Open Policy Service (COPS) protocol of some ...</title><link>https://www.cve.org/CVERecord?id=CVE-2020-1822</link><description>There are multiple out of bounds (OOB) read vulnerabilities in the implementation of the Common Open Policy Service (COPS) protocol of some Huawei products. The specific decoding function may occur out-of-bounds read when processes an incoming data packet. Successful exploit of these vulnerabilities may disrupt service on the affected device. (Vulnerability ID: HWPSIRT-2018-12275,HWPSIRT-2018-12276,HWPSIRT-2018-12277,HWPSIRT-2018-12278,HWPSIRT-2018-12279,HWPSIRT-2018-12280 and HWPSIRT-2018-12289)

The seven vulnerabilities have been assigned seven Common Vulnerabilities and Exposures (CVE) IDs: CVE-2020-1818, CVE-2020-1819, CVE-2020-1820, CVE-2020-1821, CVE-2020-1822, CVE-2020-1823 and CVE-2020-1824.</description><pubDate>Sat, 28 Dec 2024 06:39:24 +0000</pubDate></item><item><title>CVE-2020-1820 | There are multiple out of bounds (OOB) read vulnerabilities in the implementation of the Common Open Policy Service (COPS) protocol of some ...</title><link>https://www.cve.org/CVERecord?id=CVE-2020-1820</link><description>There are multiple out of bounds (OOB) read vulnerabilities in the implementation of the Common Open Policy Service (COPS) protocol of some Huawei products. The specific decoding function may occur out-of-bounds read when processes an incoming data packet. Successful exploit of these vulnerabilities may disrupt service on the affected device. (Vulnerability ID: HWPSIRT-2018-12275,HWPSIRT-2018-12276,HWPSIRT-2018-12277,HWPSIRT-2018-12278,HWPSIRT-2018-12279,HWPSIRT-2018-12280 and HWPSIRT-2018-12289)

The seven vulnerabilities have been assigned seven Common Vulnerabilities and Exposures (CVE) IDs: CVE-2020-1818, CVE-2020-1819, CVE-2020-1820, CVE-2020-1821, CVE-2020-1822, CVE-2020-1823 and CVE-2020-1824.</description><pubDate>Sat, 28 Dec 2024 06:21:19 +0000</pubDate></item><item><title>CVE-2024-43705 | GPU DDK - Security: Exploitable PVRSRVBridgePhysmemWrapExtMem may lead to overwrite read-only file/memory (e.g. libc.so)</title><link>https://www.cve.org/CVERecord?id=CVE-2024-43705</link><description>Software installed and run as a non-privileged user can trigger the GPU kernel driver to write to arbitrary read-only system files that have been mapped into application memory.</description><pubDate>Sat, 28 Dec 2024 05:10:06 +0000</pubDate></item><item><title>CVE-2024-46972 | GPU DDK - Security: Reference count overflow in pvr_sync_rollback_export_fence</title><link>https://www.cve.org/CVERecord?id=CVE-2024-46972</link><description>Software installed and run as a non-privileged user may conduct improper GPU system calls to trigger use-after-free kernel exceptions.</description><pubDate>Sat, 28 Dec 2024 05:10:07 +0000</pubDate></item><item><title>CVE-2024-46973 | Exploitable kernel use-after-free on psServerMMUContext due to reference count mismanagement</title><link>https://www.cve.org/CVERecord?id=CVE-2024-46973</link><description>Software installed and run as a non-privileged user may conduct improper GPU system calls to trigger use-after-free kernel exceptions.</description><pubDate>Sat, 28 Dec 2024 05:10:07 +0000</pubDate></item></channel></rss>