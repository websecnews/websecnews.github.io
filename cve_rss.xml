<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>New CVE from cve.org feed</title><link>https://github.com/test.xml</link><description>Last 2 days CVE feed!</description><atom:link href="https://github.com/test.xml" rel="self"/><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><language>en</language><lastBuildDate>Mon, 13 Jan 2025 16:59:55 +0000</lastBuildDate><item><title>CVE-2024-46919 | An issue was discovered in Samsung Mobile Processor Exynos 9820, 9825, 980, 990, 850, 1080, 2100, and 1280. Lack of a length check leads to ...</title><link>https://www.cve.org/CVERecord?id=CVE-2024-46919</link><description>An issue was discovered in Samsung Mobile Processor Exynos 9820, 9825, 980, 990, 850, 1080, 2100, and 1280. Lack of a length check leads to a stack out-of-bounds write at loadOutputBuffers.</description><pubDate>Mon, 13 Jan 2025 16:59:57 +0000</pubDate></item><item><title>CVE-2024-57487 | In Code-Projects Online Car Rental System 1.0, the file upload feature does not validate file extensions or MIME types allowing an attacker ...</title><link>https://www.cve.org/CVERecord?id=CVE-2024-57487</link><description>In Code-Projects Online Car Rental System 1.0, the file upload feature does not validate file extensions or MIME types allowing an attacker to upload a PHP shell without any restrictions and execute commands on the server.</description><pubDate>Mon, 13 Jan 2025 16:59:57 +0000</pubDate></item><item><title>CVE-2024-57488 | Code-Projects Online Car Rental System 1.0 is vulnerable to Cross Site Scripting (XSS) via the vehicalorcview parameter in /admin/edit-vehic...</title><link>https://www.cve.org/CVERecord?id=CVE-2024-57488</link><description>Code-Projects Online Car Rental System 1.0 is vulnerable to Cross Site Scripting (XSS) via the vehicalorcview parameter in /admin/edit-vehicle.php.</description><pubDate>Mon, 13 Jan 2025 16:59:58 +0000</pubDate></item><item><title>CVE-2024-6352 | Malformed packet leads to denial of service in APS layer</title><link>https://www.cve.org/CVERecord?id=CVE-2024-6352</link><description>A malformed packet can cause a buffer overflow in the APS layer of the Ember ZNet stack and lead to an assert</description><pubDate>Mon, 13 Jan 2025 16:52:13 +0000</pubDate></item><item><title>CVE-2024-12211 | Pega Platform versions 8.1 to Infinity 24.2.0 are affected by an Stored XSS issue with profile.</title><link>https://www.cve.org/CVERecord?id=CVE-2024-12211</link><description>Pega Platform versions 8.1 to Infinity 24.2.0 are affected by an Stored XSS issue with profile.</description><pubDate>Mon, 13 Jan 2025 16:40:31 +0000</pubDate></item><item><title>CVE-2024-54999 | MonicaHQ v4.1.2 was discovered to contain a Client-Side Injection vulnerability via the last_name parameter the General Information module.</title><link>https://www.cve.org/CVERecord?id=CVE-2024-54999</link><description>MonicaHQ v4.1.2 was discovered to contain a Client-Side Injection vulnerability via the last_name parameter the General Information module.</description><pubDate>Mon, 13 Jan 2025 16:40:32 +0000</pubDate></item><item><title>CVE-2025-22963 | Teedy through 1.11 allows CSRF for account takeover via POST /api/user/admin.</title><link>https://www.cve.org/CVERecord?id=CVE-2025-22963</link><description>Teedy through 1.11 allows CSRF for account takeover via POST /api/user/admin.</description><pubDate>Mon, 13 Jan 2025 15:50:21 +0000</pubDate></item><item><title>CVE-2024-47796 | An improper array index validation vulnerability exists in the nowindow functionality of OFFIS DCMTK 3.6.8. A specially crafted DICOM file c...</title><link>https://www.cve.org/CVERecord?id=CVE-2024-47796</link><description>An improper array index validation vulnerability exists in the nowindow functionality of OFFIS DCMTK 3.6.8. A specially crafted DICOM file can lead to an out-of-bounds write. An attacker can provide a malicious file to trigger this vulnerability.</description><pubDate>Mon, 13 Jan 2025 14:32:31 +0000</pubDate></item><item><title>CVE-2024-52333 | An improper array index validation vulnerability exists in the determineMinMax functionality of OFFIS DCMTK 3.6.8. A specially crafted DICOM...</title><link>https://www.cve.org/CVERecord?id=CVE-2024-52333</link><description>An improper array index validation vulnerability exists in the determineMinMax functionality of OFFIS DCMTK 3.6.8. A specially crafted DICOM file can lead to an out-of-bounds write. An attacker can provide a malicious file to trigger this vulnerability.</description><pubDate>Mon, 13 Jan 2025 14:32:31 +0000</pubDate></item><item><title>CVE-2024-56065 | WordPress WP2LEADS Plugin &amp;lt;= 3.4.2 - Reflected Cross Site Scripting (XSS) vulnerability</title><link>https://www.cve.org/CVERecord?id=CVE-2024-56065</link><description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting') vulnerability in Saleswonder.biz Team WP2LEADS allows Reflected XSS.This issue affects WP2LEADS: from n/a through 3.4.2.</description><pubDate>Mon, 13 Jan 2025 13:17:16 +0000</pubDate></item><item><title>CVE-2024-56301 | WordPress Distance Based Shipping Calculator Plugin &amp;lt;= 2.0.21 - Reflected Cross Site Scripting (XSS) vulnerability</title><link>https://www.cve.org/CVERecord?id=CVE-2024-56301</link><description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting') vulnerability in Eniture Technology Distance Based Shipping Calculator allows Reflected XSS.This issue affects Distance Based Shipping Calculator: from n/a through 2.0.21.</description><pubDate>Mon, 13 Jan 2025 13:17:16 +0000</pubDate></item><item><title>CVE-2025-22314 | WordPress Food Store plugin &amp;lt;= 1.5.1 - Reflected Cross Site Scripting (XSS) vulnerability</title><link>https://www.cve.org/CVERecord?id=CVE-2025-22314</link><description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting') vulnerability in WP Scripts Food Store – Online Food Delivery &amp; Pickup allows Reflected XSS.This issue affects Food Store – Online Food Delivery &amp; Pickup: from n/a through 1.5.1.</description><pubDate>Mon, 13 Jan 2025 13:17:17 +0000</pubDate></item><item><title>CVE-2025-22337 | WordPress Order Audit Log for WooCommerce plugin &amp;lt;= 2.0  - Reflected Cross Site Scripting (XSS) vulnerability</title><link>https://www.cve.org/CVERecord?id=CVE-2025-22337</link><description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting') vulnerability in Infosoft Consultant Order Audit Log for WooCommerce allows Reflected XSS.This issue affects Order Audit Log for WooCommerce: from n/a through 2.0.</description><pubDate>Mon, 13 Jan 2025 13:17:17 +0000</pubDate></item><item><title>CVE-2025-22344 | WordPress Media Category Library plugin &amp;lt;= 2.7 - Reflected Cross Site Scripting (XSS) vulnerability</title><link>https://www.cve.org/CVERecord?id=CVE-2025-22344</link><description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting') vulnerability in Convoy Media Category Library allows Reflected XSS.This issue affects Media Category Library: from n/a through 2.7.</description><pubDate>Mon, 13 Jan 2025 13:17:18 +0000</pubDate></item><item><title>CVE-2025-22498 | WordPress LucidLMS plugin &amp;lt;= 1.0.5 - Reflected Cross Site Scripting (XSS) vulnerability</title><link>https://www.cve.org/CVERecord?id=CVE-2025-22498</link><description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting') vulnerability in New Normal LLC LucidLMS allows Reflected XSS.This issue affects LucidLMS: from n/a through 1.0.5.</description><pubDate>Mon, 13 Jan 2025 13:17:18 +0000</pubDate></item><item><title>CVE-2025-22499 | WordPress F4 Post Tree Plugin &amp;lt;= 1.1.18 - Reflected Cross Site Scripting (XSS) vulnerability</title><link>https://www.cve.org/CVERecord?id=CVE-2025-22499</link><description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting') vulnerability in FAKTOR VIER F4 Post Tree allows Reflected XSS.This issue affects F4 Post Tree: from n/a through 1.1.18.</description><pubDate>Mon, 13 Jan 2025 13:17:18 +0000</pubDate></item><item><title>CVE-2025-22506 | WordPress Smart Agenda Plugin &amp;lt;= 4.7 - CSRF to Stored XSS vulnerability</title><link>https://www.cve.org/CVERecord?id=CVE-2025-22506</link><description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting') vulnerability in SmartAgenda Smart Agenda allows Stored XSS.This issue affects Smart Agenda: from n/a through 4.7.</description><pubDate>Mon, 13 Jan 2025 13:17:19 +0000</pubDate></item><item><title>CVE-2025-22514 | WordPress Axact Author List Widget Plugin &amp;lt;= 3.1.1 - Reflected Cross Site Scripting (XSS) vulnerability</title><link>https://www.cve.org/CVERecord?id=CVE-2025-22514</link><description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting') vulnerability in Yamna Tatheer KNR Author List Widget allows Reflected XSS.This issue affects KNR Author List Widget: from n/a through 3.1.1.</description><pubDate>Mon, 13 Jan 2025 13:17:19 +0000</pubDate></item><item><title>CVE-2025-22567 | WordPress TRUSTist REVIEWer Plugin &amp;lt;= 2.0 - Reflected Cross Site Scripting (XSS) vulnerability</title><link>https://www.cve.org/CVERecord?id=CVE-2025-22567</link><description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting') vulnerability in trustist TRUSTist REVIEWer allows Reflected XSS.This issue affects TRUSTist REVIEWer: from n/a through 2.0.</description><pubDate>Mon, 13 Jan 2025 13:17:20 +0000</pubDate></item><item><title>CVE-2025-22568 | WordPress Post And Page Reactions Plugin &amp;lt;= 1.0.5 - Reflected Cross Site Scripting (XSS) vulnerability</title><link>https://www.cve.org/CVERecord?id=CVE-2025-22568</link><description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting') vulnerability in Paramveer Singh for Arete IT Private Limited Post And Page Reactions allows Reflected XSS.This issue affects Post And Page Reactions: from n/a through 1.0.5.</description><pubDate>Mon, 13 Jan 2025 13:17:20 +0000</pubDate></item><item><title>CVE-2025-22569 | WordPress Featured Page Widget Plugin &amp;lt;= 2.2 - Reflected Cross Site Scripting (XSS) vulnerability</title><link>https://www.cve.org/CVERecord?id=CVE-2025-22569</link><description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting') vulnerability in grandslambert Featured Page Widget allows Reflected XSS.This issue affects Featured Page Widget: from n/a through 2.2.</description><pubDate>Mon, 13 Jan 2025 13:17:20 +0000</pubDate></item><item><title>CVE-2025-22570 | WordPress Inline Tweets plugin &amp;lt;= 2.0 - Cross Site Scripting (XSS) vulnerability</title><link>https://www.cve.org/CVERecord?id=CVE-2025-22570</link><description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting') vulnerability in Miloš Đekić Inline Tweets allows Stored XSS.This issue affects Inline Tweets: from n/a through 2.0.</description><pubDate>Mon, 13 Jan 2025 13:17:21 +0000</pubDate></item><item><title>CVE-2025-22576 | WordPress Site PIN Plugin &amp;lt;= 1.3 - Reflected Cross Site Scripting (XSS) vulnerability</title><link>https://www.cve.org/CVERecord?id=CVE-2025-22576</link><description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting') vulnerability in Marcus Downing Site PIN allows Reflected XSS.This issue affects Site PIN: from n/a through 1.3.</description><pubDate>Mon, 13 Jan 2025 13:17:21 +0000</pubDate></item><item><title>CVE-2025-22583 | WordPress Scan External Links Plugin &amp;lt;= 1.0 - Reflected Cross Site Scripting (XSS) vulnerability</title><link>https://www.cve.org/CVERecord?id=CVE-2025-22583</link><description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting') vulnerability in Anshul Sojatia Scan External Links allows Reflected XSS.This issue affects Scan External Links: from n/a through 1.0.</description><pubDate>Mon, 13 Jan 2025 13:17:22 +0000</pubDate></item><item><title>CVE-2025-22586 | WordPress WPEX Replace DB Urls Plugin &amp;lt;= 0.4.0 - Reflected Cross Site Scripting (XSS) vulnerability</title><link>https://www.cve.org/CVERecord?id=CVE-2025-22586</link><description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting') vulnerability in Detlef Stöver WPEX Replace DB Urls allows Reflected XSS.This issue affects WPEX Replace DB Urls: from n/a through 0.4.0.</description><pubDate>Mon, 13 Jan 2025 13:17:22 +0000</pubDate></item><item><title>CVE-2025-22588 | WordPress Scanventory Plugin &amp;lt;= 1.1.3 - Reflected Cross Site Scripting (XSS) vulnerability</title><link>https://www.cve.org/CVERecord?id=CVE-2025-22588</link><description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting') vulnerability in Scanventory.net Scanventory allows Reflected XSS.This issue affects Scanventory: from n/a through 1.1.3.</description><pubDate>Mon, 13 Jan 2025 13:17:23 +0000</pubDate></item><item><title>CVE-2025-22777 | WordPress GiveWP Plugin &amp;lt;= 3.19.3 - PHP Object Injection vulnerability</title><link>https://www.cve.org/CVERecord?id=CVE-2025-22777</link><description>Deserialization of Untrusted Data vulnerability in GiveWP GiveWP allows Object Injection.This issue affects GiveWP: from n/a through 3.19.3.</description><pubDate>Mon, 13 Jan 2025 13:17:23 +0000</pubDate></item><item><title>CVE-2025-22800 | WordPress Post SMTP plugin &amp;lt;= 2.9.11 - Broken Access Control vulnerability</title><link>https://www.cve.org/CVERecord?id=CVE-2025-22800</link><description>Missing Authorization vulnerability in Post SMTP Post SMTP allows Exploiting Incorrectly Configured Access Control Security Levels.This issue affects Post SMTP: from n/a through 2.9.11.</description><pubDate>Mon, 13 Jan 2025 13:17:23 +0000</pubDate></item><item><title>CVE-2025-22828 | Apache CloudStack: Unauthorised access to annotations</title><link>https://www.cve.org/CVERecord?id=CVE-2025-22828</link><description>CloudStack users can add and read comments (annotations) on resources they are authorised to access. 

Due to an access validation issue that affects Apache CloudStack versions from 4.16.0, users who have access, prior access or knowledge of resource UUIDs can list and add comments (annotations) to such resources. 

An attacker with a user-account and access or prior knowledge of resource UUIDs may exploit this issue to read contents of the comments (annotations) or add malicious comments (annotations) to such resources. 

This may cause potential loss of confidentiality of CloudStack environments and resources if the comments (annotations) contain any privileged information. However, guessing or brute-forcing resource UUIDs are generally hard to impossible and access to listing or adding comments isn't same as access to CloudStack resources, making this issue of very low severity and general low impact.


CloudStack admins may also disallow listAnnotations and addAnnotation API access to non-admin roles in their environment as an interim measure.</description><pubDate>Mon, 13 Jan 2025 12:55:27 +0000</pubDate></item><item><title>CVE-2024-52938 | GPU DDK - rgxfw_pm_add_freelist_for_reconstruction OOB write</title><link>https://www.cve.org/CVERecord?id=CVE-2024-52938</link><description>Kernel software installed and running inside a Guest VM may post improper commands to the GPU Firmware to subvert reconstruction activities to trigger a write of data outside the Guest's virtualised GPU memory.</description><pubDate>Mon, 13 Jan 2025 11:54:56 +0000</pubDate></item><item><title>CVE-2024-52936 | GPU DDK - rgxfw_hwperf_config OOB read &amp;amp; write</title><link>https://www.cve.org/CVERecord?id=CVE-2024-52936</link><description>Kernel software installed and running inside a Guest VM may post improper commands to the GPU Firmware to write data outside the Guest's virtualised GPU memory.</description><pubDate>Mon, 13 Jan 2025 10:45:59 +0000</pubDate></item><item><title>CVE-2024-52937 | GPU DDK - rgxfw_kernel_CMD_DISABLE_ZSSTORE OOB write via ui32WriteOffsetOfDisableZSStore</title><link>https://www.cve.org/CVERecord?id=CVE-2024-52937</link><description>Kernel software installed and running inside a Guest VM may exploit memory shared with the GPU Firmware to write data outside the Guest's virtualised GPU memory.</description><pubDate>Mon, 13 Jan 2025 10:45:59 +0000</pubDate></item><item><title>CVE-2024-47894 | GPU DDK - Out of bounds read into fwlog due to unchecked loop bounds</title><link>https://www.cve.org/CVERecord?id=CVE-2024-47894</link><description>Kernel software installed and running inside a Guest VM may post improper commands to the GPU Firmware to read data outside the Guest's virtualised GPU memory.</description><pubDate>Mon, 13 Jan 2025 10:46:00 +0000</pubDate></item><item><title>CVE-2024-47895 | GPU DDK - OOB read into fwlog due to unchecked block count</title><link>https://www.cve.org/CVERecord?id=CVE-2024-47895</link><description>Kernel software installed and running inside a Guest VM may post improper commands to the GPU Firmware to read data outside the Guest's virtualised GPU memory.</description><pubDate>Mon, 13 Jan 2025 10:46:00 +0000</pubDate></item><item><title>CVE-2024-47897 | GPU DDK - PVRSRVRGXGetEnabledHWPerfBlocksKM off-by-one OOB write</title><link>https://www.cve.org/CVERecord?id=CVE-2024-47897</link><description>Software installed and run as a non-privileged user may conduct improper GPU system calls resulting in platform instability and reboots.</description><pubDate>Mon, 13 Jan 2025 10:46:01 +0000</pubDate></item><item><title>CVE-2024-52935 | GPU DDK - psContext-&amp;gt;eDM gives OOB write</title><link>https://www.cve.org/CVERecord?id=CVE-2024-52935</link><description>Kernel software installed and running inside a Guest VM may exploit memory shared with the GPU Firmware to write data outside the Guest's virtualised GPU memory.</description><pubDate>Mon, 13 Jan 2025 10:46:01 +0000</pubDate></item><item><title>CVE-2024-11636 | Email Subscribers &amp;lt; 5.7.45 - Admin+ Stored XSS</title><link>https://www.cve.org/CVERecord?id=CVE-2024-11636</link><description>The Email Subscribers by Icegram Express  WordPress plugin before 5.7.45 does not sanitise and escape some of its Text Block options, which could allow high privilege users such as admin to perform Stored Cross-Site Scripting attacks even when the unfiltered_html capability is disallowed (for example in multisite setup).</description><pubDate>Mon, 13 Jan 2025 06:18:28 +0000</pubDate></item><item><title>CVE-2024-12274 | BookingPress &amp;lt; 1.1.23 - Unauthenticated Export File Download</title><link>https://www.cve.org/CVERecord?id=CVE-2024-12274</link><description>The Appointment Booking Calendar Plugin and Scheduling Plugin  WordPress plugin before 1.1.23 export settings functionality exports data to a public folder, with an easily guessable file name, allowing unauthenticated attackers to access the exported files (if they exist).</description><pubDate>Mon, 13 Jan 2025 06:18:28 +0000</pubDate></item><item><title>CVE-2024-12566 | Email Subscribers &amp;lt; 5.7.45 - Admin+ Stored XSS</title><link>https://www.cve.org/CVERecord?id=CVE-2024-12566</link><description>The Email Subscribers by Icegram Express  WordPress plugin before 5.7.45 does not sanitise and escape some of form settings, which could allow high privilege users such as admin to perform Stored Cross-Site Scripting attacks even when the unfiltered_html capability is disallowed (for example in multisite setup).</description><pubDate>Mon, 13 Jan 2025 06:18:29 +0000</pubDate></item><item><title>CVE-2024-12567 | Email Subscribers &amp;lt; 5.7.45 - Admin+ Stored XSS</title><link>https://www.cve.org/CVERecord?id=CVE-2024-12567</link><description>The Email Subscribers by Icegram Express  WordPress plugin before 5.7.45 does not sanitise and escape some of its form settings, which could allow high privilege users such as admin to perform Stored Cross-Site Scripting attacks even when the unfiltered_html capability is disallowed (for example in multisite setup).</description><pubDate>Mon, 13 Jan 2025 06:18:29 +0000</pubDate></item><item><title>CVE-2024-12568 | Email Subscribers &amp;lt; 5.7.45 - Admin+ Stored XSS</title><link>https://www.cve.org/CVERecord?id=CVE-2024-12568</link><description>The Email Subscribers by Icegram Express  WordPress plugin before 5.7.45 does not sanitise and escape some of its Workflow settings, which could allow high privilege users such as admin to perform Stored Cross-Site Scripting attacks even when the unfiltered_html capability is disallowed (for example in multisite setup).</description><pubDate>Mon, 13 Jan 2025 06:18:30 +0000</pubDate></item><item><title>CVE-2025-0412 | Luxion KeyShot Viewer KSP File Parsing Memory Corruption Remote Code Execution Vulnerability</title><link>https://www.cve.org/CVERecord?id=CVE-2025-0412</link><description>Luxion KeyShot Viewer KSP File Parsing Memory Corruption Remote Code Execution Vulnerability. This vulnerability allows remote attackers to execute arbitrary code on affected installations of Luxion KeyShot Viewer. User interaction is required to exploit this vulnerability in that the target must visit a malicious page or open a malicious file.

The specific flaw exists within the processing of KSP files. The issue results from the lack of proper validation of user-supplied data, which can result in a memory corruption condition. An attacker can leverage this vulnerability to execute code in the context of the current process. Was ZDI-CAN-22139.</description><pubDate>Mon, 13 Jan 2025 03:36:04 +0000</pubDate></item><item><title>CVE-2025-0409 | liujianview gymxmjpa MembertypeController.java MembertypeDaoImpl sql injection</title><link>https://www.cve.org/CVERecord?id=CVE-2025-0409</link><description>A vulnerability classified as critical has been found in liujianview gymxmjpa 1.0. This affects the function MembertypeDaoImpl of the file src/main/java/com/liujian/gymxmjpa/controller/MembertypeController.java. The manipulation of the argument typeName leads to sql injection. It is possible to initiate the attack remotely. The exploit has been disclosed to the public and may be used.</description><pubDate>Mon, 13 Jan 2025 03:08:50 +0000</pubDate></item><item><title>CVE-2025-0410 | liujianview gymxmjpa MenberConntroller.java MenberDaoInpl sql injection</title><link>https://www.cve.org/CVERecord?id=CVE-2025-0410</link><description>A vulnerability classified as critical was found in liujianview gymxmjpa 1.0. This vulnerability affects the function MenberDaoInpl of the file src/main/java/com/liujian/gymxmjpa/controller/MenberConntroller.java. The manipulation of the argument hyname leads to sql injection. The attack can be initiated remotely. The exploit has been disclosed to the public and may be used.</description><pubDate>Mon, 13 Jan 2025 03:08:51 +0000</pubDate></item><item><title>CVE-2025-0408 | liujianview gymxmjpa LoosController.java LoosDaoImpl sql injection</title><link>https://www.cve.org/CVERecord?id=CVE-2025-0408</link><description>A vulnerability was found in liujianview gymxmjpa 1.0. It has been rated as critical. Affected by this issue is the function LoosDaoImpl of the file src/main/java/com/liujian/gymxmjpa/controller/LoosController.java. The manipulation of the argument loosName leads to sql injection. The attack may be launched remotely. The exploit has been disclosed to the public and may be used.</description><pubDate>Mon, 13 Jan 2025 02:37:40 +0000</pubDate></item><item><title>CVE-2025-0406 | liujianview gymxmjpa SubjectController.java SubjectDaoImpl sql injection</title><link>https://www.cve.org/CVERecord?id=CVE-2025-0406</link><description>A vulnerability was found in liujianview gymxmjpa 1.0. It has been classified as critical. Affected is the function SubjectDaoImpl of the file src/main/java/com/liujian/gymxmjpa/controller/SubjectController.java. The manipulation of the argument subname leads to sql injection. It is possible to launch the attack remotely. The exploit has been disclosed to the public and may be used.</description><pubDate>Mon, 13 Jan 2025 02:37:40 +0000</pubDate></item><item><title>CVE-2025-0407 | liujianview gymxmjpa EquipmentController.java EquipmentDaoImpl sql injection</title><link>https://www.cve.org/CVERecord?id=CVE-2025-0407</link><description>A vulnerability was found in liujianview gymxmjpa 1.0. It has been declared as critical. Affected by this vulnerability is the function EquipmentDaoImpl of the file src/main/java/com/liujian/gymxmjpa/controller/EquipmentController.java. The manipulation of the argument hyname leads to sql injection. The attack can be launched remotely. The exploit has been disclosed to the public and may be used.</description><pubDate>Mon, 13 Jan 2025 02:37:41 +0000</pubDate></item><item><title>CVE-2025-0404 | liujianview gymxmjpa CoachController.java CoachController sql injection</title><link>https://www.cve.org/CVERecord?id=CVE-2025-0404</link><description>A vulnerability has been found in liujianview gymxmjpa 1.0 and classified as critical. This vulnerability affects the function CoachController of the file src/main/java/com/liujian/gymxmjpa/controller/CoachController.java. The manipulation of the argument coachName leads to sql injection. The attack can be initiated remotely. The exploit has been disclosed to the public and may be used.</description><pubDate>Mon, 13 Jan 2025 01:23:01 +0000</pubDate></item><item><title>CVE-2025-0405 | liujianview gymxmjpa GoodsController.java GoodsDaoImpl sql injection</title><link>https://www.cve.org/CVERecord?id=CVE-2025-0405</link><description>A vulnerability was found in liujianview gymxmjpa 1.0 and classified as critical. This issue affects the function GoodsDaoImpl of the file src/main/java/com/liujian/gymxmjpa/controller/GoodsController.java. The manipulation of the argument goodsName leads to sql injection. The attack may be initiated remotely. The exploit has been disclosed to the public and may be used.</description><pubDate>Mon, 13 Jan 2025 01:23:02 +0000</pubDate></item><item><title>CVE-2025-0403 | 1902756969 reggie Phone Number Validation sendMsg information disclosure</title><link>https://www.cve.org/CVERecord?id=CVE-2025-0403</link><description>A vulnerability, which was classified as problematic, has been found in 1902756969 reggie 1.0. Affected by this issue is some unknown functionality of the file /user/sendMsg of the component Phone Number Validation Handler. The manipulation of the argument code leads to information disclosure. The attack may be launched remotely. The exploit has been disclosed to the public and may be used.</description><pubDate>Mon, 13 Jan 2025 01:23:03 +0000</pubDate></item><item><title>CVE-2025-0401 | 1902756969 reggie CommonController.java download path traversal</title><link>https://www.cve.org/CVERecord?id=CVE-2025-0401</link><description>A vulnerability classified as critical has been found in 1902756969 reggie 1.0. Affected is the function download of the file src/main/java/com/itheima/reggie/controller/CommonController.java. The manipulation of the argument name leads to path traversal. It is possible to launch the attack remotely. The exploit has been disclosed to the public and may be used.</description><pubDate>Sun, 12 Jan 2025 23:38:33 +0000</pubDate></item><item><title>CVE-2025-0402 | 1902756969 reggie CommonController.java upload unrestricted upload</title><link>https://www.cve.org/CVERecord?id=CVE-2025-0402</link><description>A vulnerability classified as critical was found in 1902756969 reggie 1.0. Affected by this vulnerability is the function upload of the file src/main/java/com/itheima/reggie/controller/CommonController.java. The manipulation of the argument file leads to unrestricted upload. The attack can be launched remotely. The exploit has been disclosed to the public and may be used.</description><pubDate>Sun, 12 Jan 2025 23:38:33 +0000</pubDate></item><item><title>CVE-2025-0399 | StarSea99 starsea-mall uploadController.java UploadController unrestricted upload</title><link>https://www.cve.org/CVERecord?id=CVE-2025-0399</link><description>A vulnerability was found in StarSea99 starsea-mall 1.0. It has been declared as critical. This vulnerability affects the function UploadController of the file src/main/java/com/siro/mall/controller/common/uploadController.java. The manipulation of the argument file leads to unrestricted upload. The attack can be initiated remotely. The exploit has been disclosed to the public and may be used.</description><pubDate>Sun, 12 Jan 2025 23:07:43 +0000</pubDate></item><item><title>CVE-2025-0400 | StarSea99 starsea-mall update cross site scripting</title><link>https://www.cve.org/CVERecord?id=CVE-2025-0400</link><description>A vulnerability was found in StarSea99 starsea-mall 1.0. It has been rated as problematic. This issue affects some unknown processing of the file /admin/categories/update. The manipulation of the argument categoryName leads to cross site scripting. The attack may be initiated remotely. The exploit has been disclosed to the public and may be used.</description><pubDate>Sun, 12 Jan 2025 23:07:43 +0000</pubDate></item><item><title>CVE-2024-42181 | HCL MyXalytics is affected by a cleartext transmission of sensitive information vulnerability</title><link>https://www.cve.org/CVERecord?id=CVE-2024-42181</link><description>HCL MyXalytics is affected by a cleartext transmission of sensitive information vulnerability.  The application transmits sensitive or security-critical data in cleartext in a communication channel that can be sniffed by unauthorized actors.</description><pubDate>Sun, 12 Jan 2025 22:17:43 +0000</pubDate></item><item><title>CVE-2024-42180 | HCL MyXalytics is affected by a malicious file upload vulnerability</title><link>https://www.cve.org/CVERecord?id=CVE-2024-42180</link><description>HCL MyXalytics is affected by a malicious file upload vulnerability.  The application accepts invalid file uploads, including incorrect content types, double extensions, null bytes, and special characters, allowing attackers to upload and execute malicious files.</description><pubDate>Sun, 12 Jan 2025 22:00:43 +0000</pubDate></item><item><title>CVE-2024-42179 | HCL MyXalytics is affected by sensitive information disclosure vulnerability</title><link>https://www.cve.org/CVERecord?id=CVE-2024-42179</link><description>HCL MyXalytics is affected by sensitive information disclosure vulnerability.  The HTTP response header exposes the Microsoft-HTTP API∕2.0 as the server's name &amp; version.</description><pubDate>Sun, 12 Jan 2025 21:53:31 +0000</pubDate></item><item><title>CVE-2025-0398 | longpi1 warehouse Backend updateInport cross site scripting</title><link>https://www.cve.org/CVERecord?id=CVE-2025-0398</link><description>A vulnerability has been found in longpi1 warehouse 1.0 and classified as problematic. Affected by this vulnerability is an unknown functionality of the file /resources/..;/inport/updateInport of the component Backend. The manipulation of the argument remark leads to cross site scripting. The attack can be launched remotely. The exploit has been disclosed to the public and may be used.</description><pubDate>Sun, 12 Jan 2025 14:11:36 +0000</pubDate></item><item><title>CVE-2024-51456 | IBM Robotic Process Automation information disclosure</title><link>https://www.cve.org/CVERecord?id=CVE-2024-51456</link><description>IBM Robotic Process Automation 21.0.0 through 21.0.7.19 and 23.0.0 through 23.0.19 could allow a remote attacker to obtain sensitive data that may be exposed through certain crypto-analytic attacks.</description><pubDate>Sun, 12 Jan 2025 13:37:26 +0000</pubDate></item><item><title>CVE-2025-0397 | reckcn SPPanAdmin edit cross site scripting</title><link>https://www.cve.org/CVERecord?id=CVE-2025-0397</link><description>A vulnerability, which was classified as problematic, was found in reckcn SPPanAdmin 1.0. Affected is an unknown function of the file /;/admin/role/edit. The manipulation of the argument name leads to cross site scripting. It is possible to launch the attack remotely. The exploit has been disclosed to the public and may be used. Other parameters might be affected as well. The vendor was contacted early about this disclosure but did not respond in any way.</description><pubDate>Sun, 12 Jan 2025 12:57:47 +0000</pubDate></item><item><title>CVE-2025-0396 | exelban stats XPC Service shouldAcceptNewConnection command injection</title><link>https://www.cve.org/CVERecord?id=CVE-2025-0396</link><description>A vulnerability, which was classified as critical, has been found in exelban stats up to 2.11.21. This issue affects the function shouldAcceptNewConnection of the component XPC Service. The manipulation leads to command injection. It is possible to launch the attack on the local host. Upgrading to version 2.11.22 is able to address this issue. It is recommended to upgrade the affected component.</description><pubDate>Sun, 12 Jan 2025 12:33:01 +0000</pubDate></item><item><title>CVE-2021-29669 | IBM Jazz Foundation cross-site scripting</title><link>https://www.cve.org/CVERecord?id=CVE-2021-29669</link><description>IBM Jazz Foundation 6.0.6, 6.0.6.1, 7.0, 7.0.1, and 7.0.2 is vulnerable to cross-site scripting. This vulnerability allows users to embed arbitrary JavaScript code in the Web UI thus altering the intended functionality potentially leading to credentials disclosure within a trusted session.</description><pubDate>Sun, 12 Jan 2025 02:39:13 +0000</pubDate></item><item><title>CVE-2024-49785 | IBM watsonx.ai cross-site scripting</title><link>https://www.cve.org/CVERecord?id=CVE-2024-49785</link><description>IBM watsonx.ai 1.1 through 2.0.3 and IBM watsonx.ai on Cloud Pak for Data 4.8 through 5.0.3 is vulnerable to cross-site scripting. This vulnerability allows an authenticated user to embed arbitrary JavaScript code in the Web UI thus altering the intended functionality potentially leading to credentials disclosure within a trusted session.</description><pubDate>Sun, 12 Jan 2025 02:39:13 +0000</pubDate></item><item><title>CVE-2024-57881 | mm/page_alloc: don&amp;#x27;t call pfn_to_page() on possibly non-existent PFN in split_large_buddy()</title><link>https://www.cve.org/CVERecord?id=CVE-2024-57881</link><description>In the Linux kernel, the following vulnerability has been resolved:

mm/page_alloc: don't call pfn_to_page() on possibly non-existent PFN in split_large_buddy()

In split_large_buddy(), we might call pfn_to_page() on a PFN that might
not exist.  In corner cases, such as when freeing the highest pageblock in
the last memory section, this could result with CONFIG_SPARSEMEM &amp;&amp;
!CONFIG_SPARSEMEM_EXTREME in __pfn_to_section() returning NULL and and
__section_mem_map_addr() dereferencing that NULL pointer.

Let's fix it, and avoid doing a pfn_to_page() call for the first
iteration, where we already have the page.

So far this was found by code inspection, but let's just CC stable as the
fix is easy.</description><pubDate>Sat, 11 Jan 2025 15:26:24 +0000</pubDate></item><item><title>CVE-2024-57879 | Bluetooth: iso: Always release hdev at the end of iso_listen_bis</title><link>https://www.cve.org/CVERecord?id=CVE-2024-57879</link><description>In the Linux kernel, the following vulnerability has been resolved:

Bluetooth: iso: Always release hdev at the end of iso_listen_bis

Since hci_get_route holds the device before returning, the hdev
should be released with hci_dev_put at the end of iso_listen_bis
even if the function returns with an error.</description><pubDate>Sat, 11 Jan 2025 15:11:24 +0000</pubDate></item><item><title>CVE-2024-57880 | ASoC: Intel: sof_sdw: Add space for a terminator into DAIs array</title><link>https://www.cve.org/CVERecord?id=CVE-2024-57880</link><description>In the Linux kernel, the following vulnerability has been resolved:

ASoC: Intel: sof_sdw: Add space for a terminator into DAIs array

The code uses the initialised member of the asoc_sdw_dailink struct to
determine if a member of the array is in use. However in the case the
array is completely full this will lead to an access 1 past the end of
the array, expand the array by one entry to include a space for a
terminator.</description><pubDate>Sat, 11 Jan 2025 15:11:25 +0000</pubDate></item><item><title>CVE-2024-57874 | arm64: ptrace: fix partial SETREGSET for NT_ARM_TAGGED_ADDR_CTRL</title><link>https://www.cve.org/CVERecord?id=CVE-2024-57874</link><description>In the Linux kernel, the following vulnerability has been resolved:

arm64: ptrace: fix partial SETREGSET for NT_ARM_TAGGED_ADDR_CTRL

Currently tagged_addr_ctrl_set() doesn't initialize the temporary 'ctrl'
variable, and a SETREGSET call with a length of zero will leave this
uninitialized. Consequently tagged_addr_ctrl_set() will consume an
arbitrary value, potentially leaking up to 64 bits of memory from the
kernel stack. The read is limited to a specific slot on the stack, and
the issue does not provide a write mechanism.

As set_tagged_addr_ctrl() only accepts values where bits [63:4] zero and
rejects other values, a partial SETREGSET attempt will randomly succeed
or fail depending on the value of the uninitialized value, and the
exposure is significantly limited.

Fix this by initializing the temporary value before copying the regset
from userspace, as for other regsets (e.g. NT_PRSTATUS, NT_PRFPREG,
NT_ARM_SYSTEM_CALL). In the case of a zero-length write, the existing
value of the tagged address ctrl will be retained.

The NT_ARM_TAGGED_ADDR_CTRL regset is only visible in the
user_aarch64_view used by a native AArch64 task to manipulate another
native AArch64 task. As get_tagged_addr_ctrl() only returns an error
value when called for a compat task, tagged_addr_ctrl_get() and
tagged_addr_ctrl_set() should never observe an error value from
get_tagged_addr_ctrl(). Add a WARN_ON_ONCE() to both to indicate that
such an error would be unexpected, and error handlnig is not missing in
either case.</description><pubDate>Sat, 11 Jan 2025 14:50:07 +0000</pubDate></item><item><title>CVE-2024-57875 | block: RCU protect disk-&amp;gt;conv_zones_bitmap</title><link>https://www.cve.org/CVERecord?id=CVE-2024-57875</link><description>In the Linux kernel, the following vulnerability has been resolved:

block: RCU protect disk-&gt;conv_zones_bitmap

Ensure that a disk revalidation changing the conventional zones bitmap
of a disk does not cause invalid memory references when using the
disk_zone_is_conv() helper by RCU protecting the disk-&gt;conv_zones_bitmap
pointer.

disk_zone_is_conv() is modified to operate under the RCU read lock and
the function disk_set_conv_zones_bitmap() is added to update a disk
conv_zones_bitmap pointer using rcu_replace_pointer() with the disk
zone_wplugs_lock spinlock held.

disk_free_zone_resources() is modified to call
disk_update_zone_resources() with a NULL bitmap pointer to free the disk
conv_zones_bitmap. disk_set_conv_zones_bitmap() is also used in
disk_update_zone_resources() to set the new (revalidated) bitmap and
free the old one.</description><pubDate>Sat, 11 Jan 2025 14:50:07 +0000</pubDate></item><item><title>CVE-2024-57876 | drm/dp_mst: Fix resetting msg rx state after topology removal</title><link>https://www.cve.org/CVERecord?id=CVE-2024-57876</link><description>In the Linux kernel, the following vulnerability has been resolved:

drm/dp_mst: Fix resetting msg rx state after topology removal

If the MST topology is removed during the reception of an MST down reply
or MST up request sideband message, the
drm_dp_mst_topology_mgr::up_req_recv/down_rep_recv states could be reset
from one thread via drm_dp_mst_topology_mgr_set_mst(false), racing with
the reading/parsing of the message from another thread via
drm_dp_mst_handle_down_rep() or drm_dp_mst_handle_up_req(). The race is
possible since the reader/parser doesn't hold any lock while accessing
the reception state. This in turn can lead to a memory corruption in the
reader/parser as described by commit bd2fccac61b4 ("drm/dp_mst: Fix MST
sideband message body length check").

Fix the above by resetting the message reception state if needed before
reading/parsing a message. Another solution would be to hold the
drm_dp_mst_topology_mgr::lock for the whole duration of the message
reception/parsing in drm_dp_mst_handle_down_rep() and
drm_dp_mst_handle_up_req(), however this would require a bigger change.
Since the fix is also needed for stable, opting for the simpler solution
in this patch.</description><pubDate>Sat, 11 Jan 2025 14:50:08 +0000</pubDate></item><item><title>CVE-2024-57877 | arm64: ptrace: fix partial SETREGSET for NT_ARM_POE</title><link>https://www.cve.org/CVERecord?id=CVE-2024-57877</link><description>In the Linux kernel, the following vulnerability has been resolved:

arm64: ptrace: fix partial SETREGSET for NT_ARM_POE

Currently poe_set() doesn't initialize the temporary 'ctrl' variable,
and a SETREGSET call with a length of zero will leave this
uninitialized. Consequently an arbitrary value will be written back to
target-&gt;thread.por_el0, potentially leaking up to 64 bits of memory from
the kernel stack. The read is limited to a specific slot on the stack,
and the issue does not provide a write mechanism.

Fix this by initializing the temporary value before copying the regset
from userspace, as for other regsets (e.g. NT_PRSTATUS, NT_PRFPREG,
NT_ARM_SYSTEM_CALL). In the case of a zero-length write, the existing
contents of POR_EL1 will be retained.

Before this patch:

| # ./poe-test
| Attempting to write NT_ARM_POE::por_el0 = 0x900d900d900d900d
| SETREGSET(nt=0x40f, len=8) wrote 8 bytes
|
| Attempting to read NT_ARM_POE::por_el0
| GETREGSET(nt=0x40f, len=8) read 8 bytes
| Read NT_ARM_POE::por_el0 = 0x900d900d900d900d
|
| Attempting to write NT_ARM_POE (zero length)
| SETREGSET(nt=0x40f, len=0) wrote 0 bytes
|
| Attempting to read NT_ARM_POE::por_el0
| GETREGSET(nt=0x40f, len=8) read 8 bytes
| Read NT_ARM_POE::por_el0 = 0xffff8000839c3d50

After this patch:

| # ./poe-test
| Attempting to write NT_ARM_POE::por_el0 = 0x900d900d900d900d
| SETREGSET(nt=0x40f, len=8) wrote 8 bytes
|
| Attempting to read NT_ARM_POE::por_el0
| GETREGSET(nt=0x40f, len=8) read 8 bytes
| Read NT_ARM_POE::por_el0 = 0x900d900d900d900d
|
| Attempting to write NT_ARM_POE (zero length)
| SETREGSET(nt=0x40f, len=0) wrote 0 bytes
|
| Attempting to read NT_ARM_POE::por_el0
| GETREGSET(nt=0x40f, len=8) read 8 bytes
| Read NT_ARM_POE::por_el0 = 0x900d900d900d900d</description><pubDate>Sat, 11 Jan 2025 14:50:08 +0000</pubDate></item><item><title>CVE-2024-57878 | arm64: ptrace: fix partial SETREGSET for NT_ARM_FPMR</title><link>https://www.cve.org/CVERecord?id=CVE-2024-57878</link><description>In the Linux kernel, the following vulnerability has been resolved:

arm64: ptrace: fix partial SETREGSET for NT_ARM_FPMR

Currently fpmr_set() doesn't initialize the temporary 'fpmr' variable,
and a SETREGSET call with a length of zero will leave this
uninitialized. Consequently an arbitrary value will be written back to
target-&gt;thread.uw.fpmr, potentially leaking up to 64 bits of memory from
the kernel stack. The read is limited to a specific slot on the stack,
and the issue does not provide a write mechanism.

Fix this by initializing the temporary value before copying the regset
from userspace, as for other regsets (e.g. NT_PRSTATUS, NT_PRFPREG,
NT_ARM_SYSTEM_CALL). In the case of a zero-length write, the existing
contents of FPMR will be retained.

Before this patch:

| # ./fpmr-test
| Attempting to write NT_ARM_FPMR::fpmr = 0x900d900d900d900d
| SETREGSET(nt=0x40e, len=8) wrote 8 bytes
|
| Attempting to read NT_ARM_FPMR::fpmr
| GETREGSET(nt=0x40e, len=8) read 8 bytes
| Read NT_ARM_FPMR::fpmr = 0x900d900d900d900d
|
| Attempting to write NT_ARM_FPMR (zero length)
| SETREGSET(nt=0x40e, len=0) wrote 0 bytes
|
| Attempting to read NT_ARM_FPMR::fpmr
| GETREGSET(nt=0x40e, len=8) read 8 bytes
| Read NT_ARM_FPMR::fpmr = 0xffff800083963d50

After this patch:

| # ./fpmr-test
| Attempting to write NT_ARM_FPMR::fpmr = 0x900d900d900d900d
| SETREGSET(nt=0x40e, len=8) wrote 8 bytes
|
| Attempting to read NT_ARM_FPMR::fpmr
| GETREGSET(nt=0x40e, len=8) read 8 bytes
| Read NT_ARM_FPMR::fpmr = 0x900d900d900d900d
|
| Attempting to write NT_ARM_FPMR (zero length)
| SETREGSET(nt=0x40e, len=0) wrote 0 bytes
|
| Attempting to read NT_ARM_FPMR::fpmr
| GETREGSET(nt=0x40e, len=8) read 8 bytes
| Read NT_ARM_FPMR::fpmr = 0x900d900d900d900d</description><pubDate>Sat, 11 Jan 2025 14:50:09 +0000</pubDate></item><item><title>CVE-2024-57839 | Revert &amp;quot;readahead: properly shorten readahead when falling back to do_page_cache_ra()&amp;quot;</title><link>https://www.cve.org/CVERecord?id=CVE-2024-57839</link><description>In the Linux kernel, the following vulnerability has been resolved:

Revert "readahead: properly shorten readahead when falling back to do_page_cache_ra()"

This reverts commit 7c877586da3178974a8a94577b6045a48377ff25.

Anders and Philippe have reported that recent kernels occasionally hang
when used with NFS in readahead code.  The problem has been bisected to
7c877586da3 ("readahead: properly shorten readahead when falling back to
do_page_cache_ra()").  The cause of the problem is that ra-&gt;size can be
shrunk by read_pages() call and subsequently we end up calling
do_page_cache_ra() with negative (read huge positive) number of pages. 
Let's revert 7c877586da3 for now until we can find a proper way how the
logic in read_pages() and page_cache_ra_order() can coexist.  This can
lead to reduced readahead throughput due to readahead window confusion but
that's better than outright hangs.</description><pubDate>Sat, 11 Jan 2025 14:43:12 +0000</pubDate></item><item><title>CVE-2024-57843 | virtio-net: fix overflow inside virtnet_rq_alloc</title><link>https://www.cve.org/CVERecord?id=CVE-2024-57843</link><description>In the Linux kernel, the following vulnerability has been resolved:

virtio-net: fix overflow inside virtnet_rq_alloc

When the frag just got a page, then may lead to regression on VM.
Specially if the sysctl net.core.high_order_alloc_disable value is 1,
then the frag always get a page when do refill.

Which could see reliable crashes or scp failure (scp a file 100M in size
to VM).

The issue is that the virtnet_rq_dma takes up 16 bytes at the beginning
of a new frag. When the frag size is larger than PAGE_SIZE,
everything is fine. However, if the frag is only one page and the
total size of the buffer and virtnet_rq_dma is larger than one page, an
overflow may occur.

The commit f9dac92ba908 ("virtio_ring: enable premapped mode whatever
use_dma_api") introduced this problem. And we reverted some commits to
fix this in last linux version. Now we try to enable it and fix this
bug directly.

Here, when the frag size is not enough, we reduce the buffer len to fix
this problem.</description><pubDate>Sat, 11 Jan 2025 14:43:12 +0000</pubDate></item><item><title>CVE-2024-57849 | s390/cpum_sf: Handle CPU hotplug remove during sampling</title><link>https://www.cve.org/CVERecord?id=CVE-2024-57849</link><description>In the Linux kernel, the following vulnerability has been resolved:

s390/cpum_sf: Handle CPU hotplug remove during sampling

CPU hotplug remove handling triggers the following function
call sequence:

   CPUHP_AP_PERF_S390_SF_ONLINE  --&gt; s390_pmu_sf_offline_cpu()
   ...
   CPUHP_AP_PERF_ONLINE          --&gt; perf_event_exit_cpu()

The s390 CPUMF sampling CPU hotplug handler invokes:

 s390_pmu_sf_offline_cpu()
 +--&gt;  cpusf_pmu_setup()
       +--&gt; setup_pmc_cpu()
            +--&gt; deallocate_buffers()

This function de-allocates all sampling data buffers (SDBs) allocated
for that CPU at event initialization. It also clears the
PMU_F_RESERVED bit. The CPU is gone and can not be sampled.

With the event still being active on the removed CPU, the CPU event
hotplug support in kernel performance subsystem triggers the
following function calls on the removed CPU:

  perf_event_exit_cpu()
  +--&gt; perf_event_exit_cpu_context()
       +--&gt; __perf_event_exit_context()
	    +--&gt; __perf_remove_from_context()
	         +--&gt; event_sched_out()
	              +--&gt; cpumsf_pmu_del()
	                   +--&gt; cpumsf_pmu_stop()
                                +--&gt; hw_perf_event_update()

to stop and remove the event. During removal of the event, the
sampling device driver tries to read out the remaining samples from
the sample data buffers (SDBs). But they have already been freed
(and may have been re-assigned). This may lead to a use after free
situation in which case the samples are most likely invalid. In the
best case the memory has not been reassigned and still contains
valid data.

Remedy this situation and check if the CPU is still in reserved
state (bit PMU_F_RESERVED set). In this case the SDBs have not been
released an contain valid data. This is always the case when
the event is removed (and no CPU hotplug off occured).
If the PMU_F_RESERVED bit is not set, the SDB buffers are gone.</description><pubDate>Sat, 11 Jan 2025 14:43:13 +0000</pubDate></item><item><title>CVE-2024-57850 | jffs2: Prevent rtime decompress memory corruption</title><link>https://www.cve.org/CVERecord?id=CVE-2024-57850</link><description>In the Linux kernel, the following vulnerability has been resolved:

jffs2: Prevent rtime decompress memory corruption

The rtime decompression routine does not fully check bounds during the
entirety of the decompression pass and can corrupt memory outside the
decompression buffer if the compressed data is corrupted. This adds the
required check to prevent this failure mode.</description><pubDate>Sat, 11 Jan 2025 14:43:13 +0000</pubDate></item><item><title>CVE-2024-57872 | scsi: ufs: pltfrm: Dellocate HBA during ufshcd_pltfrm_remove()</title><link>https://www.cve.org/CVERecord?id=CVE-2024-57872</link><description>In the Linux kernel, the following vulnerability has been resolved:

scsi: ufs: pltfrm: Dellocate HBA during ufshcd_pltfrm_remove()

This will ensure that the scsi host is cleaned up properly using
scsi_host_dev_release(). Otherwise, it may lead to memory leaks.</description><pubDate>Sat, 11 Jan 2025 14:43:14 +0000</pubDate></item><item><title>CVE-2025-23124 | block: RCU protect disk-&amp;gt;conv_zones_bitmap</title><link>https://www.cve.org/CVERecord?id=CVE-2025-23124</link><description>In the Linux kernel, the following vulnerability has been resolved:

block: RCU protect disk-&gt;conv_zones_bitmap

Ensure that a disk revalidation changing the conventional zones bitmap
of a disk does not cause invalid memory references when using the
disk_zone_is_conv() helper by RCU protecting the disk-&gt;conv_zones_bitmap
pointer.

disk_zone_is_conv() is modified to operate under the RCU read lock and
the function disk_set_conv_zones_bitmap() is added to update a disk
conv_zones_bitmap pointer using rcu_replace_pointer() with the disk
zone_wplugs_lock spinlock held.

disk_free_zone_resources() is modified to call
disk_update_zone_resources() with a NULL bitmap pointer to free the disk
conv_zones_bitmap. disk_set_conv_zones_bitmap() is also used in
disk_update_zone_resources() to set the new (revalidated) bitmap and
free the old one.</description><pubDate>Sat, 11 Jan 2025 14:43:14 +0000</pubDate></item><item><title>CVE-2025-23125 | drm/dp_mst: Fix resetting msg rx state after topology removal</title><link>https://www.cve.org/CVERecord?id=CVE-2025-23125</link><description>In the Linux kernel, the following vulnerability has been resolved:

drm/dp_mst: Fix resetting msg rx state after topology removal

If the MST topology is removed during the reception of an MST down reply
or MST up request sideband message, the
drm_dp_mst_topology_mgr::up_req_recv/down_rep_recv states could be reset
from one thread via drm_dp_mst_topology_mgr_set_mst(false), racing with
the reading/parsing of the message from another thread via
drm_dp_mst_handle_down_rep() or drm_dp_mst_handle_up_req(). The race is
possible since the reader/parser doesn't hold any lock while accessing
the reception state. This in turn can lead to a memory corruption in the
reader/parser as described by commit bd2fccac61b4 ("drm/dp_mst: Fix MST
sideband message body length check").

Fix the above by resetting the message reception state if needed before
reading/parsing a message. Another solution would be to hold the
drm_dp_mst_topology_mgr::lock for the whole duration of the message
reception/parsing in drm_dp_mst_handle_down_rep() and
drm_dp_mst_handle_up_req(), however this would require a bigger change.
Since the fix is also needed for stable, opting for the simpler solution
in this patch.</description><pubDate>Sat, 11 Jan 2025 14:43:15 +0000</pubDate></item><item><title>CVE-2025-23126 | arm64: ptrace: fix partial SETREGSET for NT_ARM_POE</title><link>https://www.cve.org/CVERecord?id=CVE-2025-23126</link><description>In the Linux kernel, the following vulnerability has been resolved:

arm64: ptrace: fix partial SETREGSET for NT_ARM_POE

Currently poe_set() doesn't initialize the temporary 'ctrl' variable,
and a SETREGSET call with a length of zero will leave this
uninitialized. Consequently an arbitrary value will be written back to
target-&gt;thread.por_el0, potentially leaking up to 64 bits of memory from
the kernel stack. The read is limited to a specific slot on the stack,
and the issue does not provide a write mechanism.

Fix this by initializing the temporary value before copying the regset
from userspace, as for other regsets (e.g. NT_PRSTATUS, NT_PRFPREG,
NT_ARM_SYSTEM_CALL). In the case of a zero-length write, the existing
contents of POR_EL1 will be retained.

Before this patch:

| # ./poe-test
| Attempting to write NT_ARM_POE::por_el0 = 0x900d900d900d900d
| SETREGSET(nt=0x40f, len=8) wrote 8 bytes
|
| Attempting to read NT_ARM_POE::por_el0
| GETREGSET(nt=0x40f, len=8) read 8 bytes
| Read NT_ARM_POE::por_el0 = 0x900d900d900d900d
|
| Attempting to write NT_ARM_POE (zero length)
| SETREGSET(nt=0x40f, len=0) wrote 0 bytes
|
| Attempting to read NT_ARM_POE::por_el0
| GETREGSET(nt=0x40f, len=8) read 8 bytes
| Read NT_ARM_POE::por_el0 = 0xffff8000839c3d50

After this patch:

| # ./poe-test
| Attempting to write NT_ARM_POE::por_el0 = 0x900d900d900d900d
| SETREGSET(nt=0x40f, len=8) wrote 8 bytes
|
| Attempting to read NT_ARM_POE::por_el0
| GETREGSET(nt=0x40f, len=8) read 8 bytes
| Read NT_ARM_POE::por_el0 = 0x900d900d900d900d
|
| Attempting to write NT_ARM_POE (zero length)
| SETREGSET(nt=0x40f, len=0) wrote 0 bytes
|
| Attempting to read NT_ARM_POE::por_el0
| GETREGSET(nt=0x40f, len=8) read 8 bytes
| Read NT_ARM_POE::por_el0 = 0x900d900d900d900d</description><pubDate>Sat, 11 Jan 2025 14:43:15 +0000</pubDate></item><item><title>CVE-2025-23127 | arm64: ptrace: fix partial SETREGSET for NT_ARM_FPMR</title><link>https://www.cve.org/CVERecord?id=CVE-2025-23127</link><description>In the Linux kernel, the following vulnerability has been resolved:

arm64: ptrace: fix partial SETREGSET for NT_ARM_FPMR

Currently fpmr_set() doesn't initialize the temporary 'fpmr' variable,
and a SETREGSET call with a length of zero will leave this
uninitialized. Consequently an arbitrary value will be written back to
target-&gt;thread.uw.fpmr, potentially leaking up to 64 bits of memory from
the kernel stack. The read is limited to a specific slot on the stack,
and the issue does not provide a write mechanism.

Fix this by initializing the temporary value before copying the regset
from userspace, as for other regsets (e.g. NT_PRSTATUS, NT_PRFPREG,
NT_ARM_SYSTEM_CALL). In the case of a zero-length write, the existing
contents of FPMR will be retained.

Before this patch:

| # ./fpmr-test
| Attempting to write NT_ARM_FPMR::fpmr = 0x900d900d900d900d
| SETREGSET(nt=0x40e, len=8) wrote 8 bytes
|
| Attempting to read NT_ARM_FPMR::fpmr
| GETREGSET(nt=0x40e, len=8) read 8 bytes
| Read NT_ARM_FPMR::fpmr = 0x900d900d900d900d
|
| Attempting to write NT_ARM_FPMR (zero length)
| SETREGSET(nt=0x40e, len=0) wrote 0 bytes
|
| Attempting to read NT_ARM_FPMR::fpmr
| GETREGSET(nt=0x40e, len=8) read 8 bytes
| Read NT_ARM_FPMR::fpmr = 0xffff800083963d50

After this patch:

| # ./fpmr-test
| Attempting to write NT_ARM_FPMR::fpmr = 0x900d900d900d900d
| SETREGSET(nt=0x40e, len=8) wrote 8 bytes
|
| Attempting to read NT_ARM_FPMR::fpmr
| GETREGSET(nt=0x40e, len=8) read 8 bytes
| Read NT_ARM_FPMR::fpmr = 0x900d900d900d900d
|
| Attempting to write NT_ARM_FPMR (zero length)
| SETREGSET(nt=0x40e, len=0) wrote 0 bytes
|
| Attempting to read NT_ARM_FPMR::fpmr
| GETREGSET(nt=0x40e, len=8) read 8 bytes
| Read NT_ARM_FPMR::fpmr = 0x900d900d900d900d</description><pubDate>Sat, 11 Jan 2025 14:43:15 +0000</pubDate></item><item><title>CVE-2025-23128 | arm64: ptrace: fix partial SETREGSET for NT_ARM_TAGGED_ADDR_CTRL</title><link>https://www.cve.org/CVERecord?id=CVE-2025-23128</link><description>In the Linux kernel, the following vulnerability has been resolved:

arm64: ptrace: fix partial SETREGSET for NT_ARM_TAGGED_ADDR_CTRL

Currently tagged_addr_ctrl_set() doesn't initialize the temporary 'ctrl'
variable, and a SETREGSET call with a length of zero will leave this
uninitialized. Consequently tagged_addr_ctrl_set() will consume an
arbitrary value, potentially leaking up to 64 bits of memory from the
kernel stack. The read is limited to a specific slot on the stack, and
the issue does not provide a write mechanism.

As set_tagged_addr_ctrl() only accepts values where bits [63:4] zero and
rejects other values, a partial SETREGSET attempt will randomly succeed
or fail depending on the value of the uninitialized value, and the
exposure is significantly limited.

Fix this by initializing the temporary value before copying the regset
from userspace, as for other regsets (e.g. NT_PRSTATUS, NT_PRFPREG,
NT_ARM_SYSTEM_CALL). In the case of a zero-length write, the existing
value of the tagged address ctrl will be retained.

The NT_ARM_TAGGED_ADDR_CTRL regset is only visible in the
user_aarch64_view used by a native AArch64 task to manipulate another
native AArch64 task. As get_tagged_addr_ctrl() only returns an error
value when called for a compat task, tagged_addr_ctrl_get() and
tagged_addr_ctrl_set() should never observe an error value from
get_tagged_addr_ctrl(). Add a WARN_ON_ONCE() to both to indicate that
such an error would be unexpected, and error handlnig is not missing in
either case.</description><pubDate>Sat, 11 Jan 2025 14:43:16 +0000</pubDate></item><item><title>CVE-2024-57809 | PCI: imx6: Fix suspend/resume support on i.MX6QDL</title><link>https://www.cve.org/CVERecord?id=CVE-2024-57809</link><description>In the Linux kernel, the following vulnerability has been resolved:

PCI: imx6: Fix suspend/resume support on i.MX6QDL

The suspend/resume functionality is currently broken on the i.MX6QDL
platform, as documented in the NXP errata (ERR005723):

  https://www.nxp.com/docs/en/errata/IMX6DQCE.pdf

This patch addresses the issue by sharing most of the suspend/resume
sequences used by other i.MX devices, while avoiding modifications to
critical registers that disrupt the PCIe functionality. It targets the
same problem as the following downstream commit:

  https://github.com/nxp-imx/linux-imx/commit/4e92355e1f79d225ea842511fcfd42b343b32995

Unlike the downstream commit, this patch also resets the connected PCIe
device if possible. Without this reset, certain drivers, such as ath10k
or iwlwifi, will crash on resume. The device reset is also done by the
driver on other i.MX platforms, making this patch consistent with
existing practices.

Upon resuming, the kernel will hang and display an error. Here's an
example of the error encountered with the ath10k driver:

  ath10k_pci 0000:01:00.0: Unable to change power state from D3hot to D0, device inaccessible
  Unhandled fault: imprecise external abort (0x1406) at 0x0106f944

Without this patch, suspend/resume will fail on i.MX6QDL devices if a
PCIe device is connected.

[kwilczynski: commit log, added tag for stable releases]</description><pubDate>Sat, 11 Jan 2025 14:27:11 +0000</pubDate></item><item><title>CVE-2024-57838 | s390/entry: Mark IRQ entries to fix stack depot warnings</title><link>https://www.cve.org/CVERecord?id=CVE-2024-57838</link><description>In the Linux kernel, the following vulnerability has been resolved:

s390/entry: Mark IRQ entries to fix stack depot warnings

The stack depot filters out everything outside of the top interrupt
context as an uninteresting or irrelevant part of the stack traces. This
helps with stack trace de-duplication, avoiding an explosion of saved
stack traces that share the same IRQ context code path but originate
from different randomly interrupted points, eventually exhausting the
stack depot.

Filtering uses in_irqentry_text() to identify functions within the
.irqentry.text and .softirqentry.text sections, which then become the
last stack trace entries being saved.

While __do_softirq() is placed into the .softirqentry.text section by
common code, populating .irqentry.text is architecture-specific.

Currently, the .irqentry.text section on s390 is empty, which prevents
stack depot filtering and de-duplication and could result in warnings
like:

Stack depot reached limit capacity
WARNING: CPU: 0 PID: 286113 at lib/stackdepot.c:252 depot_alloc_stack+0x39a/0x3c8

with PREEMPT and KASAN enabled.

Fix this by moving the IO/EXT interrupt handlers from .kprobes.text into
the .irqentry.text section and updating the kprobes blacklist to include
the .irqentry.text section.

This is done only for asynchronous interrupts and explicitly not for
program checks, which are synchronous and where the context beyond the
program check is important to preserve. Despite machine checks being
somewhat in between, they are extremely rare, and preserving context
when possible is also of value.

SVCs and Restart Interrupts are not relevant, one being always at the
boundary to user space and the other being a one-time thing.

IRQ entries filtering is also optionally used in ftrace function graph,
where the same logic applies.</description><pubDate>Sat, 11 Jan 2025 14:27:11 +0000</pubDate></item><item><title>CVE-2024-41149 | block: avoid to reuse `hctx` not removed from cpuhp callback list</title><link>https://www.cve.org/CVERecord?id=CVE-2024-41149</link><description>In the Linux kernel, the following vulnerability has been resolved:

block: avoid to reuse `hctx` not removed from cpuhp callback list

If the 'hctx' isn't removed from cpuhp callback list, we can't reuse it,
otherwise use-after-free may be triggered.</description><pubDate>Sat, 11 Jan 2025 12:51:35 +0000</pubDate></item><item><title>CVE-2024-46896 | drm/amdgpu: don&amp;#x27;t access invalid sched</title><link>https://www.cve.org/CVERecord?id=CVE-2024-46896</link><description>In the Linux kernel, the following vulnerability has been resolved:

drm/amdgpu: don't access invalid sched

Since 2320c9e6a768 ("drm/sched: memset() 'job' in drm_sched_job_init()")
accessing job-&gt;base.sched can produce unexpected results as the initialisation
of (*job)-&gt;base.sched done in amdgpu_job_alloc is overwritten by the
memset.

This commit fixes an issue when a CS would fail validation and would
be rejected after job-&gt;num_ibs is incremented. In this case,
amdgpu_ib_free(ring-&gt;adev, ...) will be called, which would crash the
machine because the ring value is bogus.

To fix this, pass a NULL pointer to amdgpu_ib_free(): we can do this
because the device is actually not used in this function.

The next commit will remove the ring argument completely.

(cherry picked from commit 2ae520cb12831d264ceb97c61f72c59d33c0dbd7)</description><pubDate>Sat, 11 Jan 2025 12:51:36 +0000</pubDate></item><item><title>CVE-2024-47408 | net/smc: check smcd_v2_ext_offset when receiving proposal msg</title><link>https://www.cve.org/CVERecord?id=CVE-2024-47408</link><description>In the Linux kernel, the following vulnerability has been resolved:

net/smc: check smcd_v2_ext_offset when receiving proposal msg

When receiving proposal msg in server, the field smcd_v2_ext_offset in
proposal msg is from the remote client and can not be fully trusted.
Once the value of smcd_v2_ext_offset exceed the max value, there has
the chance to access wrong address, and crash may happen.

This patch checks the value of smcd_v2_ext_offset before using it.</description><pubDate>Sat, 11 Jan 2025 12:51:36 +0000</pubDate></item><item><title>CVE-2024-49568 | net/smc: check v2_ext_offset/eid_cnt/ism_gid_cnt when receiving proposal msg</title><link>https://www.cve.org/CVERecord?id=CVE-2024-49568</link><description>In the Linux kernel, the following vulnerability has been resolved:

net/smc: check v2_ext_offset/eid_cnt/ism_gid_cnt when receiving proposal msg

When receiving proposal msg in server, the fields v2_ext_offset/
eid_cnt/ism_gid_cnt in proposal msg are from the remote client
and can not be fully trusted. Especially the field v2_ext_offset,
once exceed the max value, there has the chance to access wrong
address, and crash may happen.

This patch checks the fields v2_ext_offset/eid_cnt/ism_gid_cnt
before using them.</description><pubDate>Sat, 11 Jan 2025 12:51:37 +0000</pubDate></item><item><title>CVE-2024-49571 | net/smc: check iparea_offset and ipv6_prefixes_cnt when receiving proposal msg</title><link>https://www.cve.org/CVERecord?id=CVE-2024-49571</link><description>In the Linux kernel, the following vulnerability has been resolved:

net/smc: check iparea_offset and ipv6_prefixes_cnt when receiving proposal msg

When receiving proposal msg in server, the field iparea_offset
and the field ipv6_prefixes_cnt in proposal msg are from the
remote client and can not be fully trusted. Especially the
field iparea_offset, once exceed the max value, there has the
chance to access wrong address, and crash may happen.

This patch checks iparea_offset and ipv6_prefixes_cnt before using them.</description><pubDate>Sat, 11 Jan 2025 12:51:37 +0000</pubDate></item><item><title>CVE-2024-49573 | sched/fair: Fix NEXT_BUDDY</title><link>https://www.cve.org/CVERecord?id=CVE-2024-49573</link><description>In the Linux kernel, the following vulnerability has been resolved:

sched/fair: Fix NEXT_BUDDY

Adam reports that enabling NEXT_BUDDY insta triggers a WARN in
pick_next_entity().

Moving clear_buddies() up before the delayed dequeue bits ensures
no -&gt;next buddy becomes delayed. Further ensure no new -&gt;next buddy
ever starts as delayed.</description><pubDate>Sat, 11 Jan 2025 12:51:37 +0000</pubDate></item><item><title>CVE-2024-51729 | mm: use aligned address in copy_user_gigantic_page()</title><link>https://www.cve.org/CVERecord?id=CVE-2024-51729</link><description>In the Linux kernel, the following vulnerability has been resolved:

mm: use aligned address in copy_user_gigantic_page()

In current kernel, hugetlb_wp() calls copy_user_large_folio() with the
fault address.  Where the fault address may be not aligned with the huge
page size.  Then, copy_user_large_folio() may call
copy_user_gigantic_page() with the address, while
copy_user_gigantic_page() requires the address to be huge page size
aligned.  So, this may cause memory corruption or information leak,
addtional, use more obvious naming 'addr_hint' instead of 'addr' for
copy_user_gigantic_page().</description><pubDate>Sat, 11 Jan 2025 12:51:38 +0000</pubDate></item><item><title>CVE-2024-52319 | mm: use aligned address in clear_gigantic_page()</title><link>https://www.cve.org/CVERecord?id=CVE-2024-52319</link><description>In the Linux kernel, the following vulnerability has been resolved:

mm: use aligned address in clear_gigantic_page()

In current kernel, hugetlb_no_page() calls folio_zero_user() with the
fault address.  Where the fault address may be not aligned with the huge
page size.  Then, folio_zero_user() may call clear_gigantic_page() with
the address, while clear_gigantic_page() requires the address to be huge
page size aligned.  So, this may cause memory corruption or information
leak, addtional, use more obvious naming 'addr_hint' instead of 'addr' for
clear_gigantic_page().</description><pubDate>Sat, 11 Jan 2025 12:51:38 +0000</pubDate></item><item><title>CVE-2024-53682 | regulator: axp20x: AXP717: set ramp_delay</title><link>https://www.cve.org/CVERecord?id=CVE-2024-53682</link><description>In the Linux kernel, the following vulnerability has been resolved:

regulator: axp20x: AXP717: set ramp_delay

AXP717 datasheet says that regulator ramp delay is 15.625 us/step,
which is 10mV in our case.

Add a AXP_DESC_RANGES_DELAY macro and update AXP_DESC_RANGES macro to
expand to AXP_DESC_RANGES_DELAY with ramp_delay = 0

For DCDC4, steps is 100mv

Add a AXP_DESC_DELAY macro and update AXP_DESC macro to
expand to AXP_DESC_DELAY with ramp_delay = 0

This patch fix crashes when using CPU DVFS.</description><pubDate>Sat, 11 Jan 2025 12:51:39 +0000</pubDate></item><item><title>CVE-2024-53685 | ceph: give up on paths longer than PATH_MAX</title><link>https://www.cve.org/CVERecord?id=CVE-2024-53685</link><description>In the Linux kernel, the following vulnerability has been resolved:

ceph: give up on paths longer than PATH_MAX

If the full path to be built by ceph_mdsc_build_path() happens to be
longer than PATH_MAX, then this function will enter an endless (retry)
loop, effectively blocking the whole task.  Most of the machine
becomes unusable, making this a very simple and effective DoS
vulnerability.

I cannot imagine why this retry was ever implemented, but it seems
rather useless and harmful to me.  Let's remove it and fail with
ENAMETOOLONG instead.</description><pubDate>Sat, 11 Jan 2025 12:51:39 +0000</pubDate></item><item><title>CVE-2024-53687 | riscv: Fix IPIs usage in kfence_protect_page()</title><link>https://www.cve.org/CVERecord?id=CVE-2024-53687</link><description>In the Linux kernel, the following vulnerability has been resolved:

riscv: Fix IPIs usage in kfence_protect_page()

flush_tlb_kernel_range() may use IPIs to flush the TLBs of all the
cores, which triggers the following warning when the irqs are disabled:

[    3.455330] WARNING: CPU: 1 PID: 0 at kernel/smp.c:815 smp_call_function_many_cond+0x452/0x520
[    3.456647] Modules linked in:
[    3.457218] CPU: 1 UID: 0 PID: 0 Comm: swapper/1 Not tainted 6.12.0-rc7-00010-g91d3de7240b8 #1
[    3.457416] Hardware name: QEMU QEMU Virtual Machine, BIOS
[    3.457633] epc : smp_call_function_many_cond+0x452/0x520
[    3.457736]  ra : on_each_cpu_cond_mask+0x1e/0x30
[    3.457786] epc : ffffffff800b669a ra : ffffffff800b67c2 sp : ff2000000000bb50
[    3.457824]  gp : ffffffff815212b8 tp : ff6000008014f080 t0 : 000000000000003f
[    3.457859]  t1 : ffffffff815221e0 t2 : 000000000000000f s0 : ff2000000000bc10
[    3.457920]  s1 : 0000000000000040 a0 : ffffffff815221e0 a1 : 0000000000000001
[    3.457953]  a2 : 0000000000010000 a3 : 0000000000000003 a4 : 0000000000000000
[    3.458006]  a5 : 0000000000000000 a6 : ffffffffffffffff a7 : 0000000000000000
[    3.458042]  s2 : ffffffff815223be s3 : 00fffffffffff000 s4 : ff600001ffe38fc0
[    3.458076]  s5 : ff600001ff950d00 s6 : 0000000200000120 s7 : 0000000000000001
[    3.458109]  s8 : 0000000000000001 s9 : ff60000080841ef0 s10: 0000000000000001
[    3.458141]  s11: ffffffff81524812 t3 : 0000000000000001 t4 : ff60000080092bc0
[    3.458172]  t5 : 0000000000000000 t6 : ff200000000236d0
[    3.458203] status: 0000000200000100 badaddr: ffffffff800b669a cause: 0000000000000003
[    3.458373] [] smp_call_function_many_cond+0x452/0x520
[    3.458593] [] on_each_cpu_cond_mask+0x1e/0x30
[    3.458625] [] __flush_tlb_range+0x118/0x1ca
[    3.458656] [] flush_tlb_kernel_range+0x1e/0x26
[    3.458683] [] kfence_protect+0xc0/0xce
[    3.458717] [] kfence_guarded_free+0xc6/0x1c0
[    3.458742] [] __kfence_free+0x62/0xc6
[    3.458764] [] kfree+0x106/0x32c
[    3.458786] [] detach_buf_split+0x188/0x1a8
[    3.458816] [] virtqueue_get_buf_ctx+0xb6/0x1f6
[    3.458839] [] virtqueue_get_buf+0xe/0x16
[    3.458880] [] virtblk_done+0x5c/0xe2
[    3.458908] [] vring_interrupt+0x6a/0x74
[    3.458930] [] __handle_irq_event_percpu+0x7c/0xe2
[    3.458956] [] handle_irq_event+0x3c/0x86
[    3.458978] [] handle_simple_irq+0x9e/0xbe
[    3.459004] [] generic_handle_domain_irq+0x1c/0x2a
[    3.459027] [] imsic_handle_irq+0xba/0x120
[    3.459056] [] generic_handle_domain_irq+0x1c/0x2a
[    3.459080] [] riscv_intc_aia_irq+0x24/0x34
[    3.459103] [] handle_riscv_irq+0x2e/0x4c
[    3.459133] [] call_on_irq_stack+0x32/0x40

So only flush the local TLB and let the lazy kfence page fault handling
deal with the faults which could happen when a core has an old protected
pte version cached in its TLB. That leads to potential inaccuracies which
can be tolerated when using kfence.</description><pubDate>Sat, 11 Jan 2025 12:51:39 +0000</pubDate></item><item><title>CVE-2024-53689 | block: Fix potential deadlock while freezing queue and acquiring sysfs_lock</title><link>https://www.cve.org/CVERecord?id=CVE-2024-53689</link><description>In the Linux kernel, the following vulnerability has been resolved:

block: Fix potential deadlock while freezing queue and acquiring sysfs_lock

For storing a value to a queue attribute, the queue_attr_store function
first freezes the queue (-&gt;q_usage_counter(io)) and then acquire
-&gt;sysfs_lock. This seems not correct as the usual ordering should be to
acquire -&gt;sysfs_lock before freezing the queue. This incorrect ordering
causes the following lockdep splat which we are able to reproduce always
simply by accessing /sys/kernel/debug file using ls command:

[   57.597146] WARNING: possible circular locking dependency detected
[   57.597154] 6.12.0-10553-gb86545e02e8c #20 Tainted: G        W
[   57.597162] ------------------------------------------------------
[   57.597168] ls/4605 is trying to acquire lock:
[   57.597176] c00000003eb56710 (&amp;amp;mm-&gt;mmap_lock){++++}-{4:4}, at: __might_fault+0x58/0xc0
[   57.597200]
               but task is already holding lock:
[   57.597207] c0000018e27c6810 (&amp;amp;sb-&gt;s_type-&gt;i_mutex_key#3){++++}-{4:4}, at: iterate_dir+0x94/0x1d4
[   57.597226]
               which lock already depends on the new lock.

[   57.597233]
               the existing dependency chain (in reverse order) is:
[   57.597241]
               -&gt; #5 (&amp;amp;sb-&gt;s_type-&gt;i_mutex_key#3){++++}-{4:4}:
[   57.597255]        down_write+0x6c/0x18c
[   57.597264]        start_creating+0xb4/0x24c
[   57.597274]        debugfs_create_dir+0x2c/0x1e8
[   57.597283]        blk_register_queue+0xec/0x294
[   57.597292]        add_disk_fwnode+0x2e4/0x548
[   57.597302]        brd_alloc+0x2c8/0x338
[   57.597309]        brd_init+0x100/0x178
[   57.597317]        do_one_initcall+0x88/0x3e4
[   57.597326]        kernel_init_freeable+0x3cc/0x6e0
[   57.597334]        kernel_init+0x34/0x1cc
[   57.597342]        ret_from_kernel_user_thread+0x14/0x1c
[   57.597350]
               -&gt; #4 (&amp;amp;q-&gt;debugfs_mutex){+.+.}-{4:4}:
[   57.597362]        __mutex_lock+0xfc/0x12a0
[   57.597370]        blk_register_queue+0xd4/0x294
[   57.597379]        add_disk_fwnode+0x2e4/0x548
[   57.597388]        brd_alloc+0x2c8/0x338
[   57.597395]        brd_init+0x100/0x178
[   57.597402]        do_one_initcall+0x88/0x3e4
[   57.597410]        kernel_init_freeable+0x3cc/0x6e0
[   57.597418]        kernel_init+0x34/0x1cc
[   57.597426]        ret_from_kernel_user_thread+0x14/0x1c
[   57.597434]
               -&gt; #3 (&amp;amp;q-&gt;sysfs_lock){+.+.}-{4:4}:
[   57.597446]        __mutex_lock+0xfc/0x12a0
[   57.597454]        queue_attr_store+0x9c/0x110
[   57.597462]        sysfs_kf_write+0x70/0xb0
[   57.597471]        kernfs_fop_write_iter+0x1b0/0x2ac
[   57.597480]        vfs_write+0x3dc/0x6e8
[   57.597488]        ksys_write+0x84/0x140
[   57.597495]        system_call_exception+0x130/0x360
[   57.597504]        system_call_common+0x160/0x2c4
[   57.597516]
               -&gt; #2 (&amp;amp;q-&gt;q_usage_counter(io)#21){++++}-{0:0}:
[   57.597530]        __submit_bio+0x5ec/0x828
[   57.597538]        submit_bio_noacct_nocheck+0x1e4/0x4f0
[   57.597547]        iomap_readahead+0x2a0/0x448
[   57.597556]        xfs_vm_readahead+0x28/0x3c
[   57.597564]        read_pages+0x88/0x41c
[   57.597571]        page_cache_ra_unbounded+0x1ac/0x2d8
[   57.597580]        filemap_get_pages+0x188/0x984
[   57.597588]        filemap_read+0x13c/0x4bc
[   57.597596]        xfs_file_buffered_read+0x88/0x17c
[   57.597605]        xfs_file_read_iter+0xac/0x158
[   57.597614]        vfs_read+0x2d4/0x3b4
[   57.597622]        ksys_read+0x84/0x144
[   57.597629]        system_call_exception+0x130/0x360
[   57.597637]        system_call_common+0x160/0x2c4
[   57.597647]
               -&gt; #1 (mapping.invalidate_lock#2){++++}-{4:4}:
[   57.597661]        down_read+0x6c/0x220
[   57.597669]        filemap_fault+0x870/0x100c
[   57.597677]        xfs_filemap_fault+0xc4/0x18c
[   57.597684]        __do_fault+0x64/0x164
[   57.597693]        __handle_mm_fault+0x1274/0x1dac
[   57.597702]        handle_mm_fault+0x248/0x48
---truncated---</description><pubDate>Sat, 11 Jan 2025 12:51:40 +0000</pubDate></item><item><title>CVE-2024-53690 | nilfs2: prevent use of deleted inode</title><link>https://www.cve.org/CVERecord?id=CVE-2024-53690</link><description>In the Linux kernel, the following vulnerability has been resolved:

nilfs2: prevent use of deleted inode

syzbot reported a WARNING in nilfs_rmdir. [1]

Because the inode bitmap is corrupted, an inode with an inode number that
should exist as a ".nilfs" file was reassigned by nilfs_mkdir for "file0",
causing an inode duplication during execution.  And this causes an
underflow of i_nlink in rmdir operations.

The inode is used twice by the same task to unmount and remove directories
".nilfs" and "file0", it trigger warning in nilfs_rmdir.

Avoid to this issue, check i_nlink in nilfs_iget(), if it is 0, it means
that this inode has been deleted, and iput is executed to reclaim it.

[1]
WARNING: CPU: 1 PID: 5824 at fs/inode.c:407 drop_nlink+0xc4/0x110 fs/inode.c:407
...
Call Trace:
 
 nilfs_rmdir+0x1b0/0x250 fs/nilfs2/namei.c:342
 vfs_rmdir+0x3a3/0x510 fs/namei.c:4394
 do_rmdir+0x3b5/0x580 fs/namei.c:4453
 __do_sys_rmdir fs/namei.c:4472 [inline]
 __se_sys_rmdir fs/namei.c:4470 [inline]
 __x64_sys_rmdir+0x47/0x50 fs/namei.c:4470
 do_syscall_x64 arch/x86/entry/common.c:52 [inline]
 do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83
 entry_SYSCALL_64_after_hwframe+0x77/0x7f</description><pubDate>Sat, 11 Jan 2025 12:51:40 +0000</pubDate></item><item><title>CVE-2024-54191 | Bluetooth: iso: Fix circular lock in iso_conn_big_sync</title><link>https://www.cve.org/CVERecord?id=CVE-2024-54191</link><description>In the Linux kernel, the following vulnerability has been resolved:

Bluetooth: iso: Fix circular lock in iso_conn_big_sync

This fixes the circular locking dependency warning below, by reworking
iso_sock_recvmsg, to ensure that the socket lock is always released
before calling a function that locks hdev.

[  561.670344] ======================================================
[  561.670346] WARNING: possible circular locking dependency detected
[  561.670349] 6.12.0-rc6+ #26 Not tainted
[  561.670351] ------------------------------------------------------
[  561.670353] iso-tester/3289 is trying to acquire lock:
[  561.670355] ffff88811f600078 (&amp;amp;hdev-&gt;lock){+.+.}-{3:3},
               at: iso_conn_big_sync+0x73/0x260 [bluetooth]
[  561.670405]
               but task is already holding lock:
[  561.670407] ffff88815af58258 (sk_lock-AF_BLUETOOTH){+.+.}-{0:0},
               at: iso_sock_recvmsg+0xbf/0x500 [bluetooth]
[  561.670450]
               which lock already depends on the new lock.

[  561.670452]
               the existing dependency chain (in reverse order) is:
[  561.670453]
               -&gt; #2 (sk_lock-AF_BLUETOOTH){+.+.}-{0:0}:
[  561.670458]        lock_acquire+0x7c/0xc0
[  561.670463]        lock_sock_nested+0x3b/0xf0
[  561.670467]        bt_accept_dequeue+0x1a5/0x4d0 [bluetooth]
[  561.670510]        iso_sock_accept+0x271/0x830 [bluetooth]
[  561.670547]        do_accept+0x3dd/0x610
[  561.670550]        __sys_accept4+0xd8/0x170
[  561.670553]        __x64_sys_accept+0x74/0xc0
[  561.670556]        x64_sys_call+0x17d6/0x25f0
[  561.670559]        do_syscall_64+0x87/0x150
[  561.670563]        entry_SYSCALL_64_after_hwframe+0x76/0x7e
[  561.670567]
               -&gt; #1 (sk_lock-AF_BLUETOOTH-BTPROTO_ISO){+.+.}-{0:0}:
[  561.670571]        lock_acquire+0x7c/0xc0
[  561.670574]        lock_sock_nested+0x3b/0xf0
[  561.670577]        iso_sock_listen+0x2de/0xf30 [bluetooth]
[  561.670617]        __sys_listen_socket+0xef/0x130
[  561.670620]        __x64_sys_listen+0xe1/0x190
[  561.670623]        x64_sys_call+0x2517/0x25f0
[  561.670626]        do_syscall_64+0x87/0x150
[  561.670629]        entry_SYSCALL_64_after_hwframe+0x76/0x7e
[  561.670632]
               -&gt; #0 (&amp;amp;hdev-&gt;lock){+.+.}-{3:3}:
[  561.670636]        __lock_acquire+0x32ad/0x6ab0
[  561.670639]        lock_acquire.part.0+0x118/0x360
[  561.670642]        lock_acquire+0x7c/0xc0
[  561.670644]        __mutex_lock+0x18d/0x12f0
[  561.670647]        mutex_lock_nested+0x1b/0x30
[  561.670651]        iso_conn_big_sync+0x73/0x260 [bluetooth]
[  561.670687]        iso_sock_recvmsg+0x3e9/0x500 [bluetooth]
[  561.670722]        sock_recvmsg+0x1d5/0x240
[  561.670725]        sock_read_iter+0x27d/0x470
[  561.670727]        vfs_read+0x9a0/0xd30
[  561.670731]        ksys_read+0x1a8/0x250
[  561.670733]        __x64_sys_read+0x72/0xc0
[  561.670736]        x64_sys_call+0x1b12/0x25f0
[  561.670738]        do_syscall_64+0x87/0x150
[  561.670741]        entry_SYSCALL_64_after_hwframe+0x76/0x7e
[  561.670744]
               other info that might help us debug this:

[  561.670745] Chain exists of:
&amp;amp;hdev-&gt;lock --&gt; sk_lock-AF_BLUETOOTH-BTPROTO_ISO --&gt; sk_lock-AF_BLUETOOTH

[  561.670751]  Possible unsafe locking scenario:

[  561.670753]        CPU0                    CPU1
[  561.670754]        ----                    ----
[  561.670756]   lock(sk_lock-AF_BLUETOOTH);
[  561.670758]                                lock(sk_lock
                                              AF_BLUETOOTH-BTPROTO_ISO);
[  561.670761]                                lock(sk_lock-AF_BLUETOOTH);
[  561.670764]   lock(&amp;amp;hdev-&gt;lock);
[  561.670767]
                *** DEADLOCK ***</description><pubDate>Sat, 11 Jan 2025 12:51:41 +0000</pubDate></item><item><title>CVE-2024-54193 | accel/ivpu: Fix WARN in ivpu_ipc_send_receive_internal()</title><link>https://www.cve.org/CVERecord?id=CVE-2024-54193</link><description>In the Linux kernel, the following vulnerability has been resolved:

accel/ivpu: Fix WARN in ivpu_ipc_send_receive_internal()

Move pm_runtime_set_active() to ivpu_pm_init() so when
ivpu_ipc_send_receive_internal() is executed before ivpu_pm_enable()
it already has correct runtime state, even if last resume was
not successful.</description><pubDate>Sat, 11 Jan 2025 12:51:41 +0000</pubDate></item><item><title>CVE-2024-54455 | accel/ivpu: Fix general protection fault in ivpu_bo_list()</title><link>https://www.cve.org/CVERecord?id=CVE-2024-54455</link><description>In the Linux kernel, the following vulnerability has been resolved:

accel/ivpu: Fix general protection fault in ivpu_bo_list()

Check if ctx is not NULL before accessing its fields.</description><pubDate>Sat, 11 Jan 2025 12:51:41 +0000</pubDate></item><item><title>CVE-2024-54460 | Bluetooth: iso: Fix circular lock in iso_listen_bis</title><link>https://www.cve.org/CVERecord?id=CVE-2024-54460</link><description>In the Linux kernel, the following vulnerability has been resolved:

Bluetooth: iso: Fix circular lock in iso_listen_bis

This fixes the circular locking dependency warning below, by
releasing the socket lock before enterning iso_listen_bis, to
avoid any potential deadlock with hdev lock.

[   75.307983] ======================================================
[   75.307984] WARNING: possible circular locking dependency detected
[   75.307985] 6.12.0-rc6+ #22 Not tainted
[   75.307987] ------------------------------------------------------
[   75.307987] kworker/u81:2/2623 is trying to acquire lock:
[   75.307988] ffff8fde1769da58 (sk_lock-AF_BLUETOOTH-BTPROTO_ISO)
               at: iso_connect_cfm+0x253/0x840 [bluetooth]
[   75.308021]
               but task is already holding lock:
[   75.308022] ffff8fdd61a10078 (&amp;amp;hdev-&gt;lock)
               at: hci_le_per_adv_report_evt+0x47/0x2f0 [bluetooth]
[   75.308053]
               which lock already depends on the new lock.

[   75.308054]
               the existing dependency chain (in reverse order) is:
[   75.308055]
               -&gt; #1 (&amp;amp;hdev-&gt;lock){+.+.}-{3:3}:
[   75.308057]        __mutex_lock+0xad/0xc50
[   75.308061]        mutex_lock_nested+0x1b/0x30
[   75.308063]        iso_sock_listen+0x143/0x5c0 [bluetooth]
[   75.308085]        __sys_listen_socket+0x49/0x60
[   75.308088]        __x64_sys_listen+0x4c/0x90
[   75.308090]        x64_sys_call+0x2517/0x25f0
[   75.308092]        do_syscall_64+0x87/0x150
[   75.308095]        entry_SYSCALL_64_after_hwframe+0x76/0x7e
[   75.308098]
               -&gt; #0 (sk_lock-AF_BLUETOOTH-BTPROTO_ISO){+.+.}-{0:0}:
[   75.308100]        __lock_acquire+0x155e/0x25f0
[   75.308103]        lock_acquire+0xc9/0x300
[   75.308105]        lock_sock_nested+0x32/0x90
[   75.308107]        iso_connect_cfm+0x253/0x840 [bluetooth]
[   75.308128]        hci_connect_cfm+0x6c/0x190 [bluetooth]
[   75.308155]        hci_le_per_adv_report_evt+0x27b/0x2f0 [bluetooth]
[   75.308180]        hci_le_meta_evt+0xe7/0x200 [bluetooth]
[   75.308206]        hci_event_packet+0x21f/0x5c0 [bluetooth]
[   75.308230]        hci_rx_work+0x3ae/0xb10 [bluetooth]
[   75.308254]        process_one_work+0x212/0x740
[   75.308256]        worker_thread+0x1bd/0x3a0
[   75.308258]        kthread+0xe4/0x120
[   75.308259]        ret_from_fork+0x44/0x70
[   75.308261]        ret_from_fork_asm+0x1a/0x30
[   75.308263]
               other info that might help us debug this:

[   75.308264]  Possible unsafe locking scenario:

[   75.308264]        CPU0                CPU1
[   75.308265]        ----                ----
[   75.308265]   lock(&amp;amp;hdev-&gt;lock);
[   75.308267]                            lock(sk_lock-
                                                AF_BLUETOOTH-BTPROTO_ISO);
[   75.308268]                            lock(&amp;amp;hdev-&gt;lock);
[   75.308269]   lock(sk_lock-AF_BLUETOOTH-BTPROTO_ISO);
[   75.308270]
                *** DEADLOCK ***

[   75.308271] 4 locks held by kworker/u81:2/2623:
[   75.308272]  #0: ffff8fdd66e52148 ((wq_completion)hci0#2){+.+.}-{0:0},
                at: process_one_work+0x443/0x740
[   75.308276]  #1: ffffafb488b7fe48 ((work_completion)(&amp;amp;hdev-&gt;rx_work)),
                at: process_one_work+0x1ce/0x740
[   75.308280]  #2: ffff8fdd61a10078 (&amp;amp;hdev-&gt;lock){+.+.}-{3:3}
                at: hci_le_per_adv_report_evt+0x47/0x2f0 [bluetooth]
[   75.308304]  #3: ffffffffb6ba4900 (rcu_read_lock){....}-{1:2},
                at: hci_connect_cfm+0x29/0x190 [bluetooth]</description><pubDate>Sat, 11 Jan 2025 12:51:42 +0000</pubDate></item><item><title>CVE-2024-54680 | smb: client: fix TCP timers deadlock after rmmod</title><link>https://www.cve.org/CVERecord?id=CVE-2024-54680</link><description>In the Linux kernel, the following vulnerability has been resolved:

smb: client: fix TCP timers deadlock after rmmod

Commit ef7134c7fc48 ("smb: client: Fix use-after-free of network namespace.")
fixed a netns UAF by manually enabled socket refcounting
(sk-&gt;sk_net_refcnt=1 and sock_inuse_add(net, 1)).

The reason the patch worked for that bug was because we now hold
references to the netns (get_net_track() gets a ref internally)
and they're properly released (internally, on __sk_destruct()),
but only because sk-&gt;sk_net_refcnt was set.

Problem:
(this happens regardless of CONFIG_NET_NS_REFCNT_TRACKER and regardless
if init_net or other)

Setting sk-&gt;sk_net_refcnt=1 *manually* and *after* socket creation is not
only out of cifs scope, but also technically wrong -- it's set conditionally
based on user (=1) vs kernel (=0) sockets.  And net/ implementations
seem to base their user vs kernel space operations on it.

e.g. upon TCP socket close, the TCP timers are not cleared because
sk-&gt;sk_net_refcnt=1:
(cf. commit 151c9c724d05 ("tcp: properly terminate timers for kernel sockets"))

net/ipv4/tcp.c:
    void tcp_close(struct sock *sk, long timeout)
    {
    	lock_sock(sk);
    	__tcp_close(sk, timeout);
    	release_sock(sk);
    	if (!sk-&gt;sk_net_refcnt)
    		inet_csk_clear_xmit_timers_sync(sk);
    	sock_put(sk);
    }

Which will throw a lockdep warning and then, as expected, deadlock on
tcp_write_timer().

A way to reproduce this is by running the reproducer from ef7134c7fc48
and then 'rmmod cifs'.  A few seconds later, the deadlock/lockdep
warning shows up.

Fix:
We shouldn't mess with socket internals ourselves, so do not set
sk_net_refcnt manually.

Also change __sock_create() to sock_create_kern() for explicitness.

As for non-init_net network namespaces, we deal with it the best way
we can -- hold an extra netns reference for server-&gt;ssocket and drop it
when it's released.  This ensures that the netns still exists whenever
we need to create/destroy server-&gt;ssocket, but is not directly tied to
it.</description><pubDate>Sat, 11 Jan 2025 12:51:42 +0000</pubDate></item><item><title>CVE-2024-54683 | netfilter: IDLETIMER: Fix for possible ABBA deadlock</title><link>https://www.cve.org/CVERecord?id=CVE-2024-54683</link><description>In the Linux kernel, the following vulnerability has been resolved:

netfilter: IDLETIMER: Fix for possible ABBA deadlock

Deletion of the last rule referencing a given idletimer may happen at
the same time as a read of its file in sysfs:

| ======================================================
| WARNING: possible circular locking dependency detected
| 6.12.0-rc7-01692-g5e9a28f41134-dirty #594 Not tainted
| ------------------------------------------------------
| iptables/3303 is trying to acquire lock:
| ffff8881057e04b8 (kn-&gt;active#48){++++}-{0:0}, at: __kernfs_remove+0x20
|
| but task is already holding lock:
| ffffffffa0249068 (list_mutex){+.+.}-{3:3}, at: idletimer_tg_destroy_v]
|
| which lock already depends on the new lock.

A simple reproducer is:

| #!/bin/bash
|
| while true; do
|         iptables -A INPUT -i foo -j IDLETIMER --timeout 10 --label "testme"
|         iptables -D INPUT -i foo -j IDLETIMER --timeout 10 --label "testme"
| done &amp;
| while true; do
|         cat /sys/class/xt_idletimer/timers/testme &gt;/dev/null
| done

Avoid this by freeing list_mutex right after deleting the element from
the list, then continuing with the teardown.</description><pubDate>Sat, 11 Jan 2025 12:51:43 +0000</pubDate></item><item><title>CVE-2024-55639 | net: renesas: rswitch: avoid use-after-put for a device tree node</title><link>https://www.cve.org/CVERecord?id=CVE-2024-55639</link><description>In the Linux kernel, the following vulnerability has been resolved:

net: renesas: rswitch: avoid use-after-put for a device tree node

The device tree node saved in the rswitch_device structure is used at
several driver locations. So passing this node to of_node_put() after
the first use is wrong.

Move of_node_put() for this node to exit paths.</description><pubDate>Sat, 11 Jan 2025 12:51:43 +0000</pubDate></item><item><title>CVE-2024-55641 | xfs: unlock inodes when erroring out of xfs_trans_alloc_dir</title><link>https://www.cve.org/CVERecord?id=CVE-2024-55641</link><description>In the Linux kernel, the following vulnerability has been resolved:

xfs: unlock inodes when erroring out of xfs_trans_alloc_dir

Debugging a filesystem patch with generic/475 caused the system to hang
after observing the following sequences in dmesg:

 XFS (dm-0): metadata I/O error in "xfs_imap_to_bp+0x61/0xe0 [xfs]" at daddr 0x491520 len 32 error 5
 XFS (dm-0): metadata I/O error in "xfs_btree_read_buf_block+0xba/0x160 [xfs]" at daddr 0x3445608 len 8 error 5
 XFS (dm-0): metadata I/O error in "xfs_imap_to_bp+0x61/0xe0 [xfs]" at daddr 0x138e1c0 len 32 error 5
 XFS (dm-0): log I/O error -5
 XFS (dm-0): Metadata I/O Error (0x1) detected at xfs_trans_read_buf_map+0x1ea/0x4b0 [xfs] (fs/xfs/xfs_trans_buf.c:311).  Shutting down filesystem.
 XFS (dm-0): Please unmount the filesystem and rectify the problem(s)
 XFS (dm-0): Internal error dqp-&gt;q_ino.reserved &lt; dqp-&gt;q_ino.count at line 869 of file fs/xfs/xfs_trans_dquot.c.  Caller xfs_trans_dqresv+0x236/0x440 [xfs]
 XFS (dm-0): Corruption detected. Unmount and run xfs_repair
 XFS (dm-0): Unmounting Filesystem be6bcbcc-9921-4deb-8d16-7cc94e335fa7

The system is stuck in unmount trying to lock a couple of inodes so that
they can be purged.  The dquot corruption notice above is a clue to what
happened -- a link() call tried to set up a transaction to link a child
into a directory.  Quota reservation for the transaction failed after IO
errors shut down the filesystem, but then we forgot to unlock the inodes
on our way out.  Fix that.</description><pubDate>Sat, 11 Jan 2025 12:51:43 +0000</pubDate></item><item><title>CVE-2024-55642 | block: Prevent potential deadlocks in zone write plug error recovery</title><link>https://www.cve.org/CVERecord?id=CVE-2024-55642</link><description>In the Linux kernel, the following vulnerability has been resolved:

block: Prevent potential deadlocks in zone write plug error recovery

Zone write plugging for handling writes to zones of a zoned block
device always execute a zone report whenever a write BIO to a zone
fails. The intent of this is to ensure that the tracking of a zone write
pointer is always correct to ensure that the alignment to a zone write
pointer of write BIOs can be checked on submission and that we can
always correctly emulate zone append operations using regular write
BIOs.

However, this error recovery scheme introduces a potential deadlock if a
device queue freeze is initiated while BIOs are still plugged in a zone
write plug and one of these write operation fails. In such case, the
disk zone write plug error recovery work is scheduled and executes a
report zone. This in turn can result in a request allocation in the
underlying driver to issue the report zones command to the device. But
with the device queue freeze already started, this allocation will
block, preventing the report zone execution and the continuation of the
processing of the plugged BIOs. As plugged BIOs hold a queue usage
reference, the queue freeze itself will never complete, resulting in a
deadlock.

Avoid this problem by completely removing from the zone write plugging
code the use of report zones operations after a failed write operation,
instead relying on the device user to either execute a report zones,
reset the zone, finish the zone, or give up writing to the device (which
is a fairly common pattern for file systems which degrade to read-only
after write failures). This is not an unreasonnable requirement as all
well-behaved applications, FSes and device mapper already use report
zones to recover from write errors whenever possible by comparing the
current position of a zone write pointer with what their assumption
about the position is.

The changes to remove the automatic error recovery are as follows:
 - Completely remove the error recovery work and its associated
   resources (zone write plug list head, disk error list, and disk
   zone_wplugs_work work struct). This also removes the functions
   disk_zone_wplug_set_error() and disk_zone_wplug_clear_error().

 - Change the BLK_ZONE_WPLUG_ERROR zone write plug flag into
   BLK_ZONE_WPLUG_NEED_WP_UPDATE. This new flag is set for a zone write
   plug whenever a write opration targetting the zone of the zone write
   plug fails. This flag indicates that the zone write pointer offset is
   not reliable and that it must be updated when the next report zone,
   reset zone, finish zone or disk revalidation is executed.

 - Modify blk_zone_write_plug_bio_endio() to set the
   BLK_ZONE_WPLUG_NEED_WP_UPDATE flag for the target zone of a failed
   write BIO.

 - Modify the function disk_zone_wplug_set_wp_offset() to clear this
   new flag, thus implementing recovery of a correct write pointer
   offset with the reset (all) zone and finish zone operations.

 - Modify blkdev_report_zones() to always use the disk_report_zones_cb()
   callback so that disk_zone_wplug_sync_wp_offset() can be called for
   any zone marked with the BLK_ZONE_WPLUG_NEED_WP_UPDATE flag.
   This implements recovery of a correct write pointer offset for zone
   write plugs marked with BLK_ZONE_WPLUG_NEED_WP_UPDATE and within
   the range of the report zones operation executed by the user.

 - Modify blk_revalidate_seq_zone() to call
   disk_zone_wplug_sync_wp_offset() for all sequential write required
   zones when a zoned block device is revalidated, thus always resolving
   any inconsistency between the write pointer offset of zone write
   plugs and the actual write pointer position of sequential zones.</description><pubDate>Sat, 11 Jan 2025 12:51:44 +0000</pubDate></item><item><title>CVE-2024-55881 | KVM: x86: Play nice with protected guests in complete_hypercall_exit()</title><link>https://www.cve.org/CVERecord?id=CVE-2024-55881</link><description>In the Linux kernel, the following vulnerability has been resolved:

KVM: x86: Play nice with protected guests in complete_hypercall_exit()

Use is_64_bit_hypercall() instead of is_64_bit_mode() to detect a 64-bit
hypercall when completing said hypercall.  For guests with protected state,
e.g. SEV-ES and SEV-SNP, KVM must assume the hypercall was made in 64-bit
mode as the vCPU state needed to detect 64-bit mode is unavailable.

Hacking the sev_smoke_test selftest to generate a KVM_HC_MAP_GPA_RANGE
hypercall via VMGEXIT trips the WARN:

  ------------[ cut here ]------------
  WARNING: CPU: 273 PID: 326626 at arch/x86/kvm/x86.h:180 complete_hypercall_exit+0x44/0xe0 [kvm]
  Modules linked in: kvm_amd kvm ... [last unloaded: kvm]
  CPU: 273 UID: 0 PID: 326626 Comm: sev_smoke_test Not tainted 6.12.0-smp--392e932fa0f3-feat #470
  Hardware name: Google Astoria/astoria, BIOS 0.20240617.0-0 06/17/2024
  RIP: 0010:complete_hypercall_exit+0x44/0xe0 [kvm]
  Call Trace:
   
   kvm_arch_vcpu_ioctl_run+0x2400/0x2720 [kvm]
   kvm_vcpu_ioctl+0x54f/0x630 [kvm]
   __se_sys_ioctl+0x6b/0xc0
   do_syscall_64+0x83/0x160
   entry_SYSCALL_64_after_hwframe+0x76/0x7e
   
  ---[ end trace 0000000000000000 ]---</description><pubDate>Sat, 11 Jan 2025 12:51:44 +0000</pubDate></item><item><title>CVE-2024-55916 | Drivers: hv: util: Avoid accessing a ringbuffer not initialized yet</title><link>https://www.cve.org/CVERecord?id=CVE-2024-55916</link><description>In the Linux kernel, the following vulnerability has been resolved:

Drivers: hv: util: Avoid accessing a ringbuffer not initialized yet

If the KVP (or VSS) daemon starts before the VMBus channel's ringbuffer is
fully initialized, we can hit the panic below:

hv_utils: Registering HyperV Utility Driver
hv_vmbus: registering driver hv_utils
...
BUG: kernel NULL pointer dereference, address: 0000000000000000
CPU: 44 UID: 0 PID: 2552 Comm: hv_kvp_daemon Tainted: G E 6.11.0-rc3+ #1
RIP: 0010:hv_pkt_iter_first+0x12/0xd0
Call Trace:
...
 vmbus_recvpacket
 hv_kvp_onchannelcallback
 vmbus_on_event
 tasklet_action_common
 tasklet_action
 handle_softirqs
 irq_exit_rcu
 sysvec_hyperv_stimer0
 
 
 asm_sysvec_hyperv_stimer0
...
 kvp_register_done
 hvt_op_read
 vfs_read
 ksys_read
 __x64_sys_read

This can happen because the KVP/VSS channel callback can be invoked
even before the channel is fully opened:
1) as soon as hv_kvp_init() -&gt; hvutil_transport_init() creates
/dev/vmbus/hv_kvp, the kvp daemon can open the device file immediately and
register itself to the driver by writing a message KVP_OP_REGISTER1 to the
file (which is handled by kvp_on_msg() -&gt;kvp_handle_handshake()) and
reading the file for the driver's response, which is handled by
hvt_op_read(), which calls hvt-&gt;on_read(), i.e. kvp_register_done().

2) the problem with kvp_register_done() is that it can cause the
channel callback to be called even before the channel is fully opened,
and when the channel callback is starting to run, util_probe()-&gt;
vmbus_open() may have not initialized the ringbuffer yet, so the
callback can hit the panic of NULL pointer dereference.

To reproduce the panic consistently, we can add a "ssleep(10)" for KVP in
__vmbus_open(), just before the first hv_ringbuffer_init(), and then we
unload and reload the driver hv_utils, and run the daemon manually within
the 10 seconds.

Fix the panic by reordering the steps in util_probe() so the char dev
entry used by the KVP or VSS daemon is not created until after
vmbus_open() has completed. This reordering prevents the race condition
from happening.</description><pubDate>Sat, 11 Jan 2025 12:51:44 +0000</pubDate></item><item><title>CVE-2024-56368 | ring-buffer: Fix overflow in __rb_map_vma</title><link>https://www.cve.org/CVERecord?id=CVE-2024-56368</link><description>In the Linux kernel, the following vulnerability has been resolved:

ring-buffer: Fix overflow in __rb_map_vma

An overflow occurred when performing the following calculation:

   nr_pages = ((nr_subbufs + 1) &lt;&lt; subbuf_order) - pgoff;

Add a check before the calculation to avoid this problem.

syzbot reported this as a slab-out-of-bounds in __rb_map_vma:

BUG: KASAN: slab-out-of-bounds in __rb_map_vma+0x9ab/0xae0 kernel/trace/ring_buffer.c:7058
Read of size 8 at addr ffff8880767dd2b8 by task syz-executor187/5836

CPU: 0 UID: 0 PID: 5836 Comm: syz-executor187 Not tainted 6.13.0-rc2-syzkaller-00159-gf932fb9b4074 #0
Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 11/25/2024
Call Trace:
 
 __dump_stack lib/dump_stack.c:94 [inline]
 dump_stack_lvl+0x116/0x1f0 lib/dump_stack.c:120
 print_address_description mm/kasan/report.c:378 [inline]
 print_report+0xc3/0x620 mm/kasan/report.c:489
 kasan_report+0xd9/0x110 mm/kasan/report.c:602
 __rb_map_vma+0x9ab/0xae0 kernel/trace/ring_buffer.c:7058
 ring_buffer_map+0x56e/0x9b0 kernel/trace/ring_buffer.c:7138
 tracing_buffers_mmap+0xa6/0x120 kernel/trace/trace.c:8482
 call_mmap include/linux/fs.h:2183 [inline]
 mmap_file mm/internal.h:124 [inline]
 __mmap_new_file_vma mm/vma.c:2291 [inline]
 __mmap_new_vma mm/vma.c:2355 [inline]
 __mmap_region+0x1786/0x2670 mm/vma.c:2456
 mmap_region+0x127/0x320 mm/mmap.c:1348
 do_mmap+0xc00/0xfc0 mm/mmap.c:496
 vm_mmap_pgoff+0x1ba/0x360 mm/util.c:580
 ksys_mmap_pgoff+0x32c/0x5c0 mm/mmap.c:542
 __do_sys_mmap arch/x86/kernel/sys_x86_64.c:89 [inline]
 __se_sys_mmap arch/x86/kernel/sys_x86_64.c:82 [inline]
 __x64_sys_mmap+0x125/0x190 arch/x86/kernel/sys_x86_64.c:82
 do_syscall_x64 arch/x86/entry/common.c:52 [inline]
 do_syscall_64+0xcd/0x250 arch/x86/entry/common.c:83
 entry_SYSCALL_64_after_hwframe+0x77/0x7f

The reproducer for this bug is:

------------------------8&lt;-------------------------
 #include 
 #include 
 #include 
 #include types.h&gt;
 #include mman.h&gt;

 int main(int argc, char **argv)
 {
	int page_size = getpagesize();
	int fd;
	void *meta;

	system("echo 1 &gt; /sys/kernel/tracing/buffer_size_kb");
	fd = open("/sys/kernel/tracing/per_cpu/cpu0/trace_pipe_raw", O_RDONLY);

	meta = mmap(NULL, page_size, PROT_READ, MAP_SHARED, fd, page_size * 5);
 }
------------------------&gt;8-------------------------</description><pubDate>Sat, 11 Jan 2025 12:51:45 +0000</pubDate></item><item><title>CVE-2024-56369 | drm/modes: Avoid divide by zero harder in drm_mode_vrefresh()</title><link>https://www.cve.org/CVERecord?id=CVE-2024-56369</link><description>In the Linux kernel, the following vulnerability has been resolved:

drm/modes: Avoid divide by zero harder in drm_mode_vrefresh()

drm_mode_vrefresh() is trying to avoid divide by zero
by checking whether htotal or vtotal are zero. But we may
still end up with a div-by-zero of vtotal*htotal*...</description><pubDate>Sat, 11 Jan 2025 12:51:45 +0000</pubDate></item><item><title>CVE-2024-56372 | net: tun: fix tun_napi_alloc_frags()</title><link>https://www.cve.org/CVERecord?id=CVE-2024-56372</link><description>In the Linux kernel, the following vulnerability has been resolved:

net: tun: fix tun_napi_alloc_frags()

syzbot reported the following crash [1]

Issue came with the blamed commit. Instead of going through
all the iov components, we keep using the first one
and end up with a malformed skb.

[1]

kernel BUG at net/core/skbuff.c:2849 !
Oops: invalid opcode: 0000 [#1] PREEMPT SMP KASAN PTI
CPU: 0 UID: 0 PID: 6230 Comm: syz-executor132 Not tainted 6.13.0-rc1-syzkaller-00407-g96b6fcc0ee41 #0
Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 11/25/2024
 RIP: 0010:__pskb_pull_tail+0x1568/0x1570 net/core/skbuff.c:2848
Code: 38 c1 0f 8c 32 f1 ff ff 4c 89 f7 e8 92 96 74 f8 e9 25 f1 ff ff e8 e8 ae 09 f8 48 8b 5c 24 08 e9 eb fb ff ff e8 d9 ae 09 f8 90 &lt;0f&gt; 0b 66 0f 1f 44 00 00 90 90 90 90 90 90 90 90 90 90 90 90 90 90
RSP: 0018:ffffc90004cbef30 EFLAGS: 00010293
RAX: ffffffff8995c347 RBX: 00000000fffffff2 RCX: ffff88802cf45a00
RDX: 0000000000000000 RSI: 00000000fffffff2 RDI: 0000000000000000
RBP: ffff88807df0c06a R08: ffffffff8995b084 R09: 1ffff1100fbe185c
R10: dffffc0000000000 R11: ffffed100fbe185d R12: ffff888076e85d50
R13: ffff888076e85c80 R14: ffff888076e85cf4 R15: ffff888076e85c80
FS:  00007f0dca6ea6c0(0000) GS:ffff8880b8600000(0000) knlGS:0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 00007f0dca6ead58 CR3: 00000000119da000 CR4: 00000000003526f0
DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
Call Trace:
 
  skb_cow_data+0x2da/0xcb0 net/core/skbuff.c:5284
  tipc_aead_decrypt net/tipc/crypto.c:894 [inline]
  tipc_crypto_rcv+0x402/0x24e0 net/tipc/crypto.c:1844
  tipc_rcv+0x57e/0x12a0 net/tipc/node.c:2109
  tipc_l2_rcv_msg+0x2bd/0x450 net/tipc/bearer.c:668
  __netif_receive_skb_list_ptype net/core/dev.c:5720 [inline]
  __netif_receive_skb_list_core+0x8b7/0x980 net/core/dev.c:5762
  __netif_receive_skb_list net/core/dev.c:5814 [inline]
  netif_receive_skb_list_internal+0xa51/0xe30 net/core/dev.c:5905
  gro_normal_list include/net/gro.h:515 [inline]
  napi_complete_done+0x2b5/0x870 net/core/dev.c:6256
  napi_complete include/linux/netdevice.h:567 [inline]
  tun_get_user+0x2ea0/0x4890 drivers/net/tun.c:1982
  tun_chr_write_iter+0x10d/0x1f0 drivers/net/tun.c:2057
 do_iter_readv_writev+0x600/0x880
  vfs_writev+0x376/0xba0 fs/read_write.c:1050
  do_writev+0x1b6/0x360 fs/read_write.c:1096
  do_syscall_x64 arch/x86/entry/common.c:52 [inline]
  do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83
 entry_SYSCALL_64_after_hwframe+0x77/0x7f</description><pubDate>Sat, 11 Jan 2025 12:51:46 +0000</pubDate></item><item><title>CVE-2024-56788 | net: ethernet: oa_tc6: fix tx skb race condition between reference pointers</title><link>https://www.cve.org/CVERecord?id=CVE-2024-56788</link><description>In the Linux kernel, the following vulnerability has been resolved:

net: ethernet: oa_tc6: fix tx skb race condition between reference pointers

There are two skb pointers to manage tx skb's enqueued from n/w stack.
waiting_tx_skb pointer points to the tx skb which needs to be processed
and ongoing_tx_skb pointer points to the tx skb which is being processed.

SPI thread prepares the tx data chunks from the tx skb pointed by the
ongoing_tx_skb pointer. When the tx skb pointed by the ongoing_tx_skb is
processed, the tx skb pointed by the waiting_tx_skb is assigned to
ongoing_tx_skb and the waiting_tx_skb pointer is assigned with NULL.
Whenever there is a new tx skb from n/w stack, it will be assigned to
waiting_tx_skb pointer if it is NULL. Enqueuing and processing of a tx skb
handled in two different threads.

Consider a scenario where the SPI thread processed an ongoing_tx_skb and
it moves next tx skb from waiting_tx_skb pointer to ongoing_tx_skb pointer
without doing any NULL check. At this time, if the waiting_tx_skb pointer
is NULL then ongoing_tx_skb pointer is also assigned with NULL. After
that, if a new tx skb is assigned to waiting_tx_skb pointer by the n/w
stack and there is a chance to overwrite the tx skb pointer with NULL in
the SPI thread. Finally one of the tx skb will be left as unhandled,
resulting packet missing and memory leak.

- Consider the below scenario where the TXC reported from the previous
transfer is 10 and ongoing_tx_skb holds an tx ethernet frame which can be
transported in 20 TXCs and waiting_tx_skb is still NULL.
	tx_credits = 10; /* 21 are filled in the previous transfer */
	ongoing_tx_skb = 20;
	waiting_tx_skb = NULL; /* Still NULL */
- So, (tc6-&gt;ongoing_tx_skb || tc6-&gt;waiting_tx_skb) becomes true.
- After oa_tc6_prepare_spi_tx_buf_for_tx_skbs()
	ongoing_tx_skb = 10;
	waiting_tx_skb = NULL; /* Still NULL */
- Perform SPI transfer.
- Process SPI rx buffer to get the TXC from footers.
- Now let's assume previously filled 21 TXCs are freed so we are good to
transport the next remaining 10 tx chunks from ongoing_tx_skb.
	tx_credits = 21;
	ongoing_tx_skb = 10;
	waiting_tx_skb = NULL;
- So, (tc6-&gt;ongoing_tx_skb || tc6-&gt;waiting_tx_skb) becomes true again.
- In the oa_tc6_prepare_spi_tx_buf_for_tx_skbs()
	ongoing_tx_skb = NULL;
	waiting_tx_skb = NULL;

- Now the below bad case might happen,

Thread1 (oa_tc6_start_xmit)	Thread2 (oa_tc6_spi_thread_handler)
---------------------------	-----------------------------------
- if waiting_tx_skb is NULL
				- if ongoing_tx_skb is NULL
				- ongoing_tx_skb = waiting_tx_skb
- waiting_tx_skb = skb
				- waiting_tx_skb = NULL
				...
				- ongoing_tx_skb = NULL
- if waiting_tx_skb is NULL
- waiting_tx_skb = skb

To overcome the above issue, protect the moving of tx skb reference from
waiting_tx_skb pointer to ongoing_tx_skb pointer and assigning new tx skb
to waiting_tx_skb pointer, so that the other thread can't access the
waiting_tx_skb pointer until the current thread completes moving the tx
skb reference safely.</description><pubDate>Sat, 11 Jan 2025 12:51:46 +0000</pubDate></item><item><title>CVE-2024-57791 | net/smc: check return value of sock_recvmsg when draining clc data</title><link>https://www.cve.org/CVERecord?id=CVE-2024-57791</link><description>In the Linux kernel, the following vulnerability has been resolved:

net/smc: check return value of sock_recvmsg when draining clc data

When receiving clc msg, the field length in smc_clc_msg_hdr indicates the
length of msg should be received from network and the value should not be
fully trusted as it is from the network. Once the value of length exceeds
the value of buflen in function smc_clc_wait_msg it may run into deadloop
when trying to drain the remaining data exceeding buflen.

This patch checks the return value of sock_recvmsg when draining data in
case of deadloop in draining.</description><pubDate>Sat, 11 Jan 2025 12:51:46 +0000</pubDate></item><item><title>CVE-2024-57792 | power: supply: gpio-charger: Fix set charge current limits</title><link>https://www.cve.org/CVERecord?id=CVE-2024-57792</link><description>In the Linux kernel, the following vulnerability has been resolved:

power: supply: gpio-charger: Fix set charge current limits

Fix set charge current limits for devices which allow to set the lowest
charge current limit to be greater zero. If requested charge current limit
is below lowest limit, the index equals current_limit_map_size which leads
to accessing memory beyond allocated memory.</description><pubDate>Sat, 11 Jan 2025 12:51:47 +0000</pubDate></item><item><title>CVE-2024-57793 | virt: tdx-guest: Just leak decrypted memory on unrecoverable errors</title><link>https://www.cve.org/CVERecord?id=CVE-2024-57793</link><description>In the Linux kernel, the following vulnerability has been resolved:

virt: tdx-guest: Just leak decrypted memory on unrecoverable errors

In CoCo VMs it is possible for the untrusted host to cause
set_memory_decrypted() to fail such that an error is returned
and the resulting memory is shared. Callers need to take care
to handle these errors to avoid returning decrypted (shared)
memory to the page allocator, which could lead to functional
or security issues.

Leak the decrypted memory when set_memory_decrypted() fails,
and don't need to print an error since set_memory_decrypted()
will call WARN_ONCE().</description><pubDate>Sat, 11 Jan 2025 12:51:47 +0000</pubDate></item><item><title>CVE-2024-57798 | drm/dp_mst: Ensure mst_primary pointer is valid in drm_dp_mst_handle_up_req()</title><link>https://www.cve.org/CVERecord?id=CVE-2024-57798</link><description>In the Linux kernel, the following vulnerability has been resolved:

drm/dp_mst: Ensure mst_primary pointer is valid in drm_dp_mst_handle_up_req()

While receiving an MST up request message from one thread in
drm_dp_mst_handle_up_req(), the MST topology could be removed from
another thread via drm_dp_mst_topology_mgr_set_mst(false), freeing
mst_primary and setting drm_dp_mst_topology_mgr::mst_primary to NULL.
This could lead to a NULL deref/use-after-free of mst_primary in
drm_dp_mst_handle_up_req().

Avoid the above by holding a reference for mst_primary in
drm_dp_mst_handle_up_req() while it's used.

v2: Fix kfreeing the request if getting an mst_primary reference fails.</description><pubDate>Sat, 11 Jan 2025 12:51:47 +0000</pubDate></item><item><title>CVE-2024-57799 | phy: rockchip: samsung-hdptx: Set drvdata before enabling runtime PM</title><link>https://www.cve.org/CVERecord?id=CVE-2024-57799</link><description>In the Linux kernel, the following vulnerability has been resolved:

phy: rockchip: samsung-hdptx: Set drvdata before enabling runtime PM

In some cases, rk_hdptx_phy_runtime_resume() may be invoked before
platform_set_drvdata() is executed in -&gt;probe(), leading to a NULL
pointer dereference when using the return of dev_get_drvdata().

Ensure platform_set_drvdata() is called before devm_pm_runtime_enable().</description><pubDate>Sat, 11 Jan 2025 12:51:48 +0000</pubDate></item><item><title>CVE-2024-57800 | ALSA: memalloc: prefer dma_mapping_error() over explicit address checking</title><link>https://www.cve.org/CVERecord?id=CVE-2024-57800</link><description>In the Linux kernel, the following vulnerability has been resolved:

ALSA: memalloc: prefer dma_mapping_error() over explicit address checking

With CONFIG_DMA_API_DEBUG enabled, the following warning is observed:

DMA-API: snd_hda_intel 0000:03:00.1: device driver failed to check map error[device address=0x00000000ffff0000] [size=20480 bytes] [mapped as single]
WARNING: CPU: 28 PID: 2255 at kernel/dma/debug.c:1036 check_unmap+0x1408/0x2430
CPU: 28 UID: 42 PID: 2255 Comm: wireplumber Tainted: G  W L  6.12.0-10-133577cad6bf48e5a7848c4338124081393bfe8a+ #759
debug_dma_unmap_page+0xe9/0xf0
snd_dma_wc_free+0x85/0x130 [snd_pcm]
snd_pcm_lib_free_pages+0x1e3/0x440 [snd_pcm]
snd_pcm_common_ioctl+0x1c9a/0x2960 [snd_pcm]
snd_pcm_ioctl+0x6a/0xc0 [snd_pcm]
...

Check for returned DMA addresses using specialized dma_mapping_error()
helper which is generally recommended for this purpose by
Documentation/core-api/dma-api.rst.</description><pubDate>Sat, 11 Jan 2025 12:51:48 +0000</pubDate></item><item><title>CVE-2024-57804 | scsi: mpi3mr: Fix corrupt config pages PHY state is switched in sysfs</title><link>https://www.cve.org/CVERecord?id=CVE-2024-57804</link><description>In the Linux kernel, the following vulnerability has been resolved:

scsi: mpi3mr: Fix corrupt config pages PHY state is switched in sysfs

The driver, through the SAS transport, exposes a sysfs interface to
enable/disable PHYs in a controller/expander setup.  When multiple PHYs
are disabled and enabled in rapid succession, the persistent and current
config pages related to SAS IO unit/SAS Expander pages could get
corrupted.

Use separate memory for each config request.</description><pubDate>Sat, 11 Jan 2025 12:51:48 +0000</pubDate></item><item><title>CVE-2024-57805 | ASoC: SOF: Intel: hda-dai: Do not release the link DMA on STOP</title><link>https://www.cve.org/CVERecord?id=CVE-2024-57805</link><description>In the Linux kernel, the following vulnerability has been resolved:

ASoC: SOF: Intel: hda-dai: Do not release the link DMA on STOP

The linkDMA should not be released on stop trigger since a stream re-start
might happen without closing of the stream. This leaves a short time for
other streams to 'steal' the linkDMA since it has been released.

This issue is not easy to reproduce under normal conditions as usually
after stop the stream is closed, or the same stream is restarted, but if
another stream got in between the stop and start, like this:
aplay -Dhw:0,3 -c2 -r48000 -fS32_LE /dev/zero -d 120
CTRL+z
aplay -Dhw:0,0 -c2 -r48000 -fS32_LE /dev/zero -d 120

then the link DMA channels will be mixed up, resulting firmware error or
crash.</description><pubDate>Sat, 11 Jan 2025 12:51:49 +0000</pubDate></item><item><title>CVE-2024-57806 | btrfs: fix transaction atomicity bug when enabling simple quotas</title><link>https://www.cve.org/CVERecord?id=CVE-2024-57806</link><description>In the Linux kernel, the following vulnerability has been resolved:

btrfs: fix transaction atomicity bug when enabling simple quotas

Set squota incompat bit before committing the transaction that enables
the feature.

With the config CONFIG_BTRFS_ASSERT enabled, an assertion
failure occurs regarding the simple quota feature.

  [5.596534] assertion failed: btrfs_fs_incompat(fs_info, SIMPLE_QUOTA), in fs/btrfs/qgroup.c:365
  [5.597098] ------------[ cut here ]------------
  [5.597371] kernel BUG at fs/btrfs/qgroup.c:365!
  [5.597946] CPU: 1 UID: 0 PID: 268 Comm: mount Not tainted 6.13.0-rc2-00031-gf92f4749861b #146
  [5.598450] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.2-debian-1.16.2-1 04/01/2014
  [5.599008] RIP: 0010:btrfs_read_qgroup_config+0x74d/0x7a0
  [5.604303]  
  [5.605230]  ? btrfs_read_qgroup_config+0x74d/0x7a0
  [5.605538]  ? exc_invalid_op+0x56/0x70
  [5.605775]  ? btrfs_read_qgroup_config+0x74d/0x7a0
  [5.606066]  ? asm_exc_invalid_op+0x1f/0x30
  [5.606441]  ? btrfs_read_qgroup_config+0x74d/0x7a0
  [5.606741]  ? btrfs_read_qgroup_config+0x74d/0x7a0
  [5.607038]  ? try_to_wake_up+0x317/0x760
  [5.607286]  open_ctree+0xd9c/0x1710
  [5.607509]  btrfs_get_tree+0x58a/0x7e0
  [5.608002]  vfs_get_tree+0x2e/0x100
  [5.608224]  fc_mount+0x16/0x60
  [5.608420]  btrfs_get_tree+0x2f8/0x7e0
  [5.608897]  vfs_get_tree+0x2e/0x100
  [5.609121]  path_mount+0x4c8/0xbc0
  [5.609538]  __x64_sys_mount+0x10d/0x150

The issue can be easily reproduced using the following reproducer:

  root@q:linux# cat repro.sh
  set -e

  mkfs.btrfs -q -f /dev/sdb
  mount /dev/sdb /mnt/btrfs
  btrfs quota enable -s /mnt/btrfs
  umount /mnt/btrfs
  mount /dev/sdb /mnt/btrfs

The issue is that when enabling quotas, at btrfs_quota_enable(), we set
BTRFS_QGROUP_STATUS_FLAG_SIMPLE_MODE at fs_info-&gt;qgroup_flags and persist
it in the quota root in the item with the key BTRFS_QGROUP_STATUS_KEY, but
we only set the incompat bit BTRFS_FEATURE_INCOMPAT_SIMPLE_QUOTA after we
commit the transaction used to enable simple quotas.

This means that if after that transaction commit we unmount the filesystem
without starting and committing any other transaction, or we have a power
failure, the next time we mount the filesystem we will find the flag
BTRFS_QGROUP_STATUS_FLAG_SIMPLE_MODE set in the item with the key
BTRFS_QGROUP_STATUS_KEY but we will not find the incompat bit
BTRFS_FEATURE_INCOMPAT_SIMPLE_QUOTA set in the superblock, triggering an
assertion failure at:

  btrfs_read_qgroup_config() -&gt; qgroup_read_enable_gen()

To fix this issue, set the BTRFS_FEATURE_INCOMPAT_SIMPLE_QUOTA flag
immediately after setting the BTRFS_QGROUP_STATUS_FLAG_SIMPLE_MODE.
This ensures that both flags are flushed to disk within the same
transaction.</description><pubDate>Sat, 11 Jan 2025 12:51:49 +0000</pubDate></item><item><title>CVE-2024-57807 | scsi: megaraid_sas: Fix for a potential deadlock</title><link>https://www.cve.org/CVERecord?id=CVE-2024-57807</link><description>In the Linux kernel, the following vulnerability has been resolved:

scsi: megaraid_sas: Fix for a potential deadlock

This fixes a 'possible circular locking dependency detected' warning
      CPU0                    CPU1
      ----                    ----
 lock(&amp;amp;instance-&gt;reset_mutex);
                              lock(&amp;amp;shost-&gt;scan_mutex);
                              lock(&amp;amp;instance-&gt;reset_mutex);
 lock(&amp;amp;shost-&gt;scan_mutex);

Fix this by temporarily releasing the reset_mutex.</description><pubDate>Sat, 11 Jan 2025 12:51:49 +0000</pubDate></item><item><title>CVE-2024-41932 | sched: fix warning in sched_setaffinity</title><link>https://www.cve.org/CVERecord?id=CVE-2024-41932</link><description>In the Linux kernel, the following vulnerability has been resolved:

sched: fix warning in sched_setaffinity

Commit 8f9ea86fdf99b added some logic to sched_setaffinity that included
a WARN when a per-task affinity assignment races with a cpuset update.

Specifically, we can have a race where a cpuset update results in the
task affinity no longer being a subset of the cpuset. That's fine; we
have a fallback to instead use the cpuset mask. However, we have a WARN
set up that will trigger if the cpuset mask has no overlap at all with
the requested task affinity. This shouldn't be a warning condition; its
trivial to create this condition.

Reproduced the warning by the following setup:

- $PID inside a cpuset cgroup
- another thread repeatedly switching the cpuset cpus from 1-2 to just 1
- another thread repeatedly setting the $PID affinity (via taskset) to 2</description><pubDate>Sat, 11 Jan 2025 12:51:50 +0000</pubDate></item><item><title>CVE-2024-41935 | f2fs: fix to shrink read extent node in batches</title><link>https://www.cve.org/CVERecord?id=CVE-2024-41935</link><description>In the Linux kernel, the following vulnerability has been resolved:

f2fs: fix to shrink read extent node in batches

We use rwlock to protect core structure data of extent tree during
its shrink, however, if there is a huge number of extent nodes in
extent tree, during shrink of extent tree, it may hold rwlock for
a very long time, which may trigger kernel hang issue.

This patch fixes to shrink read extent node in batches, so that,
critical region of the rwlock can be shrunk to avoid its extreme
long time hold.</description><pubDate>Sat, 11 Jan 2025 12:51:51 +0000</pubDate></item><item><title>CVE-2024-43098 | i3c: Use i3cdev-&amp;gt;desc-&amp;gt;info instead of calling i3c_device_get_info() to avoid deadlock</title><link>https://www.cve.org/CVERecord?id=CVE-2024-43098</link><description>In the Linux kernel, the following vulnerability has been resolved:

i3c: Use i3cdev-&gt;desc-&gt;info instead of calling i3c_device_get_info() to avoid deadlock

A deadlock may happen since the i3c_master_register() acquires
&amp;amp;i3cbus-&gt;lock twice. See the log below.
Use i3cdev-&gt;desc-&gt;info instead of calling i3c_device_info() to
avoid acquiring the lock twice.

v2:
  - Modified the title and commit message

============================================
WARNING: possible recursive locking detected
6.11.0-mainline
--------------------------------------------
init/1 is trying to acquire lock:
f1ffff80a6a40dc0 (&amp;amp;i3cbus-&gt;lock){++++}-{3:3}, at: i3c_bus_normaluse_lock

but task is already holding lock:
f1ffff80a6a40dc0 (&amp;amp;i3cbus-&gt;lock){++++}-{3:3}, at: i3c_master_register

other info that might help us debug this:
 Possible unsafe locking scenario:

       CPU0
       ----
  lock(&amp;amp;i3cbus-&gt;lock);
  lock(&amp;amp;i3cbus-&gt;lock);

 *** DEADLOCK ***

 May be due to missing lock nesting notation

2 locks held by init/1:
 #0: fcffff809b6798f8 (&amp;amp;dev-&gt;mutex){....}-{3:3}, at: __driver_attach
 #1: f1ffff80a6a40dc0 (&amp;amp;i3cbus-&gt;lock){++++}-{3:3}, at: i3c_master_register

stack backtrace:
CPU: 6 UID: 0 PID: 1 Comm: init
Call trace:
 dump_backtrace+0xfc/0x17c
 show_stack+0x18/0x28
 dump_stack_lvl+0x40/0xc0
 dump_stack+0x18/0x24
 print_deadlock_bug+0x388/0x390
 __lock_acquire+0x18bc/0x32ec
 lock_acquire+0x134/0x2b0
 down_read+0x50/0x19c
 i3c_bus_normaluse_lock+0x14/0x24
 i3c_device_get_info+0x24/0x58
 i3c_device_uevent+0x34/0xa4
 dev_uevent+0x310/0x384
 kobject_uevent_env+0x244/0x414
 kobject_uevent+0x14/0x20
 device_add+0x278/0x460
 device_register+0x20/0x34
 i3c_master_register_new_i3c_devs+0x78/0x154
 i3c_master_register+0x6a0/0x6d4
 mtk_i3c_master_probe+0x3b8/0x4d8
 platform_probe+0xa0/0xe0
 really_probe+0x114/0x454
 __driver_probe_device+0xa0/0x15c
 driver_probe_device+0x3c/0x1ac
 __driver_attach+0xc4/0x1f0
 bus_for_each_dev+0x104/0x160
 driver_attach+0x24/0x34
 bus_add_driver+0x14c/0x294
 driver_register+0x68/0x104
 __platform_driver_register+0x20/0x30
 init_module+0x20/0xfe4
 do_one_initcall+0x184/0x464
 do_init_module+0x58/0x1ec
 load_module+0xefc/0x10c8
 __arm64_sys_finit_module+0x238/0x33c
 invoke_syscall+0x58/0x10c
 el0_svc_common+0xa8/0xdc
 do_el0_svc+0x1c/0x28
 el0_svc+0x50/0xac
 el0t_64_sync_handler+0x70/0xbc
 el0t_64_sync+0x1a8/0x1ac</description><pubDate>Sat, 11 Jan 2025 12:51:51 +0000</pubDate></item><item><title>CVE-2024-45828 | i3c: mipi-i3c-hci: Mask ring interrupts before ring stop request</title><link>https://www.cve.org/CVERecord?id=CVE-2024-45828</link><description>In the Linux kernel, the following vulnerability has been resolved:

i3c: mipi-i3c-hci: Mask ring interrupts before ring stop request

Bus cleanup path in DMA mode may trigger a RING_OP_STAT interrupt when
the ring is being stopped. Depending on timing between ring stop request
completion, interrupt handler removal and code execution this may lead
to a NULL pointer dereference in hci_dma_irq_handler() if it gets to run
after the io_data pointer is set to NULL in hci_dma_cleanup().

Prevent this my masking the ring interrupts before ring stop request.</description><pubDate>Sat, 11 Jan 2025 12:51:51 +0000</pubDate></item><item><title>CVE-2024-47141 | pinmux: Use sequential access to access desc-&amp;gt;pinmux data</title><link>https://www.cve.org/CVERecord?id=CVE-2024-47141</link><description>In the Linux kernel, the following vulnerability has been resolved:

pinmux: Use sequential access to access desc-&gt;pinmux data

When two client of the same gpio call pinctrl_select_state() for the
same functionality, we are seeing NULL pointer issue while accessing
desc-&gt;mux_owner.

Let's say two processes A, B executing in pin_request() for the same pin
and process A updates the desc-&gt;mux_usecount but not yet updated the
desc-&gt;mux_owner while process B see the desc-&gt;mux_usecount which got
updated by A path and further executes strcmp and while accessing
desc-&gt;mux_owner it crashes with NULL pointer.

Serialize the access to mux related setting with a mutex lock.

	cpu0 (process A)			cpu1(process B)

pinctrl_select_state() {		  pinctrl_select_state() {
  pin_request() {				pin_request() {
  ...
						 ....
    } else {
         desc-&gt;mux_usecount++;
    						desc-&gt;mux_usecount &amp;&amp; strcmp(desc-&gt;mux_owner, owner)) {

         if (desc-&gt;mux_usecount &gt; 1)
               return 0;
         desc-&gt;mux_owner = owner;

  }						}</description><pubDate>Sat, 11 Jan 2025 12:51:52 +0000</pubDate></item><item><title>CVE-2024-47143 | dma-debug: fix a possible deadlock on radix_lock</title><link>https://www.cve.org/CVERecord?id=CVE-2024-47143</link><description>In the Linux kernel, the following vulnerability has been resolved:

dma-debug: fix a possible deadlock on radix_lock

radix_lock() shouldn't be held while holding dma_hash_entry[idx].lock
otherwise, there's a possible deadlock scenario when
dma debug API is called holding rq_lock():

CPU0                   CPU1                       CPU2
dma_free_attrs()
check_unmap()          add_dma_entry()            __schedule() //out
                                                  (A) rq_lock()
get_hash_bucket()
(A) dma_entry_hash
                                                  check_sync()
                       (A) radix_lock()           (W) dma_entry_hash
dma_entry_free()
(W) radix_lock()
                       // CPU2's one
                       (W) rq_lock()

CPU1 situation can happen when it extending radix tree and
it tries to wake up kswapd via wake_all_kswapd().

CPU2 situation can happen while perf_event_task_sched_out()
(i.e. dma sync operation is called while deleting perf_event using
 etm and etr tmc which are Arm Coresight hwtracing driver backends).

To remove this possible situation, call dma_entry_free() after
put_hash_bucket() in check_unmap().</description><pubDate>Sat, 11 Jan 2025 12:51:52 +0000</pubDate></item><item><title>CVE-2024-47794 | bpf: Prevent tailcall infinite loop caused by freplace</title><link>https://www.cve.org/CVERecord?id=CVE-2024-47794</link><description>In the Linux kernel, the following vulnerability has been resolved:

bpf: Prevent tailcall infinite loop caused by freplace

There is a potential infinite loop issue that can occur when using a
combination of tail calls and freplace.

In an upcoming selftest, the attach target for entry_freplace of
tailcall_freplace.c is subprog_tc of tc_bpf2bpf.c, while the tail call in
entry_freplace leads to entry_tc. This results in an infinite loop:

entry_tc -&gt; subprog_tc -&gt; entry_freplace --tailcall-&gt; entry_tc.

The problem arises because the tail_call_cnt in entry_freplace resets to
zero each time entry_freplace is executed, causing the tail call mechanism
to never terminate, eventually leading to a kernel panic.

To fix this issue, the solution is twofold:

1. Prevent updating a program extended by an freplace program to a
   prog_array map.
2. Prevent extending a program that is already part of a prog_array map
   with an freplace program.

This ensures that:

* If a program or its subprogram has been extended by an freplace program,
  it can no longer be updated to a prog_array map.
* If a program has been added to a prog_array map, neither it nor its
  subprograms can be extended by an freplace program.

Moreover, an extension program should not be tailcalled. As such, return
-EINVAL if the program has a type of BPF_PROG_TYPE_EXT when adding it to a
prog_array map.

Additionally, fix a minor code style issue by replacing eight spaces with a
tab for proper formatting.</description><pubDate>Sat, 11 Jan 2025 12:51:53 +0000</pubDate></item><item><title>CVE-2024-47809 | dlm: fix possible lkb_resource null dereference</title><link>https://www.cve.org/CVERecord?id=CVE-2024-47809</link><description>In the Linux kernel, the following vulnerability has been resolved:

dlm: fix possible lkb_resource null dereference

This patch fixes a possible null pointer dereference when this function is
called from request_lock() as lkb-&gt;lkb_resource is not assigned yet,
only after validate_lock_args() by calling attach_lkb(). Another issue
is that a resource name could be a non printable bytearray and we cannot
assume to be ASCII coded.

The log functionality is probably never being hit when DLM is used in
normal way and no debug logging is enabled. The null pointer dereference
can only occur on a new created lkb that does not have the resource
assigned yet, it probably never hits the null pointer dereference but we
should be sure that other changes might not change this behaviour and we
actually can hit the mentioned null pointer dereference.

In this patch we just drop the printout of the resource name, the lkb id
is enough to make a possible connection to a resource name if this
exists.</description><pubDate>Sat, 11 Jan 2025 12:51:53 +0000</pubDate></item><item><title>CVE-2024-48873 | wifi: rtw89: check return value of ieee80211_probereq_get() for RNR</title><link>https://www.cve.org/CVERecord?id=CVE-2024-48873</link><description>In the Linux kernel, the following vulnerability has been resolved:

wifi: rtw89: check return value of ieee80211_probereq_get() for RNR

The return value of ieee80211_probereq_get() might be NULL, so check it
before using to avoid NULL pointer access.

Addresses-Coverity-ID: 1529805 ("Dereference null return value")</description><pubDate>Sat, 11 Jan 2025 12:51:54 +0000</pubDate></item><item><title>CVE-2024-48875 | btrfs: don&amp;#x27;t take dev_replace rwsem on task already holding it</title><link>https://www.cve.org/CVERecord?id=CVE-2024-48875</link><description>In the Linux kernel, the following vulnerability has been resolved:

btrfs: don't take dev_replace rwsem on task already holding it

Running fstests btrfs/011 with MKFS_OPTIONS="-O rst" to force the usage of
the RAID stripe-tree, we get the following splat from lockdep:

 BTRFS info (device sdd): dev_replace from /dev/sdd (devid 1) to /dev/sdb started

 ============================================
 WARNING: possible recursive locking detected
 6.11.0-rc3-btrfs-for-next #599 Not tainted
 --------------------------------------------
 btrfs/2326 is trying to acquire lock:
 ffff88810f215c98 (&amp;amp;fs_info-&gt;dev_replace.rwsem){++++}-{3:3}, at: btrfs_map_block+0x39f/0x2250

 but task is already holding lock:
 ffff88810f215c98 (&amp;amp;fs_info-&gt;dev_replace.rwsem){++++}-{3:3}, at: btrfs_map_block+0x39f/0x2250

 other info that might help us debug this:
  Possible unsafe locking scenario:

        CPU0
        ----
   lock(&amp;amp;fs_info-&gt;dev_replace.rwsem);
   lock(&amp;amp;fs_info-&gt;dev_replace.rwsem);

  *** DEADLOCK ***

  May be due to missing lock nesting notation

 1 lock held by btrfs/2326:
  #0: ffff88810f215c98 (&amp;amp;fs_info-&gt;dev_replace.rwsem){++++}-{3:3}, at: btrfs_map_block+0x39f/0x2250

 stack backtrace:
 CPU: 1 UID: 0 PID: 2326 Comm: btrfs Not tainted 6.11.0-rc3-btrfs-for-next #599
 Hardware name: Bochs Bochs, BIOS Bochs 01/01/2011
 Call Trace:
  
  dump_stack_lvl+0x5b/0x80
  __lock_acquire+0x2798/0x69d0
  ? __pfx___lock_acquire+0x10/0x10
  ? __pfx___lock_acquire+0x10/0x10
  lock_acquire+0x19d/0x4a0
  ? btrfs_map_block+0x39f/0x2250
  ? __pfx_lock_acquire+0x10/0x10
  ? find_held_lock+0x2d/0x110
  ? lock_is_held_type+0x8f/0x100
  down_read+0x8e/0x440
  ? btrfs_map_block+0x39f/0x2250
  ? __pfx_down_read+0x10/0x10
  ? do_raw_read_unlock+0x44/0x70
  ? _raw_read_unlock+0x23/0x40
  btrfs_map_block+0x39f/0x2250
  ? btrfs_dev_replace_by_ioctl+0xd69/0x1d00
  ? btrfs_bio_counter_inc_blocked+0xd9/0x2e0
  ? __kasan_slab_alloc+0x6e/0x70
  ? __pfx_btrfs_map_block+0x10/0x10
  ? __pfx_btrfs_bio_counter_inc_blocked+0x10/0x10
  ? kmem_cache_alloc_noprof+0x1f2/0x300
  ? mempool_alloc_noprof+0xed/0x2b0
  btrfs_submit_chunk+0x28d/0x17e0
  ? __pfx_btrfs_submit_chunk+0x10/0x10
  ? bvec_alloc+0xd7/0x1b0
  ? bio_add_folio+0x171/0x270
  ? __pfx_bio_add_folio+0x10/0x10
  ? __kasan_check_read+0x20/0x20
  btrfs_submit_bio+0x37/0x80
  read_extent_buffer_pages+0x3df/0x6c0
  btrfs_read_extent_buffer+0x13e/0x5f0
  read_tree_block+0x81/0xe0
  read_block_for_search+0x4bd/0x7a0
  ? __pfx_read_block_for_search+0x10/0x10
  btrfs_search_slot+0x78d/0x2720
  ? __pfx_btrfs_search_slot+0x10/0x10
  ? lock_is_held_type+0x8f/0x100
  ? kasan_save_track+0x14/0x30
  ? __kasan_slab_alloc+0x6e/0x70
  ? kmem_cache_alloc_noprof+0x1f2/0x300
  btrfs_get_raid_extent_offset+0x181/0x820
  ? __pfx_lock_acquire+0x10/0x10
  ? __pfx_btrfs_get_raid_extent_offset+0x10/0x10
  ? down_read+0x194/0x440
  ? __pfx_down_read+0x10/0x10
  ? do_raw_read_unlock+0x44/0x70
  ? _raw_read_unlock+0x23/0x40
  btrfs_map_block+0x5b5/0x2250
  ? __pfx_btrfs_map_block+0x10/0x10
  scrub_submit_initial_read+0x8fe/0x11b0
  ? __pfx_scrub_submit_initial_read+0x10/0x10
  submit_initial_group_read+0x161/0x3a0
  ? lock_release+0x20e/0x710
  ? __pfx_submit_initial_group_read+0x10/0x10
  ? __pfx_lock_release+0x10/0x10
  scrub_simple_mirror.isra.0+0x3eb/0x580
  scrub_stripe+0xe4d/0x1440
  ? lock_release+0x20e/0x710
  ? __pfx_scrub_stripe+0x10/0x10
  ? __pfx_lock_release+0x10/0x10
  ? do_raw_read_unlock+0x44/0x70
  ? _raw_read_unlock+0x23/0x40
  scrub_chunk+0x257/0x4a0
  scrub_enumerate_chunks+0x64c/0xf70
  ? __mutex_unlock_slowpath+0x147/0x5f0
  ? __pfx_scrub_enumerate_chunks+0x10/0x10
  ? bit_wait_timeout+0xb0/0x170
  ? __up_read+0x189/0x700
  ? scrub_workers_get+0x231/0x300
  ? up_write+0x490/0x4f0
  btrfs_scrub_dev+0x52e/0xcd0
  ? create_pending_snapshots+0x230/0x250
  ? __pfx_btrfs_scrub_dev+0x10/0x10
  btrfs_dev_replace_by_ioctl+0xd69/0x1d00
  ? lock_acquire+0x19d/0x4a0
  ? __pfx_btrfs_dev_replace_by_ioctl+0x10/0x10
  ?
---truncated---</description><pubDate>Sat, 11 Jan 2025 12:51:54 +0000</pubDate></item><item><title>CVE-2024-48876 | stackdepot: fix stack_depot_save_flags() in NMI context</title><link>https://www.cve.org/CVERecord?id=CVE-2024-48876</link><description>In the Linux kernel, the following vulnerability has been resolved:

stackdepot: fix stack_depot_save_flags() in NMI context

Per documentation, stack_depot_save_flags() was meant to be usable from
NMI context if STACK_DEPOT_FLAG_CAN_ALLOC is unset.  However, it still
would try to take the pool_lock in an attempt to save a stack trace in the
current pool (if space is available).

This could result in deadlock if an NMI is handled while pool_lock is
already held.  To avoid deadlock, only try to take the lock in NMI context
and give up if unsuccessful.

The documentation is fixed to clearly convey this.</description><pubDate>Sat, 11 Jan 2025 12:51:54 +0000</pubDate></item><item><title>CVE-2024-48881 | bcache: revert replacing IS_ERR_OR_NULL with IS_ERR again</title><link>https://www.cve.org/CVERecord?id=CVE-2024-48881</link><description>In the Linux kernel, the following vulnerability has been resolved:

bcache: revert replacing IS_ERR_OR_NULL with IS_ERR again

Commit 028ddcac477b ("bcache: Remove unnecessary NULL point check in
node allocations") leads a NULL pointer deference in cache_set_flush().

1721         if (!IS_ERR_OR_NULL(c-&gt;root))
1722                 list_add(&amp;amp;c-&gt;root-&gt;list, &amp;amp;c-&gt;btree_cache);

&gt;From the above code in cache_set_flush(), if previous registration code
fails before allocating c-&gt;root, it is possible c-&gt;root is NULL as what
it is initialized. __bch_btree_node_alloc() never returns NULL but
c-&gt;root is possible to be NULL at above line 1721.

This patch replaces IS_ERR() by IS_ERR_OR_NULL() to fix this.</description><pubDate>Sat, 11 Jan 2025 12:51:55 +0000</pubDate></item><item><title>CVE-2024-49569 | nvme-rdma: unquiesce admin_q before destroy it</title><link>https://www.cve.org/CVERecord?id=CVE-2024-49569</link><description>In the Linux kernel, the following vulnerability has been resolved:

nvme-rdma: unquiesce admin_q before destroy it

Kernel will hang on destroy admin_q while we create ctrl failed, such
as following calltrace:

PID: 23644    TASK: ff2d52b40f439fc0  CPU: 2    COMMAND: "nvme"
 #0 [ff61d23de260fb78] __schedule at ffffffff8323bc15
 #1 [ff61d23de260fc08] schedule at ffffffff8323c014
 #2 [ff61d23de260fc28] blk_mq_freeze_queue_wait at ffffffff82a3dba1
 #3 [ff61d23de260fc78] blk_freeze_queue at ffffffff82a4113a
 #4 [ff61d23de260fc90] blk_cleanup_queue at ffffffff82a33006
 #5 [ff61d23de260fcb0] nvme_rdma_destroy_admin_queue at ffffffffc12686ce
 #6 [ff61d23de260fcc8] nvme_rdma_setup_ctrl at ffffffffc1268ced
 #7 [ff61d23de260fd28] nvme_rdma_create_ctrl at ffffffffc126919b
 #8 [ff61d23de260fd68] nvmf_dev_write at ffffffffc024f362
 #9 [ff61d23de260fe38] vfs_write at ffffffff827d5f25
    RIP: 00007fda7891d574  RSP: 00007ffe2ef06958  RFLAGS: 00000202
    RAX: ffffffffffffffda  RBX: 000055e8122a4d90  RCX: 00007fda7891d574
    RDX: 000000000000012b  RSI: 000055e8122a4d90  RDI: 0000000000000004
    RBP: 00007ffe2ef079c0   R8: 000000000000012b   R9: 000055e8122a4d90
    R10: 0000000000000000  R11: 0000000000000202  R12: 0000000000000004
    R13: 000055e8122923c0  R14: 000000000000012b  R15: 00007fda78a54500
    ORIG_RAX: 0000000000000001  CS: 0033  SS: 002b

This due to we have quiesced admi_q before cancel requests, but forgot
to unquiesce before destroy it, as a result we fail to drain the
pending requests, and hang on blk_mq_freeze_queue_wait() forever. Here
try to reuse nvme_rdma_teardown_admin_queue() to fix this issue and
simplify the code.</description><pubDate>Sat, 11 Jan 2025 12:51:55 +0000</pubDate></item><item><title>CVE-2024-50051 | spi: mpc52xx: Add cancel_work_sync before module remove</title><link>https://www.cve.org/CVERecord?id=CVE-2024-50051</link><description>In the Linux kernel, the following vulnerability has been resolved:

spi: mpc52xx: Add cancel_work_sync before module remove

If we remove the module which will call mpc52xx_spi_remove
it will free 'ms' through spi_unregister_controller.
while the work ms-&gt;work will be used. The sequence of operations
that may lead to a UAF bug.

Fix it by ensuring that the work is canceled before proceeding with
the cleanup in mpc52xx_spi_remove.</description><pubDate>Sat, 11 Jan 2025 12:51:56 +0000</pubDate></item><item><title>CVE-2024-52332 | igb: Fix potential invalid memory access in igb_init_module()</title><link>https://www.cve.org/CVERecord?id=CVE-2024-52332</link><description>In the Linux kernel, the following vulnerability has been resolved:

igb: Fix potential invalid memory access in igb_init_module()

The pci_register_driver() can fail and when this happened, the dca_notifier
needs to be unregistered, otherwise the dca_notifier can be called when
igb fails to install, resulting to invalid memory access.</description><pubDate>Sat, 11 Jan 2025 12:51:56 +0000</pubDate></item><item><title>CVE-2024-53680 | ipvs: fix UB due to uninitialized stack access in ip_vs_protocol_init()</title><link>https://www.cve.org/CVERecord?id=CVE-2024-53680</link><description>In the Linux kernel, the following vulnerability has been resolved:

ipvs: fix UB due to uninitialized stack access in ip_vs_protocol_init()

Under certain kernel configurations when building with Clang/LLVM, the
compiler does not generate a return or jump as the terminator
instruction for ip_vs_protocol_init(), triggering the following objtool
warning during build time:

  vmlinux.o: warning: objtool: ip_vs_protocol_init() falls through to next function __initstub__kmod_ip_vs_rr__935_123_ip_vs_rr_init6()

At runtime, this either causes an oops when trying to load the ipvs
module or a boot-time panic if ipvs is built-in. This same issue has
been reported by the Intel kernel test robot previously.

Digging deeper into both LLVM and the kernel code reveals this to be a
undefined behavior problem. ip_vs_protocol_init() uses a on-stack buffer
of 64 chars to store the registered protocol names and leaves it
uninitialized after definition. The function calls strnlen() when
concatenating protocol names into the buffer. With CONFIG_FORTIFY_SOURCE
strnlen() performs an extra step to check whether the last byte of the
input char buffer is a null character (commit 3009f891bb9f ("fortify:
Allow strlen() and strnlen() to pass compile-time known lengths")).
This, together with possibly other configurations, cause the following
IR to be generated:

  define hidden i32 @ip_vs_protocol_init() local_unnamed_addr #5 section ".init.text" align 16 !kcfi_type !29 {
    %1 = alloca [64 x i8], align 16
    ...

  14:                                               ; preds = %11
    %15 = getelementptr inbounds i8, ptr %1, i64 63
    %16 = load i8, ptr %15, align 1
    %17 = tail call i1 @llvm.is.constant.i8(i8 %16)
    %18 = icmp eq i8 %16, 0
    %19 = select i1 %17, i1 %18, i1 false
    br i1 %19, label %20, label %23

  20:                                               ; preds = %14
    %21 = call i64 @strlen(ptr noundef nonnull dereferenceable(1) %1) #23
    ...

  23:                                               ; preds = %14, %11, %20
    %24 = call i64 @strnlen(ptr noundef nonnull dereferenceable(1) %1, i64 noundef 64) #24
    ...
  }

The above code calculates the address of the last char in the buffer
(value %15) and then loads from it (value %16). Because the buffer is
never initialized, the LLVM GVN pass marks value %16 as undefined:

  %13 = getelementptr inbounds i8, ptr %1, i64 63
  br i1 undef, label %14, label %17

This gives later passes (SCCP, in particular) more DCE opportunities by
propagating the undef value further, and eventually removes everything
after the load on the uninitialized stack location:

  define hidden i32 @ip_vs_protocol_init() local_unnamed_addr #0 section ".init.text" align 16 !kcfi_type !11 {
    %1 = alloca [64 x i8], align 16
    ...

  12:                                               ; preds = %11
    %13 = getelementptr inbounds i8, ptr %1, i64 63
    unreachable
  }

In this way, the generated native code will just fall through to the
next function, as LLVM does not generate any code for the unreachable IR
instruction and leaves the function without a terminator.

Zero the on-stack buffer to avoid this possible UB.</description><pubDate>Sat, 11 Jan 2025 12:51:56 +0000</pubDate></item><item><title>CVE-2025-0392 | Guangzhou Huayi Intelligent Technology Jeewms graphReportController.do datagridGraph sql injection</title><link>https://www.cve.org/CVERecord?id=CVE-2025-0392</link><description>A vulnerability, which was classified as critical, was found in Guangzhou Huayi Intelligent Technology Jeewms up to 20241229. Affected is the function datagridGraph of the file /graphReportController.do. The manipulation of the argument store_code leads to sql injection. It is possible to launch the attack remotely. The exploit has been disclosed to the public and may be used. Upgrading to version 20250101 is able to address this issue. It is recommended to upgrade the affected component.</description><pubDate>Sat, 11 Jan 2025 11:07:46 +0000</pubDate></item><item><title>CVE-2025-0391 | Guangzhou Huayi Intelligent Technology Jeewms CgFormBuildController. java saveOrUpdate sql injection</title><link>https://www.cve.org/CVERecord?id=CVE-2025-0391</link><description>A vulnerability, which was classified as critical, has been found in Guangzhou Huayi Intelligent Technology Jeewms up to 20241229. This issue affects the function saveOrUpdate of the file org/jeecgframework/web/cgform/controller/build/CgFormBuildController. java. The manipulation leads to sql injection. The attack may be initiated remotely. The exploit has been disclosed to the public and may be used. Upgrading to version 20250101 is able to address this issue. It is recommended to upgrade the affected component.</description><pubDate>Sat, 11 Jan 2025 09:10:42 +0000</pubDate></item><item><title>CVE-2025-0390 | Guangzhou Huayi Intelligent Technology Jeewms wmOmNoticeHController.do path traversal</title><link>https://www.cve.org/CVERecord?id=CVE-2025-0390</link><description>A vulnerability classified as critical was found in Guangzhou Huayi Intelligent Technology Jeewms up to 20241229. This vulnerability affects unknown code of the file /wmOmNoticeHController.do. The manipulation leads to path traversal: '../filedir'. The attack can be initiated remotely. The exploit has been disclosed to the public and may be used. Upgrading to version 20250101 is able to address this issue. It is recommended to upgrade the affected component.</description><pubDate>Sat, 11 Jan 2025 07:35:21 +0000</pubDate></item><item><title>CVE-2024-11386 | GatorMail SmartForms &amp;lt;= 1.1.0 - Authenticated (Contributor+) Stored Cross-Site Scripting</title><link>https://www.cve.org/CVERecord?id=CVE-2024-11386</link><description>The GatorMail SmartForms plugin for WordPress is vulnerable to Stored Cross-Site Scripting via the plugin's 'gatormailsmartform' shortcode in all versions up to, and including, 1.1.0 due to insufficient input sanitization and output escaping on user supplied attributes. This makes it possible for authenticated attackers, with contributor-level access and above, to inject arbitrary web scripts in pages that will execute whenever a user accesses an injected page.</description><pubDate>Sat, 11 Jan 2025 07:35:22 +0000</pubDate></item><item><title>CVE-2024-11758 | WP SPID Italia &amp;lt;= 2.9 - Authenticated (Contributor+) Stored Cross-Site Scripting</title><link>https://www.cve.org/CVERecord?id=CVE-2024-11758</link><description>The WP SPID Italia plugin for WordPress is vulnerable to Stored Cross-Site Scripting via the plugin's shortcode in all versions up to, and including, 2.9 due to insufficient input sanitization and output escaping on user supplied attributes. This makes it possible for authenticated attackers, with contributor-level access and above, to inject arbitrary web scripts in pages that will execute whenever a user accesses an injected page.</description><pubDate>Sat, 11 Jan 2025 07:35:23 +0000</pubDate></item><item><title>CVE-2024-11874 | Grid Accordion Lite &amp;lt;= 1.5.1 - Authenticated (Contributor+) Stored Cross-Site Scripting</title><link>https://www.cve.org/CVERecord?id=CVE-2024-11874</link><description>The Grid Accordion Lite plugin for WordPress is vulnerable to Stored Cross-Site Scripting via the plugin's 'grid_accordion' shortcode in all versions up to, and including, 1.5.1 due to insufficient input sanitization and output escaping on user supplied attributes. This makes it possible for authenticated attackers, with contributor-level access and above, to inject arbitrary web scripts in pages that will execute whenever a user accesses an injected page.</description><pubDate>Sat, 11 Jan 2025 07:35:23 +0000</pubDate></item><item><title>CVE-2024-11892 | Accordion Slider Lite &amp;lt;= 1.5.1 - Authenticated (Contributor+) Stored Cross-Site Scripting</title><link>https://www.cve.org/CVERecord?id=CVE-2024-11892</link><description>The Accordion Slider Lite plugin for WordPress is vulnerable to Stored Cross-Site Scripting via the plugin's 'accordion_slider' shortcode in all versions up to, and including, 1.5.1 due to insufficient input sanitization and output escaping on user supplied attributes. This makes it possible for authenticated attackers, with contributor-level access and above, to inject arbitrary web scripts in pages that will execute whenever a user accesses an injected page.</description><pubDate>Sat, 11 Jan 2025 07:35:24 +0000</pubDate></item><item><title>CVE-2024-11915 | RRAddons for Elementor &amp;lt;= 1.1.0 - Authenticated (Contributor+) Post Disclosure</title><link>https://www.cve.org/CVERecord?id=CVE-2024-11915</link><description>The RRAddons for Elementor plugin for WordPress is vulnerable to Information Exposure in all versions up to, and including, 1.1.0 via the Popup block due to insufficient restrictions on which posts can be included. This makes it possible for authenticated attackers, with Contributor-level access and above, to extract data from private or draft posts that they should not have access to.</description><pubDate>Sat, 11 Jan 2025 07:35:24 +0000</pubDate></item><item><title>CVE-2024-12116 | Unlimited Theme Addon For Elementor and WooCommerce &amp;lt;= 1.2.1 - Authenticated (Contributor+) Post Disclosure</title><link>https://www.cve.org/CVERecord?id=CVE-2024-12116</link><description>The Unlimited Theme Addon For Elementor and WooCommerce plugin for WordPress is vulnerable to Information Exposure in all versions up to, and including, 1.2.1 via the 'uta-template' shortcode due to insufficient restrictions on which posts can be included. This makes it possible for authenticated attackers, with Contributor-level access and above, to extract data from private or draft posts created by Elementor that they should not have access to.</description><pubDate>Sat, 11 Jan 2025 07:35:25 +0000</pubDate></item><item><title>CVE-2024-12407 | Push Notification for Post and BuddyPress &amp;lt;= 2.06 - Reflected Cross-Site Scripting</title><link>https://www.cve.org/CVERecord?id=CVE-2024-12407</link><description>The Push Notification for Post and BuddyPress plugin for WordPress is vulnerable to Reflected Cross-Site Scripting via the 'pushnotificationid' parameter in all versions up to, and including, 2.06 due to insufficient input sanitization and output escaping. This makes it possible for unauthenticated attackers to inject arbitrary web scripts in pages that execute if they can successfully trick a user into performing an action such as clicking on a link.</description><pubDate>Sat, 11 Jan 2025 07:35:25 +0000</pubDate></item><item><title>CVE-2024-12412 | Rental and Booking Manager for Bike, Car, Dress, Resort with WooCommerce Integration – WpRently | WordPress plugin &amp;lt;= 2.2.1 - Reflected Cross-Site Scripting</title><link>https://www.cve.org/CVERecord?id=CVE-2024-12412</link><description>The Rental and Booking Manager for Bike, Car, Dress, Resort with WooCommerce Integration – WpRently | WordPress plugin plugin for WordPress is vulnerable to Stored Cross-Site Scripting via the ‘active_tab’ parameter in all versions up to, and including, 2.2.1 due to insufficient input sanitization and output escaping. This makes it possible for unauthenticated attackers to inject arbitrary web scripts in pages that will execute whenever a user accesses an injected page.</description><pubDate>Sat, 11 Jan 2025 07:35:26 +0000</pubDate></item><item><title>CVE-2024-12519 | TCBD Auto Refresher &amp;lt;= 2.0 - Authenticated (Contributor+) Stored Cross-Site Scripting</title><link>https://www.cve.org/CVERecord?id=CVE-2024-12519</link><description>The TCBD Auto Refresher plugin for WordPress is vulnerable to Stored Cross-Site Scripting via the plugin's 'tcbd_auto_refresh' shortcode in all versions up to, and including, 2.0 due to insufficient input sanitization and output escaping on user supplied attributes. This makes it possible for authenticated attackers, with contributor-level access and above, to inject arbitrary web scripts in pages that will execute whenever a user accesses an injected page.</description><pubDate>Sat, 11 Jan 2025 07:35:26 +0000</pubDate></item><item><title>CVE-2024-12520 | Dominion – Domain Checker for WPBakery &amp;lt;= 2.2.2 - Authenticated (Contributor+) Stored Cross-Site Scripting</title><link>https://www.cve.org/CVERecord?id=CVE-2024-12520</link><description>The Dominion – Domain Checker for WPBakery plugin for WordPress is vulnerable to Stored Cross-Site Scripting via the plugin's 'dominion_shortcodes_domain_search_6' shortcode in all versions up to, and including, 2.2.2 due to insufficient input sanitization and output escaping on user supplied attributes. This makes it possible for authenticated attackers, with contributor-level access and above, to inject arbitrary web scripts in pages that will execute whenever a user accesses an injected page.</description><pubDate>Sat, 11 Jan 2025 07:35:26 +0000</pubDate></item><item><title>CVE-2024-12527 | Perfect Portal Widgets &amp;lt;= 3.0.3 - Authenticated (Contributor+) Stored Cross-Site Scripting</title><link>https://www.cve.org/CVERecord?id=CVE-2024-12527</link><description>The Perfect Portal Widgets plugin for WordPress is vulnerable to Stored Cross-Site Scripting via the plugin's 'perfect_portal_intake_form' shortcode in all versions up to, and including, 3.0.3 due to insufficient input sanitization and output escaping on user supplied attributes. This makes it possible for authenticated attackers, with contributor-level access and above, to inject arbitrary web scripts in pages that will execute whenever a user accesses an injected page.</description><pubDate>Sat, 11 Jan 2025 07:35:27 +0000</pubDate></item><item><title>CVE-2024-12877 | GiveWP – Donation Plugin and Fundraising Platform &amp;lt;= 3.19.2 - Unauthenticated PHP Object Injection</title><link>https://www.cve.org/CVERecord?id=CVE-2024-12877</link><description>The GiveWP – Donation Plugin and Fundraising Platform plugin for WordPress is vulnerable to PHP Object Injection in all versions up to, and including, 3.19.2 via deserialization of untrusted input from the donation form like 'firstName'. This makes it possible for unauthenticated attackers to inject a PHP Object. The additional presence of a POP chain allows attackers to delete arbitrary files on the server that makes remote code execution possible. Please note this was only partially patched in 3.19.3, a fully sufficient patch was not released until 3.19.4. However, another CVE was assigned by another CNA for version 3.19.3 so we will leave this as affecting 3.19.2 and before. We have recommended the vendor use JSON encoding to prevent any further deserialization vulnerabilities from being present.</description><pubDate>Sat, 11 Jan 2025 07:35:27 +0000</pubDate></item><item><title>CVE-2024-42175 | HCL MyXalytics is affected by a weak input validation vulnerability</title><link>https://www.cve.org/CVERecord?id=CVE-2024-42175</link><description>HCL MyXalytics is affected by a weak input validation vulnerability.  The application accepts special characters and there is no length validation. This can lead to security vulnerabilities like SQL injection, XSS, and buffer overflow.</description><pubDate>Sat, 11 Jan 2025 07:35:28 +0000</pubDate></item><item><title>CVE-2024-42174 | HCL MyXalytics is affected by username enumeration vulnerability</title><link>https://www.cve.org/CVERecord?id=CVE-2024-42174</link><description>HCL MyXalytics is affected by username enumeration vulnerability.  This allows a malicious user to perform enumeration of application users, and therefore compile a list of valid usernames.</description><pubDate>Sat, 11 Jan 2025 07:18:10 +0000</pubDate></item><item><title>CVE-2024-42173 | HCL MyXalytics is affected by an improper password policy implementation vulnerability</title><link>https://www.cve.org/CVERecord?id=CVE-2024-42173</link><description>HCL MyXalytics is affected by an improper password policy implementation vulnerability.  Weak passwords and lack of account lockout policies allow attackers to guess or brute-force passwords if the username is known.</description><pubDate>Sat, 11 Jan 2025 07:01:00 +0000</pubDate></item><item><title>CVE-2024-42172 | HCL MyXalytics is affected by broken authentication</title><link>https://www.cve.org/CVERecord?id=CVE-2024-42172</link><description>HCL MyXalytics is affected by broken authentication.  It allows attackers to compromise keys, passwords, and session tokens, potentially leading to identity theft and system control.  This vulnerability arises from poor configuration, logic errors, or software bugs and can affect any application with access control, including databases, network infrastructure, and web applications.</description><pubDate>Sat, 11 Jan 2025 06:54:15 +0000</pubDate></item><item><title>CVE-2024-42171 | HCL MyXalytics is affected by insufficient session expiration</title><link>https://www.cve.org/CVERecord?id=CVE-2024-42171</link><description>HCL MyXalytics is affected by a session fixation vulnerability.  Cyber-criminals can exploit this by sending crafted URLs with a session token to access the victim's login session.</description><pubDate>Sat, 11 Jan 2025 06:39:23 +0000</pubDate></item><item><title>CVE-2024-42170 | HCL MyXalytics is affected by a session fixation vulnerability</title><link>https://www.cve.org/CVERecord?id=CVE-2024-42170</link><description>HCL MyXalytics is affected by a session fixation vulnerability.  Cyber-criminals can exploit this by sending crafted URLs with a session token to access the victim's login session.</description><pubDate>Sat, 11 Jan 2025 06:39:24 +0000</pubDate></item><item><title>CVE-2024-12587 | Contact Form Master &amp;lt;= 1.0.7 - Reflected XSS</title><link>https://www.cve.org/CVERecord?id=CVE-2024-12587</link><description>The Contact Form Master  WordPress plugin through 1.0.7 does not sanitise and escape a parameter before outputting it back in the page, leading to a Reflected Cross-Site Scripting which could be used against high privilege users such as admin.</description><pubDate>Sat, 11 Jan 2025 06:21:54 +0000</pubDate></item><item><title>CVE-2025-23108 | Opening Javascript links in a new tab via long-press in the Firefox iOS client could result in a malicious script spoofing the URL of the ne...</title><link>https://www.cve.org/CVERecord?id=CVE-2025-23108</link><description>Opening Javascript links in a new tab via long-press in the Firefox iOS client could result in a malicious script spoofing the URL of the new tab. This vulnerability affects Firefox for iOS &lt; 134.</description><pubDate>Sat, 11 Jan 2025 03:44:11 +0000</pubDate></item><item><title>CVE-2025-23109 | Long hostnames in URLs could be leveraged to obscure the actual host of the website or spoof the website address This vulnerability affects ...</title><link>https://www.cve.org/CVERecord?id=CVE-2025-23109</link><description>Long hostnames in URLs could be leveraged to obscure the actual host of the website or spoof the website address This vulnerability affects Firefox for iOS &lt; 134.</description><pubDate>Sat, 11 Jan 2025 03:44:11 +0000</pubDate></item><item><title>CVE-2024-12304 | Gutenberg Blocks with AI by Kadence WP – Page Builder Features &amp;lt;= 3.4.2 - Authenticated (contributor+) Stored Cross-Site Scripting via Button Link</title><link>https://www.cve.org/CVERecord?id=CVE-2024-12304</link><description>The Gutenberg Blocks with AI by Kadence WP – Page Builder Features plugin for WordPress is vulnerable to Stored Cross-Site Scripting via button block link in all versions up to, and including, 3.4.2 due to insufficient input sanitization and output escaping. This makes it possible for authenticated attackers, with Contributor-level access and above, to inject arbitrary web scripts in pages that will execute whenever a user accesses an injected page.</description><pubDate>Sat, 11 Jan 2025 03:33:49 +0000</pubDate></item><item><title>CVE-2025-0103 | Expedition: SQL Injection Vulnerability</title><link>https://www.cve.org/CVERecord?id=CVE-2025-0103</link><description>An SQL injection vulnerability in Palo Alto Networks Expedition enables an authenticated attacker to reveal Expedition database contents, such as password hashes, usernames, device configurations, and device API keys. This vulnerability also enables attackers to create and read arbitrary files on the Expedition system.</description><pubDate>Sat, 11 Jan 2025 03:13:51 +0000</pubDate></item><item><title>CVE-2025-0104 | Expedition: Cross-Site Scripting (XSS) Vulnerability</title><link>https://www.cve.org/CVERecord?id=CVE-2025-0104</link><description>A reflected cross-site scripting (XSS) vulnerability in Palo Alto Networks Expedition enables attackers to execute malicious JavaScript code in the context of an authenticated Expedition user’s browser if that authenticated user clicks a malicious link that allows phishing attacks and could lead to Expedition browser-session theft.</description><pubDate>Sat, 11 Jan 2025 03:13:51 +0000</pubDate></item><item><title>CVE-2025-0105 | Expedition: Arbitrary File Deletion Vulnerability</title><link>https://www.cve.org/CVERecord?id=CVE-2025-0105</link><description>An arbitrary file deletion vulnerability in Palo Alto Networks Expedition enables an unauthenticated attacker to delete arbitrary files accessible to the www-data user on the host filesystem.</description><pubDate>Sat, 11 Jan 2025 03:13:52 +0000</pubDate></item><item><title>CVE-2025-0106 | Expedition: Wildcard Expansion Vulnerability</title><link>https://www.cve.org/CVERecord?id=CVE-2025-0106</link><description>A wildcard expansion vulnerability in Palo Alto Networks Expedition allows an unauthenticated attacker to enumerate files on the host filesystem.</description><pubDate>Sat, 11 Jan 2025 03:13:52 +0000</pubDate></item><item><title>CVE-2025-0107 | Expedition: OS Command Injection Vulnerability</title><link>https://www.cve.org/CVERecord?id=CVE-2025-0107</link><description>An OS command injection vulnerability in Palo Alto Networks Expedition enables an authenticated attacker to run arbitrary OS commands as the www-data user in Expedition, which results in the disclosure of usernames, cleartext passwords, device configurations, and device API keys for firewalls running PAN-OS software.</description><pubDate>Sat, 11 Jan 2025 03:13:53 +0000</pubDate></item><item><title>CVE-2024-11327 | ClickWhale – Link Manager, Link Shortener and Click Tracker for Affiliate Links &amp;amp; Link Pages &amp;lt;= 2.4.1 - Reflected Cross-Site Scripting</title><link>https://www.cve.org/CVERecord?id=CVE-2024-11327</link><description>The ClickWhale – Link Manager, Link Shortener and Click Tracker for Affiliate Links &amp; Link Pages plugin for WordPress is vulnerable to Reflected Cross-Site Scripting due to the use of add_query_arg &amp; remove_query_arg without appropriate escaping on the URL in all versions up to, and including, 2.4.1. This makes it possible for unauthenticated attackers to inject arbitrary web scripts in pages that execute if they can successfully trick a user into performing an action such as clicking on a link.</description><pubDate>Sat, 11 Jan 2025 02:54:26 +0000</pubDate></item><item><title>CVE-2024-12204 | Coupon X: Discount Pop Up, Promo Code Pop Ups, Announcement Pop Up, WooCommerce Popups &amp;lt;= 1.3.5 - Missing Authorization</title><link>https://www.cve.org/CVERecord?id=CVE-2024-12204</link><description>The Coupon X: Discount Pop Up, Promo Code Pop Ups, Announcement Pop Up, WooCommerce Popups plugin for WordPress is vulnerable to unauthorized access due to missing capability checks on several functions in the class-cx-rest.php file in all versions up to, and including, 1.3.5. This makes it possible for authenticated attackers, with Subscriber-level access and above, to create 100% off coupons, delete posts, delete leads, and update coupon statuses.</description><pubDate>Sat, 11 Jan 2025 02:54:26 +0000</pubDate></item><item><title>CVE-2024-12404 | CF Internal Link Shortcode &amp;lt;= 1.1.0 - Unauthenticated SQL Injection</title><link>https://www.cve.org/CVERecord?id=CVE-2024-12404</link><description>The CF Internal Link Shortcode plugin for WordPress is vulnerable to SQL Injection via the 'post_title' parameter in all versions up to, and including, 1.1.0 due to insufficient escaping on the user supplied parameter and lack of sufficient preparation on the existing SQL query.  This makes it possible for unauthenticated attackers to append additional SQL queries into already existing queries that can be used to extract sensitive information from the database.</description><pubDate>Sat, 11 Jan 2025 02:54:27 +0000</pubDate></item><item><title>CVE-2024-12472 | Post Duplicator &amp;lt;= 2.36 - Authenticated (Contributor+) Protected Post Disclosure</title><link>https://www.cve.org/CVERecord?id=CVE-2024-12472</link><description>The Post Duplicator plugin for WordPress is vulnerable to Information Exposure in all versions up to, and including, 2.36 via the mtphr_duplicate_post() due to insufficient restrictions on which posts can be duplicated. This makes it possible for authenticated attackers, with Contributor-level access and above, to extract data from password protected, private, or draft posts that they should not have access to by duplicating the post.</description><pubDate>Sat, 11 Jan 2025 02:54:27 +0000</pubDate></item><item><title>CVE-2024-12505 | Trackserver &amp;lt;= 5.0.2 - Authenticated (Contributor+) Stored Cross-Site Scripting</title><link>https://www.cve.org/CVERecord?id=CVE-2024-12505</link><description>The Trackserver plugin for WordPress is vulnerable to Stored Cross-Site Scripting via the plugin's 'tsmap' shortcode in all versions up to, and including, 5.0.2 due to insufficient input sanitization and output escaping on user supplied attributes. This makes it possible for authenticated attackers, with contributor-level access and above, to inject arbitrary web scripts in pages that will execute whenever a user accesses an injected page.</description><pubDate>Sat, 11 Jan 2025 02:54:28 +0000</pubDate></item><item><title>CVE-2024-12627 | Coupon X: Discount Pop Up, Promo Code Pop Ups, Announcement Pop Up, WooCommerce Popups &amp;lt;= 1.3.5 - Missing Authorization to Authenticated (Contributor+) PHP Object Injection</title><link>https://www.cve.org/CVERecord?id=CVE-2024-12627</link><description>The Coupon X: Discount Pop Up, Promo Code Pop Ups, Announcement Pop Up, WooCommerce Popups plugin for WordPress is vulnerable to PHP Object Injection in all versions up to, and including, 1.3.5 via deserialization of untrusted input from post content passed to the capture_email AJAX action. This makes it possible for authenticated attackers, with Contributor-level access and above, to inject a PHP Object. No known POP chain is present in the vulnerable software. If a POP chain is present via an additional plugin or theme installed on the target system, it could allow the attacker to delete arbitrary files, retrieve sensitive data, or execute code.</description><pubDate>Sat, 11 Jan 2025 02:54:28 +0000</pubDate></item><item><title>CVE-2024-42168 | HCL MyXalytics is affected by out-of-band resource load (HTTP) vulnerability</title><link>https://www.cve.org/CVERecord?id=CVE-2024-42168</link><description>HCL MyXalytics is affected by out-of-band resource load (HTTP) vulnerability.  An attacker can deploy a web server that returns malicious content, and then induce the application to retrieve and process that content.</description><pubDate>Sat, 11 Jan 2025 02:54:28 +0000</pubDate></item><item><title>CVE-2024-42169 | HCL MyXalytics is affected by insecure direct object references</title><link>https://www.cve.org/CVERecord?id=CVE-2024-42169</link><description>HCL MyXalytics is affected by insecure direct object references.  It occurs due to missing access control checks, which fail to verify whether a user should be allowed to access specific data.</description><pubDate>Sat, 11 Jan 2025 02:54:29 +0000</pubDate></item></channel></rss>