<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>New CVE from cve.org feed</title><link>https://github.com/test.xml</link><description>Last 2 days CVE feed!</description><atom:link href="https://github.com/test.xml" rel="self"/><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><language>en</language><lastBuildDate>Mon, 02 Feb 2026 02:31:03 +0000</lastBuildDate><item><title>CVE-2025-13348 | An improper access control vulnerability exists in ASUS Secure Delete Driver of ASUS Business Manager. This vulnerability can be triggered b...</title><link>https://www.cve.org/CVERecord?id=CVE-2025-13348</link><description>An improper access control vulnerability exists in ASUS Secure Delete Driver of ASUS Business Manager. This vulnerability can be triggered by a local user sending a specially crafted request, potentially leading to the creation of arbitrary files in a specified path. Refer to the "Security Update for ASUS Business Manager" section on the ASUS Security Advisory for more information.</description><pubDate>Mon, 02 Feb 2026 02:31:05 +0000</pubDate></item><item><title>CVE-2026-1738 | Open5GS SGWC context.c sgwc_tunnel_add assertion</title><link>https://www.cve.org/CVERecord?id=CVE-2026-1738</link><description>A flaw has been found in Open5GS up to 2.7.6. The impacted element is the function sgwc_tunnel_add of the file /src/sgwc/context.c of the component SGWC. Executing a manipulation of the argument pdr can lead to reachable assertion. The attack can be executed remotely. The exploit has been published and may be used. It is advisable to implement a patch to correct this issue. The issue report is flagged as already-fixed.</description><pubDate>Mon, 02 Feb 2026 02:31:05 +0000</pubDate></item><item><title>CVE-2026-1739 | Free5GC pcf smpolicy.go HandleCreateSmPolicyRequest null pointer dereference</title><link>https://www.cve.org/CVERecord?id=CVE-2026-1739</link><description>A vulnerability has been found in Free5GC pcf up to 1.4.1. This affects the function HandleCreateSmPolicyRequest of the file internal/sbi/processor/smpolicy.go. The manipulation leads to null pointer dereference. The attack is possible to be carried out remotely. The exploit has been disclosed to the public and may be used. The identifier of the patch is df535f5524314620715e842baf9723efbeb481a7. Applying a patch is the recommended action to fix this issue.</description><pubDate>Mon, 02 Feb 2026 02:31:05 +0000</pubDate></item><item><title>CVE-2026-1737 | Open5GS CreateBearerRequest s5c-handler.c sgwc_s5c_handle_create_bearer_request assertion</title><link>https://www.cve.org/CVERecord?id=CVE-2026-1737</link><description>A vulnerability was detected in Open5GS up to 2.7.6. The affected element is the function sgwc_s5c_handle_create_bearer_request of the file /src/sgwc/s5c-handler.c of the component CreateBearerRequest Handler. Performing a manipulation results in reachable assertion. Remote exploitation of the attack is possible. The exploit is now public and may be used. To fix this issue, it is recommended to deploy a patch. The issue report is flagged as already-fixed.</description><pubDate>Mon, 02 Feb 2026 02:31:06 +0000</pubDate></item><item><title>CVE-2026-1735 | Yealink MeetingBar A30 Diagnostic command injection</title><link>https://www.cve.org/CVERecord?id=CVE-2026-1735</link><description>A weakness has been identified in Yealink MeetingBar A30 133.321.0.3. This issue affects some unknown processing of the component Diagnostic Handler. This manipulation causes command injection. It is feasible to perform the attack on the physical device. The exploit has been made available to the public and could be used for attacks. The vendor was contacted early about this disclosure but did not respond in any way.</description><pubDate>Mon, 02 Feb 2026 02:31:07 +0000</pubDate></item><item><title>CVE-2026-1736 | Open5GS SGWC s11-handler.c assertion</title><link>https://www.cve.org/CVERecord?id=CVE-2026-1736</link><description>A security vulnerability has been detected in Open5GS up to 2.7.6. Impacted is the function sgwc_s11_handle_create_indirect_data_forwarding_tunnel_request of the file /src/sgwc/s11-handler.c of the component SGWC. Such manipulation leads to reachable assertion. The attack may be launched remotely. The exploit has been disclosed publicly and may be used. A patch should be applied to remediate this issue. The issue report is flagged as already-fixed.</description><pubDate>Mon, 02 Feb 2026 02:31:07 +0000</pubDate></item><item><title>CVE-2026-1734 | Zhong Bang CRMEB crontab Endpoint CrontabController.php authorization</title><link>https://www.cve.org/CVERecord?id=CVE-2026-1734</link><description>A security flaw has been discovered in Zhong Bang CRMEB up to 5.6.3. This vulnerability affects unknown code of the file crmeb/app/api/controller/v1/CrontabController.php of the component crontab Endpoint. The manipulation results in missing authorization. The attack can be launched remotely. The exploit has been released to the public and may be used for attacks. The vendor was contacted early about this disclosure but did not respond in any way.</description><pubDate>Sun, 01 Feb 2026 23:43:52 +0000</pubDate></item><item><title>CVE-2026-1733 | Zhong Bang CRMEB :uni tidyOrder improper authorization</title><link>https://www.cve.org/CVERecord?id=CVE-2026-1733</link><description>A vulnerability was identified in Zhong Bang CRMEB up to 5.6.3. This affects the function detail/tidyOrder of the file /api/store_integral/order/detail/:uni. The manipulation of the argument order_id leads to improper authorization. The attack can be initiated remotely. The exploit is publicly available and might be used. The vendor was contacted early about this disclosure but did not respond in any way.</description><pubDate>Sun, 01 Feb 2026 23:19:11 +0000</pubDate></item><item><title>CVE-2026-25253 | OpenClaw (aka clawdbot or Moltbot) before 2026.1.29 obtains a gatewayUrl value from a query string and automatically makes a WebSocket conne...</title><link>https://www.cve.org/CVERecord?id=CVE-2026-25253</link><description>OpenClaw (aka clawdbot or Moltbot) before 2026.1.29 obtains a gatewayUrl value from a query string and automatically makes a WebSocket connection without prompting, sending a token value.</description><pubDate>Sun, 01 Feb 2026 22:55:08 +0000</pubDate></item><item><title>CVE-2020-37037 | AVAST SecureLine 5.5.522.0 - &amp;#x27;SecureLine&amp;#x27; Unquoted Service Path</title><link>https://www.cve.org/CVERecord?id=CVE-2020-37037</link><description>Avast SecureLine 5.5.522.0 contains an unquoted service path vulnerability that allows local users to potentially execute code with elevated system privileges. Attackers can exploit the unquoted path in the service configuration to inject malicious code that would execute with LocalSystem account permissions during service startup.</description><pubDate>Sun, 01 Feb 2026 14:54:10 +0000</pubDate></item><item><title>CVE-2020-37045 | NetBackup 7.0 - &amp;#x27;NetBackup INET Daemon&amp;#x27; Unquoted Service Path</title><link>https://www.cve.org/CVERecord?id=CVE-2020-37045</link><description>Veritas NetBackup 7.0 contains an unquoted service path vulnerability in the NetBackup INET Daemon service that allows local users to potentially execute arbitrary code. Attackers can exploit the unquoted path in C:\Program Files\Veritas\NetBackup\bin\bpinetd.exe to inject malicious code that would execute with elevated LocalSystem privileges.</description><pubDate>Sun, 01 Feb 2026 14:54:10 +0000</pubDate></item><item><title>CVE-2020-37047 | Deep Instinct Windows Agent 1.2.29.0 - &amp;#x27;DeepMgmtService&amp;#x27; Unquoted Service Path</title><link>https://www.cve.org/CVERecord?id=CVE-2020-37047</link><description>Deep Instinct Windows Agent 1.2.29.0 contains an unquoted service path vulnerability in the DeepMgmtService that allows local users to potentially execute code with elevated privileges. Attackers can exploit the unquoted path in C:\Program Files\HP Sure Sense\DeepMgmtService.exe to inject malicious code that would execute with LocalSystem permissions during service startup.</description><pubDate>Sun, 01 Feb 2026 14:54:11 +0000</pubDate></item><item><title>CVE-2020-37048 | Iskysoft Application Framework Service 2.4.3.241 - &amp;#x27;IsAppService&amp;#x27; Unquoted Service Path</title><link>https://www.cve.org/CVERecord?id=CVE-2020-37048</link><description>Iskysoft Application Framework Service 2.4.3.241 contains an unquoted service path vulnerability that allows local users to potentially execute arbitrary code with elevated privileges. Attackers can exploit the unquoted path in the service configuration to inject malicious executables that would be run with the service's high-level system permissions.</description><pubDate>Sun, 01 Feb 2026 14:54:11 +0000</pubDate></item><item><title>CVE-2020-37055 | SpyHunter 4 - &amp;#x27;SpyHunter 4 Service&amp;#x27; Unquoted Service Path</title><link>https://www.cve.org/CVERecord?id=CVE-2020-37055</link><description>SpyHunter 4 contains an unquoted service path vulnerability that allows local users to potentially execute arbitrary code with elevated system privileges. Attackers can exploit the unquoted service path by placing malicious executables in specific file system locations to gain elevated access during service startup.</description><pubDate>Sun, 01 Feb 2026 14:54:11 +0000</pubDate></item><item><title>CVE-2020-37061 | BOOTP Turbo 2.0.1214 - &amp;#x27;BOOTP Turbo&amp;#x27; Unquoted Service Path</title><link>https://www.cve.org/CVERecord?id=CVE-2020-37061</link><description>BOOTP Turbo 2.0.1214 contains an unquoted service path vulnerability that allows local attackers to potentially execute arbitrary code with elevated system privileges. Attackers can exploit the unquoted executable path to inject malicious code that will be executed when the service starts with LocalSystem permissions.</description><pubDate>Sun, 01 Feb 2026 14:54:12 +0000</pubDate></item><item><title>CVE-2020-37062 | DHCP Turbo 4.6.1298- &amp;#x27;DHCP Turbo 4&amp;#x27; Unquoted Service Path</title><link>https://www.cve.org/CVERecord?id=CVE-2020-37062</link><description>DHCP Turbo 4.61298 contains an unquoted service path vulnerability that allows local attackers to potentially execute arbitrary code by exploiting the service binary path. Attackers can place malicious executables in the service path to gain elevated privileges when the service starts.</description><pubDate>Sun, 01 Feb 2026 14:54:12 +0000</pubDate></item><item><title>CVE-2020-37063 | TFTP Turbo 4.6.1273 - &amp;#x27;TFTP Turbo 4&amp;#x27; Unquoted Service Path</title><link>https://www.cve.org/CVERecord?id=CVE-2020-37063</link><description>TFTP Turbo 4.6.1273 contains an unquoted service path vulnerability that allows local attackers to potentially execute arbitrary code with elevated privileges. Attackers can exploit the unquoted path in the service configuration to inject malicious executables that will be launched with LocalSystem permissions.</description><pubDate>Sun, 01 Feb 2026 14:54:12 +0000</pubDate></item><item><title>CVE-2020-37064 | EPSON EasyMP Network Projection 2.81 - &amp;#x27;EMP_NSWLSV&amp;#x27; Unquoted Service Path</title><link>https://www.cve.org/CVERecord?id=CVE-2020-37064</link><description>EPSON EasyMP Network Projection 2.81 contains an unquoted service path vulnerability in the EMP_NSWLSV service that allows local users to potentially execute arbitrary code. Attackers can exploit the unquoted path in C:\Program Files (x86)\EPSON Projector\EasyMP Network Projection V2\ to inject malicious code that would execute with LocalSystem privileges.</description><pubDate>Sun, 01 Feb 2026 14:54:13 +0000</pubDate></item><item><title>CVE-2021-47921 | Free Photo &amp;amp; Video Vault 0.0.2 Directory Traversal Vulnerability via Web Request</title><link>https://www.cve.org/CVERecord?id=CVE-2021-47921</link><description>Free Photo &amp; Video Vault 0.0.2 contains a directory traversal web vulnerability that allows remote attackers to manipulate application path requests and access sensitive system files. Attackers can exploit the vulnerability without privileges to retrieve environment variables and access unauthorized system paths.</description><pubDate>Sun, 01 Feb 2026 13:26:11 +0000</pubDate></item><item><title>CVE-2022-50950 | Webile 1.0.1 Directory Traversal Vulnerability via Web Application</title><link>https://www.cve.org/CVERecord?id=CVE-2022-50950</link><description>Webile 1.0.1 contains a directory traversal vulnerability that allows remote attackers to manipulate file system paths without authentication. Attackers can exploit path manipulation to access sensitive system directories and potentially compromise the mobile device's local file system.</description><pubDate>Sun, 01 Feb 2026 13:26:11 +0000</pubDate></item><item><title>CVE-2022-50951 | WiFi File Transfer 1.0.8 Persistent XSS via Web Server Input Validation</title><link>https://www.cve.org/CVERecord?id=CVE-2022-50951</link><description>WiFi File Transfer 1.0.8 contains a persistent cross-site scripting vulnerability that allows remote attackers to inject malicious script codes through file and folder names. Attackers can exploit the web server's input validation weakness to execute arbitrary JavaScript when users preview infected file paths, potentially compromising user browser sessions.</description><pubDate>Sun, 01 Feb 2026 13:26:11 +0000</pubDate></item><item><title>CVE-2022-50952 | Banco Guayaquil 8.0.0 Mobile iOS Cross-Site Scripting via Profile Name Input</title><link>https://www.cve.org/CVERecord?id=CVE-2022-50952</link><description>Banco Guayaquil 8.0.0 mobile iOS application contains a persistent cross-site scripting vulnerability in the TextBox Name Profile input. Attackers can inject malicious script code through a POST request that executes on application review without user interaction.</description><pubDate>Sun, 01 Feb 2026 13:26:12 +0000</pubDate></item><item><title>CVE-2023-54343 | QWE DL 2.0.1 Persistent XSS Vulnerability via Path Parameter</title><link>https://www.cve.org/CVERecord?id=CVE-2023-54343</link><description>QWE DL 2.0.1 mobile web application contains a persistent input validation vulnerability allowing remote attackers to inject malicious script code through path parameter manipulation. Attackers can exploit the vulnerability to execute persistent cross-site scripting attacks, potentially leading to session hijacking and application module manipulation.</description><pubDate>Sun, 01 Feb 2026 13:26:12 +0000</pubDate></item><item><title>CVE-2021-47856 | Easy Cart Shopping Cart 2021 Cross-Site Scripting via Search Parameter</title><link>https://www.cve.org/CVERecord?id=CVE-2021-47856</link><description>Easy Cart Shopping Cart 2021 contains a non-persistent cross-site scripting vulnerability in the search module's keyword parameter. Remote attackers can inject malicious script code through the search input to compromise user sessions and manipulate application content.</description><pubDate>Sun, 01 Feb 2026 12:28:33 +0000</pubDate></item><item><title>CVE-2021-47885 | Payment Terminal Multiple Versions Non-Persistent Cross-Site Scripting</title><link>https://www.cve.org/CVERecord?id=CVE-2021-47885</link><description>Multiple payment terminal versions contain non-persistent cross-site scripting vulnerabilities in billing and payment information input fields. Attackers can inject malicious script code through vulnerable parameters to manipulate client-side requests and potentially execute session hijacking or phishing attacks.</description><pubDate>Sun, 01 Feb 2026 12:28:33 +0000</pubDate></item><item><title>CVE-2021-47908 | Ultimate POS 4.4 Persistent Cross-Site Scripting via Product Name</title><link>https://www.cve.org/CVERecord?id=CVE-2021-47908</link><description>Ultimate POS 4.4 contains a persistent cross-site scripting vulnerability in the product name parameter that allows remote attackers to inject malicious scripts. Attackers can exploit the vulnerability through product add or edit functions to execute arbitrary JavaScript and potentially hijack user sessions.</description><pubDate>Sun, 01 Feb 2026 12:28:33 +0000</pubDate></item><item><title>CVE-2021-47909 | Mult-E-Cart Ultimate 2.4 SQL Injection via Vulnerable ID Parameters</title><link>https://www.cve.org/CVERecord?id=CVE-2021-47909</link><description>Mult-E-Cart Ultimate 2.4 contains multiple SQL injection vulnerabilities in inventory, customer, vendor, and order modules. Remote attackers with privileged vendor or admin roles can exploit the 'id' parameter to execute malicious SQL commands and compromise the database management system.</description><pubDate>Sun, 01 Feb 2026 12:28:33 +0000</pubDate></item><item><title>CVE-2021-47911 | Affiliate Pro 1.7 Reflected Cross-Site Scripting via Index Module</title><link>https://www.cve.org/CVERecord?id=CVE-2021-47911</link><description>Affiliate Pro 1.7 contains multiple reflected cross-site scripting vulnerabilities in the index module's input fields. Attackers can inject malicious scripts through fullname, username, and email parameters to execute client-side attacks and manipulate browser requests.</description><pubDate>Sun, 01 Feb 2026 12:28:34 +0000</pubDate></item><item><title>CVE-2021-47912 | PHP Melody 3.0 Non-Persistent Cross-Site Scripting via Multiple Parameters</title><link>https://www.cve.org/CVERecord?id=CVE-2021-47912</link><description>PHP Melody version 3.0 contains multiple non-persistent cross-site scripting vulnerabilities in categories, import, and user import files. Attackers can inject malicious scripts through unvalidated parameters to execute client-side attacks and potentially hijack user sessions.</description><pubDate>Sun, 01 Feb 2026 12:28:34 +0000</pubDate></item><item><title>CVE-2021-47913 | PHP Melody 3.0 Persistent Cross-Site Scripting via Video Editor</title><link>https://www.cve.org/CVERecord?id=CVE-2021-47913</link><description>PHP Melody 3.0 contains a persistent cross-site scripting vulnerability in the video editor that allows privileged users to inject malicious scripts. Attackers can exploit the WYSIWYG editor to execute persistent scripts, potentially leading to session hijacking and application manipulation.</description><pubDate>Sun, 01 Feb 2026 12:28:34 +0000</pubDate></item><item><title>CVE-2021-47914 | PHP Melody 3.0 Persistent XSS Vulnerability via Edit Video Parameter</title><link>https://www.cve.org/CVERecord?id=CVE-2021-47914</link><description>PHP Melody version 3.0 contains a persistent cross-site scripting vulnerability in the edit-video.php submitted parameter that allows remote attackers to inject malicious script code. Attackers can exploit this vulnerability to execute arbitrary JavaScript, potentially leading to session hijacking, persistent phishing, and manipulation of application modules.</description><pubDate>Sun, 01 Feb 2026 12:28:35 +0000</pubDate></item><item><title>CVE-2021-47915 | PHP Melody 3.0 SQL Injection Vulnerability via Edit Video Parameter</title><link>https://www.cve.org/CVERecord?id=CVE-2021-47915</link><description>PHP Melody version 3.0 contains a remote SQL injection vulnerability in the video edit module that allows authenticated attackers to inject malicious SQL commands. Attackers can exploit the unvalidated 'vid' parameter to execute arbitrary database queries and potentially compromise the web application and database management system.</description><pubDate>Sun, 01 Feb 2026 12:28:35 +0000</pubDate></item><item><title>CVE-2021-47916 | Simple CMS 2.1 SQL Injection Vulnerability via Users Module</title><link>https://www.cve.org/CVERecord?id=CVE-2021-47916</link><description>Simple CMS 2.1 contains a remote SQL injection vulnerability that allows privileged attackers to inject unfiltered SQL commands in the users module. Attackers can exploit unvalidated input parameters in the admin.php file to compromise the database management system and web application.</description><pubDate>Sun, 01 Feb 2026 12:28:35 +0000</pubDate></item><item><title>CVE-2021-47917 | Simple CMS 2.1 Persistent Cross-Site Scripting via User Input Parameters</title><link>https://www.cve.org/CVERecord?id=CVE-2021-47917</link><description>Simple CMS 2.1 contains a persistent cross-site scripting vulnerability in user input parameters that allows remote attackers to inject malicious script code. Attackers can exploit the newUser and editUser modules to inject persistent scripts that execute on user list preview, potentially leading to session hijacking and application manipulation.</description><pubDate>Sun, 01 Feb 2026 12:28:36 +0000</pubDate></item><item><title>CVE-2021-47918 | Simple CMS 2.1 SQL Injection Vulnerability via Users Module</title><link>https://www.cve.org/CVERecord?id=CVE-2021-47918</link><description>Simple CMS 2.1 contains a remote SQL injection vulnerability that allows privileged attackers to inject unfiltered SQL commands in the users module. Attackers can exploit unvalidated input parameters in the admin.php file to compromise the database management system and web application.</description><pubDate>Sun, 01 Feb 2026 12:28:36 +0000</pubDate></item><item><title>CVE-2021-47919 | Simple CMS 2.1 Non-Persistent Cross-Site Scripting via Preview Parameter</title><link>https://www.cve.org/CVERecord?id=CVE-2021-47919</link><description>Simple CMS 2.1 contains a non-persistent cross-site scripting vulnerability in the preview.php file's id parameter. Attackers can inject malicious script code through a GET request to execute arbitrary scripts and potentially hijack user sessions or perform phishing attacks.</description><pubDate>Sun, 01 Feb 2026 12:28:36 +0000</pubDate></item><item><title>CVE-2021-47920 | WebMO Job Manager 20.0 Cross-Site Scripting via Search Parameters</title><link>https://www.cve.org/CVERecord?id=CVE-2021-47920</link><description>WebMO Job Manager 20.0 contains a cross-site scripting vulnerability in search parameters that allows remote attackers to inject malicious script code. Attackers can exploit the filterSearch and filterSearchType parameters to perform non-persistent attacks including session hijacking and external redirects.</description><pubDate>Sun, 01 Feb 2026 12:28:37 +0000</pubDate></item><item><title>CVE-2022-50797 | Stripe Green Downloads Wordpress Plugin 2.03 Persistent XSS via Settings</title><link>https://www.cve.org/CVERecord?id=CVE-2022-50797</link><description>Stripe Green Downloads Wordpress Plugin 2.03 contains a persistent cross-site scripting vulnerability allowing remote attackers to inject malicious scripts in button label fields. Attackers can exploit input parameters to execute arbitrary scripts, potentially leading to session hijacking and application module manipulation.</description><pubDate>Sun, 01 Feb 2026 12:28:37 +0000</pubDate></item><item><title>CVE-2022-50940 | Knap Advanced PHP Login 3.1.3 Persistent Cross-Site Scripting via Name Parameter</title><link>https://www.cve.org/CVERecord?id=CVE-2022-50940</link><description>Knap Advanced PHP Login 3.1.3 contains a persistent cross-site scripting vulnerability that allows remote attackers to inject malicious script code in the name parameter. Attackers can exploit the vulnerability to execute arbitrary scripts in users and activity log backend modules, potentially leading to session hijacking and persistent phishing attacks.</description><pubDate>Sun, 01 Feb 2026 12:28:37 +0000</pubDate></item><item><title>CVE-2022-50941 | BootCommerce 3.2.1 Persistent Cross-Site Scripting via Order Checkout</title><link>https://www.cve.org/CVERecord?id=CVE-2022-50941</link><description>BootCommerce 3.2.1 contains persistent input validation vulnerabilities that allow remote attackers to inject malicious script code through guest order checkout input fields. Attackers can exploit unvalidated input parameters to execute arbitrary scripts, potentially leading to session hijacking, phishing attacks, and application module manipulation.</description><pubDate>Sun, 01 Feb 2026 12:28:38 +0000</pubDate></item><item><title>CVE-2022-50942 | Inciga Web 2.8.2 Client-Side Cross-Site Scripting via EventListener</title><link>https://www.cve.org/CVERecord?id=CVE-2022-50942</link><description>Inciga Web 2.8.2 contains a client-side cross-site scripting vulnerability that allows remote attackers to inject malicious script codes through the icinga.min.js file. Attackers can exploit the EventListener.handleEvent method to execute arbitrary scripts, potentially leading to session hijacking and non-persistent phishing attacks.</description><pubDate>Sun, 01 Feb 2026 12:28:38 +0000</pubDate></item><item><title>CVE-2026-25069 | SunFounder Pironman Dashboard &amp;lt;= 1.3.13 Path Traversal Arbitrary File Read/Deletion</title><link>https://www.cve.org/CVERecord?id=CVE-2026-25069</link><description>SunFounder Pironman Dashboard (pm_dashboard) version 1.3.13 and prior contain a path traversal vulnerability in the log file API endpoints. An unauthenticated remote attacker can supply traversal sequences via the filename parameter to read and delete arbitrary files. Successful exploitation can disclose sensitive information and delete critical system files, resulting in data loss and potential system compromise or denial of service.</description><pubDate>Sat, 31 Jan 2026 23:58:47 +0000</pubDate></item><item><title>CVE-2026-1165 | Popup Box &amp;lt;= 6.1.1 - Cross-Site Request Forgery to Popup Status Change</title><link>https://www.cve.org/CVERecord?id=CVE-2026-1165</link><description>The Popup Box plugin for WordPress is vulnerable to Cross-Site Request Forgery in all versions up to, and including, 6.1.1. This is due to a flawed nonce implementation in the 'publish_unpublish_popupbox' function that verifies a self-created nonce rather than one submitted in the request. This makes it possible for unauthenticated attackers to change the publish status of popups via a forged request, granted they can trick a site administrator into performing an action such as clicking a link.</description><pubDate>Sat, 31 Jan 2026 14:32:57 +0000</pubDate></item><item><title>CVE-2025-14554 | Sell BTC - Cryptocurrency Selling Calculator &amp;lt;= 1.5 - Unauthenticated Stored Cross-Site Scripting via &amp;#x27;orderform_data&amp;#x27; AJAX Action</title><link>https://www.cve.org/CVERecord?id=CVE-2025-14554</link><description>The Sell BTC - Cryptocurrency Selling Calculator plugin for WordPress is vulnerable to Stored Cross-Site Scripting via the 'orderform_data' AJAX action in all versions up to, and including, 1.5 due to insufficient input sanitization and output escaping. This makes it possible for unauthenticated attackers to inject arbitrary web scripts in order records that will execute whenever an administrator accesses the Orders page in the admin dashboard. The vulnerability was partially patched in version 1.5.</description><pubDate>Sat, 31 Jan 2026 14:00:29 +0000</pubDate></item><item><title>CVE-2025-71185 | dmaengine: ti: dma-crossbar: fix device leak on am335x route allocation</title><link>https://www.cve.org/CVERecord?id=CVE-2025-71185</link><description>In the Linux kernel, the following vulnerability has been resolved:

dmaengine: ti: dma-crossbar: fix device leak on am335x route allocation

Make sure to drop the reference taken when looking up the crossbar
platform device during am335x route allocation.</description><pubDate>Sat, 31 Jan 2026 11:49:03 +0000</pubDate></item><item><title>CVE-2025-71186 | dmaengine: stm32: dmamux: fix device leak on route allocation</title><link>https://www.cve.org/CVERecord?id=CVE-2025-71186</link><description>In the Linux kernel, the following vulnerability has been resolved:

dmaengine: stm32: dmamux: fix device leak on route allocation

Make sure to drop the reference taken when looking up the DMA mux
platform device during route allocation.

Note that holding a reference to a device does not prevent its driver
data from going away so there is no point in keeping the reference.</description><pubDate>Sat, 31 Jan 2026 11:49:04 +0000</pubDate></item><item><title>CVE-2025-71187 | dmaengine: sh: rz-dmac: fix device leak on probe failure</title><link>https://www.cve.org/CVERecord?id=CVE-2025-71187</link><description>In the Linux kernel, the following vulnerability has been resolved:

dmaengine: sh: rz-dmac: fix device leak on probe failure

Make sure to drop the reference taken when looking up the ICU device
during probe also on probe failures (e.g. probe deferral).</description><pubDate>Sat, 31 Jan 2026 11:49:04 +0000</pubDate></item><item><title>CVE-2025-71188 | dmaengine: lpc18xx-dmamux: fix device leak on route allocation</title><link>https://www.cve.org/CVERecord?id=CVE-2025-71188</link><description>In the Linux kernel, the following vulnerability has been resolved:

dmaengine: lpc18xx-dmamux: fix device leak on route allocation

Make sure to drop the reference taken when looking up the DMA mux
platform device during route allocation.

Note that holding a reference to a device does not prevent its driver
data from going away so there is no point in keeping the reference.</description><pubDate>Sat, 31 Jan 2026 11:49:04 +0000</pubDate></item><item><title>CVE-2025-71189 | dmaengine: dw: dmamux: fix OF node leak on route allocation failure</title><link>https://www.cve.org/CVERecord?id=CVE-2025-71189</link><description>In the Linux kernel, the following vulnerability has been resolved:

dmaengine: dw: dmamux: fix OF node leak on route allocation failure

Make sure to drop the reference taken to the DMA master OF node also on
late route allocation failures.</description><pubDate>Sat, 31 Jan 2026 11:49:05 +0000</pubDate></item><item><title>CVE-2025-71190 | dmaengine: bcm-sba-raid: fix device leak on probe</title><link>https://www.cve.org/CVERecord?id=CVE-2025-71190</link><description>In the Linux kernel, the following vulnerability has been resolved:

dmaengine: bcm-sba-raid: fix device leak on probe

Make sure to drop the reference taken when looking up the mailbox device
during probe on probe failures and on driver unbind.</description><pubDate>Sat, 31 Jan 2026 11:49:05 +0000</pubDate></item><item><title>CVE-2025-71191 | dmaengine: at_hdmac: fix device leak on of_dma_xlate()</title><link>https://www.cve.org/CVERecord?id=CVE-2025-71191</link><description>In the Linux kernel, the following vulnerability has been resolved:

dmaengine: at_hdmac: fix device leak on of_dma_xlate()

Make sure to drop the reference taken when looking up the DMA platform
device during of_dma_xlate() when releasing channel resources.

Note that commit 3832b78b3ec2 ("dmaengine: at_hdmac: add missing
put_device() call in at_dma_xlate()") fixed the leak in a couple of
error paths but the reference is still leaking on successful allocation.</description><pubDate>Sat, 31 Jan 2026 11:49:05 +0000</pubDate></item><item><title>CVE-2026-23025 | mm/page_alloc: prevent pcp corruption with SMP=n</title><link>https://www.cve.org/CVERecord?id=CVE-2026-23025</link><description>In the Linux kernel, the following vulnerability has been resolved:

mm/page_alloc: prevent pcp corruption with SMP=n

The kernel test robot has reported:

 BUG: spinlock trylock failure on UP on CPU#0, kcompactd0/28
  lock: 0xffff888807e35ef0, .magic: dead4ead, .owner: kcompactd0/28, .owner_cpu: 0
 CPU: 0 UID: 0 PID: 28 Comm: kcompactd0 Not tainted 6.18.0-rc5-00127-ga06157804399 #1 PREEMPT  8cc09ef94dcec767faa911515ce9e609c45db470
 Call Trace:
  
  __dump_stack (lib/dump_stack.c:95)
  dump_stack_lvl (lib/dump_stack.c:123)
  dump_stack (lib/dump_stack.c:130)
  spin_dump (kernel/locking/spinlock_debug.c:71)
  do_raw_spin_trylock (kernel/locking/spinlock_debug.c:?)
  _raw_spin_trylock (include/linux/spinlock_api_smp.h:89 kernel/locking/spinlock.c:138)
  __free_frozen_pages (mm/page_alloc.c:2973)
  ___free_pages (mm/page_alloc.c:5295)
  __free_pages (mm/page_alloc.c:5334)
  tlb_remove_table_rcu (include/linux/mm.h:? include/linux/mm.h:3122 include/asm-generic/tlb.h:220 mm/mmu_gather.c:227 mm/mmu_gather.c:290)
  ? __cfi_tlb_remove_table_rcu (mm/mmu_gather.c:289)
  ? rcu_core (kernel/rcu/tree.c:?)
  rcu_core (include/linux/rcupdate.h:341 kernel/rcu/tree.c:2607 kernel/rcu/tree.c:2861)
  rcu_core_si (kernel/rcu/tree.c:2879)
  handle_softirqs (arch/x86/include/asm/jump_label.h:36 include/trace/events/irq.h:142 kernel/softirq.c:623)
  __irq_exit_rcu (arch/x86/include/asm/jump_label.h:36 kernel/softirq.c:725)
  irq_exit_rcu (kernel/softirq.c:741)
  sysvec_apic_timer_interrupt (arch/x86/kernel/apic/apic.c:1052)
  
  
 RIP: 0010:_raw_spin_unlock_irqrestore (arch/x86/include/asm/preempt.h:95 include/linux/spinlock_api_smp.h:152 kernel/locking/spinlock.c:194)
  free_pcppages_bulk (mm/page_alloc.c:1494)
  drain_pages_zone (include/linux/spinlock.h:391 mm/page_alloc.c:2632)
  __drain_all_pages (mm/page_alloc.c:2731)
  drain_all_pages (mm/page_alloc.c:2747)
  kcompactd (mm/compaction.c:3115)
  kthread (kernel/kthread.c:465)
  ? __cfi_kcompactd (mm/compaction.c:3166)
  ? __cfi_kthread (kernel/kthread.c:412)
  ret_from_fork (arch/x86/kernel/process.c:164)
  ? __cfi_kthread (kernel/kthread.c:412)
  ret_from_fork_asm (arch/x86/entry/entry_64.S:255)
  

Matthew has analyzed the report and identified that in drain_page_zone()
we are in a section protected by spin_lock(&amp;amp;pcp-&gt;lock) and then get an
interrupt that attempts spin_trylock() on the same lock.  The code is
designed to work this way without disabling IRQs and occasionally fail the
trylock with a fallback.  However, the SMP=n spinlock implementation
assumes spin_trylock() will always succeed, and thus it's normally a
no-op.  Here the enabled lock debugging catches the problem, but otherwise
it could cause a corruption of the pcp structure.

The problem has been introduced by commit 574907741599 ("mm/page_alloc:
leave IRQs enabled for per-cpu page allocations").  The pcp locking scheme
recognizes the need for disabling IRQs to prevent nesting spin_trylock()
sections on SMP=n, but the need to prevent the nesting in spin_lock() has
not been recognized.  Fix it by introducing local wrappers that change the
spin_lock() to spin_lock_iqsave() with SMP=n and use them in all places
that do spin_lock(&amp;amp;pcp-&gt;lock).

[vbabka@suse.cz: add pcp_ prefix to the spin_lock_irqsave wrappers, per Steven]</description><pubDate>Sat, 31 Jan 2026 11:49:06 +0000</pubDate></item><item><title>CVE-2026-23026 | dmaengine: qcom: gpi: Fix memory leak in gpi_peripheral_config()</title><link>https://www.cve.org/CVERecord?id=CVE-2026-23026</link><description>In the Linux kernel, the following vulnerability has been resolved:

dmaengine: qcom: gpi: Fix memory leak in gpi_peripheral_config()

Fix a memory leak in gpi_peripheral_config() where the original memory
pointed to by gchan-&gt;config could be lost if krealloc() fails.

The issue occurs when:
1. gchan-&gt;config points to previously allocated memory
2. krealloc() fails and returns NULL
3. The function directly assigns NULL to gchan-&gt;config, losing the
   reference to the original memory
4. The original memory becomes unreachable and cannot be freed

Fix this by using a temporary variable to hold the krealloc() result
and only updating gchan-&gt;config when the allocation succeeds.

Found via static analysis and code review.</description><pubDate>Sat, 31 Jan 2026 11:49:06 +0000</pubDate></item><item><title>CVE-2026-23027 | LoongArch: KVM: Fix kvm_device leak in kvm_pch_pic_destroy()</title><link>https://www.cve.org/CVERecord?id=CVE-2026-23027</link><description>In the Linux kernel, the following vulnerability has been resolved:

LoongArch: KVM: Fix kvm_device leak in kvm_pch_pic_destroy()

In kvm_ioctl_create_device(), kvm_device has allocated memory,
kvm_device-&gt;destroy() seems to be supposed to free its kvm_device
struct, but kvm_pch_pic_destroy() is not currently doing this, that
would lead to a memory leak.

So, fix it.</description><pubDate>Sat, 31 Jan 2026 11:49:07 +0000</pubDate></item><item><title>CVE-2026-23028 | LoongArch: KVM: Fix kvm_device leak in kvm_ipi_destroy()</title><link>https://www.cve.org/CVERecord?id=CVE-2026-23028</link><description>In the Linux kernel, the following vulnerability has been resolved:

LoongArch: KVM: Fix kvm_device leak in kvm_ipi_destroy()

In kvm_ioctl_create_device(), kvm_device has allocated memory,
kvm_device-&gt;destroy() seems to be supposed to free its kvm_device
struct, but kvm_ipi_destroy() is not currently doing this, that
would lead to a memory leak.

So, fix it.</description><pubDate>Sat, 31 Jan 2026 11:49:07 +0000</pubDate></item><item><title>CVE-2026-23029 | LoongArch: KVM: Fix kvm_device leak in kvm_eiointc_destroy()</title><link>https://www.cve.org/CVERecord?id=CVE-2026-23029</link><description>In the Linux kernel, the following vulnerability has been resolved:

LoongArch: KVM: Fix kvm_device leak in kvm_eiointc_destroy()

In kvm_ioctl_create_device(), kvm_device has allocated memory,
kvm_device-&gt;destroy() seems to be supposed to free its kvm_device
struct, but kvm_eiointc_destroy() is not currently doing this, that
would lead to a memory leak.

So, fix it.</description><pubDate>Sat, 31 Jan 2026 11:49:07 +0000</pubDate></item><item><title>CVE-2026-23030 | phy: rockchip: inno-usb2: Fix a double free bug in rockchip_usb2phy_probe()</title><link>https://www.cve.org/CVERecord?id=CVE-2026-23030</link><description>In the Linux kernel, the following vulnerability has been resolved:

phy: rockchip: inno-usb2: Fix a double free bug in rockchip_usb2phy_probe()

The for_each_available_child_of_node() calls of_node_put() to
release child_np in each success loop. After breaking from the
loop with the child_np has been released, the code will jump to
the put_child label and will call the of_node_put() again if the
devm_request_threaded_irq() fails. These cause a double free bug.

Fix by returning directly to avoid the duplicate of_node_put().</description><pubDate>Sat, 31 Jan 2026 11:49:08 +0000</pubDate></item><item><title>CVE-2026-23031 | can: gs_usb: gs_usb_receive_bulk_callback(): fix URB memory leak</title><link>https://www.cve.org/CVERecord?id=CVE-2026-23031</link><description>In the Linux kernel, the following vulnerability has been resolved:

can: gs_usb: gs_usb_receive_bulk_callback(): fix URB memory leak

In gs_can_open(), the URBs for USB-in transfers are allocated, added to the
parent-&gt;rx_submitted anchor and submitted. In the complete callback
gs_usb_receive_bulk_callback(), the URB is processed and resubmitted. In
gs_can_close() the URBs are freed by calling
usb_kill_anchored_urbs(parent-&gt;rx_submitted).

However, this does not take into account that the USB framework unanchors
the URB before the complete function is called. This means that once an
in-URB has been completed, it is no longer anchored and is ultimately not
released in gs_can_close().

Fix the memory leak by anchoring the URB in the
gs_usb_receive_bulk_callback() to the parent-&gt;rx_submitted anchor.</description><pubDate>Sat, 31 Jan 2026 11:49:08 +0000</pubDate></item><item><title>CVE-2026-23032 | null_blk: fix kmemleak by releasing references to fault configfs items</title><link>https://www.cve.org/CVERecord?id=CVE-2026-23032</link><description>In the Linux kernel, the following vulnerability has been resolved:

null_blk: fix kmemleak by releasing references to fault configfs items

When CONFIG_BLK_DEV_NULL_BLK_FAULT_INJECTION is enabled, the null-blk
driver sets up fault injection support by creating the timeout_inject,
requeue_inject, and init_hctx_fault_inject configfs items as children
of the top-level nullbX configfs group.

However, when the nullbX device is removed, the references taken to
these fault-config configfs items are not released. As a result,
kmemleak reports a memory leak, for example:

unreferenced object 0xc00000021ff25c40 (size 32):
  comm "mkdir", pid 10665, jiffies 4322121578
  hex dump (first 32 bytes):
    69 6e 69 74 5f 68 63 74 78 5f 66 61 75 6c 74 5f  init_hctx_fault_
    69 6e 6a 65 63 74 00 88 00 00 00 00 00 00 00 00  inject..........
  backtrace (crc 1a018c86):
    __kmalloc_node_track_caller_noprof+0x494/0xbd8
    kvasprintf+0x74/0xf4
    config_item_set_name+0xf0/0x104
    config_group_init_type_name+0x48/0xfc
    fault_config_init+0x48/0xf0
    0xc0080000180559e4
    configfs_mkdir+0x304/0x814
    vfs_mkdir+0x49c/0x604
    do_mkdirat+0x314/0x3d0
    sys_mkdir+0xa0/0xd8
    system_call_exception+0x1b0/0x4f0
    system_call_vectored_common+0x15c/0x2ec

Fix this by explicitly releasing the references to the fault-config
configfs items when dropping the reference to the top-level nullbX
configfs group.</description><pubDate>Sat, 31 Jan 2026 11:49:08 +0000</pubDate></item><item><title>CVE-2026-23033 | dmaengine: omap-dma: fix dma_pool resource leak in error paths</title><link>https://www.cve.org/CVERecord?id=CVE-2026-23033</link><description>In the Linux kernel, the following vulnerability has been resolved:

dmaengine: omap-dma: fix dma_pool resource leak in error paths

The dma_pool created by dma_pool_create() is not destroyed when
dma_async_device_register() or of_dma_controller_register() fails,
causing a resource leak in the probe error paths.

Add dma_pool_destroy() in both error paths to properly release the
allocated dma_pool resource.</description><pubDate>Sat, 31 Jan 2026 11:49:09 +0000</pubDate></item><item><title>CVE-2026-23034 | drm/amdgpu/userq: Fix fence reference leak on queue teardown v2</title><link>https://www.cve.org/CVERecord?id=CVE-2026-23034</link><description>In the Linux kernel, the following vulnerability has been resolved:

drm/amdgpu/userq: Fix fence reference leak on queue teardown v2

The user mode queue keeps a pointer to the most recent fence in
userq-&gt;last_fence. This pointer holds an extra dma_fence reference.

When the queue is destroyed, we free the fence driver and its xarray,
but we forgot to drop the last_fence reference.

Because of the missing dma_fence_put(), the last fence object can stay
alive when the driver unloads. This leaves an allocated object in the
amdgpu_userq_fence slab cache and triggers

This is visible during driver unload as:

  BUG amdgpu_userq_fence: Objects remaining on __kmem_cache_shutdown()
  kmem_cache_destroy amdgpu_userq_fence: Slab cache still has objects
  Call Trace:
    kmem_cache_destroy
    amdgpu_userq_fence_slab_fini
    amdgpu_exit
    __do_sys_delete_module

Fix this by putting userq-&gt;last_fence and clearing the pointer during
amdgpu_userq_fence_driver_free().

This makes sure the fence reference is released and the slab cache is
empty when the module exits.

v2: Update to only release userq-&gt;last_fence with dma_fence_put()
    (Christian)

(cherry picked from commit 8e051e38a8d45caf6a866d4ff842105b577953bb)</description><pubDate>Sat, 31 Jan 2026 11:49:09 +0000</pubDate></item><item><title>CVE-2026-23035 | net/mlx5e: Pass netdev to mlx5e_destroy_netdev instead of priv</title><link>https://www.cve.org/CVERecord?id=CVE-2026-23035</link><description>In the Linux kernel, the following vulnerability has been resolved:

net/mlx5e: Pass netdev to mlx5e_destroy_netdev instead of priv

mlx5e_priv is an unstable structure that can be memset(0) if profile
attaching fails.

Pass netdev to mlx5e_destroy_netdev() to guarantee it will work on a
valid netdev.

On mlx5e_remove: Check validity of priv-&gt;profile, before attempting
to cleanup any resources that might be not there.

This fixes a kernel oops in mlx5e_remove when switchdev mode fails due
to change profile failure.

$ devlink dev eswitch set pci/0000:00:03.0 mode switchdev
Error: mlx5_core: Failed setting eswitch to offloads.
dmesg:
workqueue: Failed to create a rescuer kthread for wq "mlx5e": -EINTR
mlx5_core 0012:03:00.1: mlx5e_netdev_init_profile:6214:(pid 37199): mlx5e_priv_init failed, err=-12
mlx5_core 0012:03:00.1 gpu3rdma1: mlx5e_netdev_change_profile: new profile init failed, -12
workqueue: Failed to create a rescuer kthread for wq "mlx5e": -EINTR
mlx5_core 0012:03:00.1: mlx5e_netdev_init_profile:6214:(pid 37199): mlx5e_priv_init failed, err=-12
mlx5_core 0012:03:00.1 gpu3rdma1: mlx5e_netdev_change_profile: failed to rollback to orig profile, -12

$ devlink dev reload pci/0000:00:03.0 ==&gt; oops

BUG: kernel NULL pointer dereference, address: 0000000000000370
PGD 0 P4D 0
Oops: Oops: 0000 [#1] SMP NOPTI
CPU: 15 UID: 0 PID: 520 Comm: devlink Not tainted 6.18.0-rc5+ #115 PREEMPT(voluntary)
Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.3-2.fc40 04/01/2014
RIP: 0010:mlx5e_dcbnl_dscp_app+0x23/0x100
RSP: 0018:ffffc9000083f8b8 EFLAGS: 00010286
RAX: ffff8881126fc380 RBX: ffff8881015ac400 RCX: ffffffff826ffc45
RDX: 0000000000000000 RSI: 0000000000000001 RDI: ffff8881035109c0
RBP: ffff8881035109c0 R08: ffff888101e3e838 R09: ffff888100264e10
R10: ffffc9000083f898 R11: ffffc9000083f8a0 R12: ffff888101b921a0
R13: ffff888101b921a0 R14: ffff8881015ac9a0 R15: ffff8881015ac400
FS:  00007f789a3c8740(0000) GS:ffff88856aa59000(0000) knlGS:0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 0000000000000370 CR3: 000000010b6c0001 CR4: 0000000000370ef0
Call Trace:
 
 mlx5e_remove+0x57/0x110
 device_release_driver_internal+0x19c/0x200
 bus_remove_device+0xc6/0x130
 device_del+0x160/0x3d0
 ? devl_param_driverinit_value_get+0x2d/0x90
 mlx5_detach_device+0x89/0xe0
 mlx5_unload_one_devl_locked+0x3a/0x70
 mlx5_devlink_reload_down+0xc8/0x220
 devlink_reload+0x7d/0x260
 devlink_nl_reload_doit+0x45b/0x5a0
 genl_family_rcv_msg_doit+0xe8/0x140</description><pubDate>Sat, 31 Jan 2026 11:49:09 +0000</pubDate></item><item><title>CVE-2026-23036 | btrfs: release path before iget_failed() in btrfs_read_locked_inode()</title><link>https://www.cve.org/CVERecord?id=CVE-2026-23036</link><description>In the Linux kernel, the following vulnerability has been resolved:

btrfs: release path before iget_failed() in btrfs_read_locked_inode()

In btrfs_read_locked_inode() if we fail to lookup the inode, we jump to
the 'out' label with a path that has a read locked leaf and then we call
iget_failed(). This can result in a ABBA deadlock, since iget_failed()
triggers inode eviction and that causes the release of the delayed inode,
which must lock the delayed inode's mutex, and a task updating a delayed
inode starts by taking the node's mutex and then modifying the inode's
subvolume btree.

Syzbot reported the following lockdep splat for this:

   ======================================================
   WARNING: possible circular locking dependency detected
   syzkaller #0 Not tainted
   ------------------------------------------------------
   btrfs-cleaner/8725 is trying to acquire lock:
   ffff0000d6826a48 (&amp;amp;delayed_node-&gt;mutex){+.+.}-{4:4}, at: __btrfs_release_delayed_node+0xa0/0x9b0 fs/btrfs/delayed-inode.c:290

   but task is already holding lock:
   ffff0000dbeba878 (btrfs-tree-00){++++}-{4:4}, at: btrfs_tree_read_lock_nested+0x44/0x2ec fs/btrfs/locking.c:145

   which lock already depends on the new lock.

   the existing dependency chain (in reverse order) is:

   -&gt; #1 (btrfs-tree-00){++++}-{4:4}:
          __lock_release kernel/locking/lockdep.c:5574 [inline]
          lock_release+0x198/0x39c kernel/locking/lockdep.c:5889
          up_read+0x24/0x3c kernel/locking/rwsem.c:1632
          btrfs_tree_read_unlock+0xdc/0x298 fs/btrfs/locking.c:169
          btrfs_tree_unlock_rw fs/btrfs/locking.h:218 [inline]
          btrfs_search_slot+0xa6c/0x223c fs/btrfs/ctree.c:2133
          btrfs_lookup_inode+0xd8/0x38c fs/btrfs/inode-item.c:395
          __btrfs_update_delayed_inode+0x124/0xed0 fs/btrfs/delayed-inode.c:1032
          btrfs_update_delayed_inode fs/btrfs/delayed-inode.c:1118 [inline]
          __btrfs_commit_inode_delayed_items+0x15f8/0x1748 fs/btrfs/delayed-inode.c:1141
          __btrfs_run_delayed_items+0x1ac/0x514 fs/btrfs/delayed-inode.c:1176
          btrfs_run_delayed_items_nr+0x28/0x38 fs/btrfs/delayed-inode.c:1219
          flush_space+0x26c/0xb68 fs/btrfs/space-info.c:828
          do_async_reclaim_metadata_space+0x110/0x364 fs/btrfs/space-info.c:1158
          btrfs_async_reclaim_metadata_space+0x90/0xd8 fs/btrfs/space-info.c:1226
          process_one_work+0x7e8/0x155c kernel/workqueue.c:3263
          process_scheduled_works kernel/workqueue.c:3346 [inline]
          worker_thread+0x958/0xed8 kernel/workqueue.c:3427
          kthread+0x5fc/0x75c kernel/kthread.c:463
          ret_from_fork+0x10/0x20 arch/arm64/kernel/entry.S:844

   -&gt; #0 (&amp;amp;delayed_node-&gt;mutex){+.+.}-{4:4}:
          check_prev_add kernel/locking/lockdep.c:3165 [inline]
          check_prevs_add kernel/locking/lockdep.c:3284 [inline]
          validate_chain kernel/locking/lockdep.c:3908 [inline]
          __lock_acquire+0x1774/0x30a4 kernel/locking/lockdep.c:5237
          lock_acquire+0x14c/0x2e0 kernel/locking/lockdep.c:5868
          __mutex_lock_common+0x1d0/0x2678 kernel/locking/mutex.c:598
          __mutex_lock kernel/locking/mutex.c:760 [inline]
          mutex_lock_nested+0x2c/0x38 kernel/locking/mutex.c:812
          __btrfs_release_delayed_node+0xa0/0x9b0 fs/btrfs/delayed-inode.c:290
          btrfs_release_delayed_node fs/btrfs/delayed-inode.c:315 [inline]
          btrfs_remove_delayed_node+0x68/0x84 fs/btrfs/delayed-inode.c:1326
          btrfs_evict_inode+0x578/0xe28 fs/btrfs/inode.c:5587
          evict+0x414/0x928 fs/inode.c:810
          iput_final fs/inode.c:1914 [inline]
          iput+0x95c/0xad4 fs/inode.c:1966
          iget_failed+0xec/0x134 fs/bad_inode.c:248
          btrfs_read_locked_inode+0xe1c/0x1234 fs/btrfs/inode.c:4101
          btrfs_iget+0x1b0/0x264 fs/btrfs/inode.c:5837
          btrfs_run_defrag_inode fs/btrfs/defrag.c:237 [inline]
          btrfs_run_defrag_inodes+0x520/0xdc4 fs/btrf
---truncated---</description><pubDate>Sat, 31 Jan 2026 11:49:10 +0000</pubDate></item><item><title>CVE-2026-23037 | can: etas_es58x: allow partial RX URB allocation to succeed</title><link>https://www.cve.org/CVERecord?id=CVE-2026-23037</link><description>In the Linux kernel, the following vulnerability has been resolved:

can: etas_es58x: allow partial RX URB allocation to succeed

When es58x_alloc_rx_urbs() fails to allocate the requested number of
URBs but succeeds in allocating some, it returns an error code.
This causes es58x_open() to return early, skipping the cleanup label
'free_urbs', which leads to the anchored URBs being leaked.

As pointed out by maintainer Vincent Mailhol, the driver is designed
to handle partial URB allocation gracefully. Therefore, partial
allocation should not be treated as a fatal error.

Modify es58x_alloc_rx_urbs() to return 0 if at least one URB has been
allocated, restoring the intended behavior and preventing the leak
in es58x_open().</description><pubDate>Sat, 31 Jan 2026 11:49:10 +0000</pubDate></item><item><title>CVE-2026-23038 | pnfs/flexfiles: Fix memory leak in nfs4_ff_alloc_deviceid_node()</title><link>https://www.cve.org/CVERecord?id=CVE-2026-23038</link><description>In the Linux kernel, the following vulnerability has been resolved:

pnfs/flexfiles: Fix memory leak in nfs4_ff_alloc_deviceid_node()

In nfs4_ff_alloc_deviceid_node(), if the allocation for ds_versions fails,
the function jumps to the out_scratch label without freeing the already
allocated dsaddrs list, leading to a memory leak.

Fix this by jumping to the out_err_drain_dsaddrs label, which properly
frees the dsaddrs list before cleaning up other resources.</description><pubDate>Sat, 31 Jan 2026 11:49:11 +0000</pubDate></item><item><title>CVE-2026-23039 | drm/gud: fix NULL fb and crtc dereferences on USB disconnect</title><link>https://www.cve.org/CVERecord?id=CVE-2026-23039</link><description>In the Linux kernel, the following vulnerability has been resolved:

drm/gud: fix NULL fb and crtc dereferences on USB disconnect

On disconnect drm_atomic_helper_disable_all() is called which
sets both the fb and crtc for a plane to NULL before invoking a commit.

This causes a kernel oops on every display disconnect.

Add guards for those dereferences.</description><pubDate>Sat, 31 Jan 2026 11:49:11 +0000</pubDate></item><item><title>CVE-2025-71180 | counter: interrupt-cnt: Drop IRQF_NO_THREAD flag</title><link>https://www.cve.org/CVERecord?id=CVE-2025-71180</link><description>In the Linux kernel, the following vulnerability has been resolved:

counter: interrupt-cnt: Drop IRQF_NO_THREAD flag

An IRQ handler can either be IRQF_NO_THREAD or acquire spinlock_t, as
CONFIG_PROVE_RAW_LOCK_NESTING warns:
=============================
[ BUG: Invalid wait context ]
6.18.0-rc1+git... #1
-----------------------------
some-user-space-process/1251 is trying to lock:
(&amp;amp;counter-&gt;events_list_lock){....}-{3:3}, at: counter_push_event [counter]
other info that might help us debug this:
context-{2:2}
no locks held by some-user-space-process/....
stack backtrace:
CPU: 0 UID: 0 PID: 1251 Comm: some-user-space-process 6.18.0-rc1+git... #1 PREEMPT
Call trace:
 show_stack (C)
 dump_stack_lvl
 dump_stack
 __lock_acquire
 lock_acquire
 _raw_spin_lock_irqsave
 counter_push_event [counter]
 interrupt_cnt_isr [interrupt_cnt]
 __handle_irq_event_percpu
 handle_irq_event
 handle_simple_irq
 handle_irq_desc
 generic_handle_domain_irq
 gpio_irq_handler
 handle_irq_desc
 generic_handle_domain_irq
 gic_handle_irq
 call_on_irq_stack
 do_interrupt_handler
 el0_interrupt
 __el0_irq_handler_common
 el0t_64_irq_handler
 el0t_64_irq

... and Sebastian correctly points out. Remove IRQF_NO_THREAD as an
alternative to switching to raw_spinlock_t, because the latter would limit
all potential nested locks to raw_spinlock_t only.</description><pubDate>Sat, 31 Jan 2026 11:49:12 +0000</pubDate></item><item><title>CVE-2025-71181 | rust_binder: remove spin_lock() in rust_shrink_free_page()</title><link>https://www.cve.org/CVERecord?id=CVE-2025-71181</link><description>In the Linux kernel, the following vulnerability has been resolved:

rust_binder: remove spin_lock() in rust_shrink_free_page()

When forward-porting Rust Binder to 6.18, I neglected to take commit
fb56fdf8b9a2 ("mm/list_lru: split the lock to per-cgroup scope") into
account, and apparently I did not end up running the shrinker callback
when I sanity tested the driver before submission. This leads to crashes
like the following:

	============================================
	WARNING: possible recursive locking detected
	6.18.0-mainline-maybe-dirty #1 Tainted: G          IO
	--------------------------------------------
	kswapd0/68 is trying to acquire lock:
	ffff956000fa18b0 (&amp;amp;l-&gt;lock){+.+.}-{2:2}, at: lock_list_lru_of_memcg+0x128/0x230

	but task is already holding lock:
	ffff956000fa18b0 (&amp;amp;l-&gt;lock){+.+.}-{2:2}, at: rust_helper_spin_lock+0xd/0x20

	other info that might help us debug this:
	 Possible unsafe locking scenario:

	       CPU0
	       ----
	  lock(&amp;amp;l-&gt;lock);
	  lock(&amp;amp;l-&gt;lock);

	 *** DEADLOCK ***

	 May be due to missing lock nesting notation

	3 locks held by kswapd0/68:
	 #0: ffffffff90d2e260 (fs_reclaim){+.+.}-{0:0}, at: kswapd+0x597/0x1160
	 #1: ffff956000fa18b0 (&amp;amp;l-&gt;lock){+.+.}-{2:2}, at: rust_helper_spin_lock+0xd/0x20
	 #2: ffffffff90cf3680 (rcu_read_lock){....}-{1:2}, at: lock_list_lru_of_memcg+0x2d/0x230

To fix this, remove the spin_lock() call from rust_shrink_free_page().</description><pubDate>Sat, 31 Jan 2026 11:49:12 +0000</pubDate></item><item><title>CVE-2025-71182 | can: j1939: make j1939_session_activate() fail if device is no longer registered</title><link>https://www.cve.org/CVERecord?id=CVE-2025-71182</link><description>In the Linux kernel, the following vulnerability has been resolved:

can: j1939: make j1939_session_activate() fail if device is no longer registered

syzbot is still reporting

  unregister_netdevice: waiting for vcan0 to become free. Usage count = 2

even after commit 93a27b5891b8 ("can: j1939: add missing calls in
NETDEV_UNREGISTER notification handler") was added. A debug printk() patch
found that j1939_session_activate() can succeed even after
j1939_cancel_active_session() from j1939_netdev_notify(NETDEV_UNREGISTER)
has completed.

Since j1939_cancel_active_session() is processed with the session list lock
held, checking ndev-&gt;reg_state in j1939_session_activate() with the session
list lock held can reliably close the race window.</description><pubDate>Sat, 31 Jan 2026 11:49:12 +0000</pubDate></item><item><title>CVE-2025-71183 | btrfs: always detect conflicting inodes when logging inode refs</title><link>https://www.cve.org/CVERecord?id=CVE-2025-71183</link><description>In the Linux kernel, the following vulnerability has been resolved:

btrfs: always detect conflicting inodes when logging inode refs

After rename exchanging (either with the rename exchange operation or
regular renames in multiple non-atomic steps) two inodes and at least
one of them is a directory, we can end up with a log tree that contains
only of the inodes and after a power failure that can result in an attempt
to delete the other inode when it should not because it was not deleted
before the power failure. In some case that delete attempt fails when
the target inode is a directory that contains a subvolume inside it, since
the log replay code is not prepared to deal with directory entries that
point to root items (only inode items).

1) We have directories "dir1" (inode A) and "dir2" (inode B) under the
   same parent directory;

2) We have a file (inode C) under directory "dir1" (inode A);

3) We have a subvolume inside directory "dir2" (inode B);

4) All these inodes were persisted in a past transaction and we are
   currently at transaction N;

5) We rename the file (inode C), so at btrfs_log_new_name() we update
   inode C's last_unlink_trans to N;

6) We get a rename exchange for "dir1" (inode A) and "dir2" (inode B),
   so after the exchange "dir1" is inode B and "dir2" is inode A.
   During the rename exchange we call btrfs_log_new_name() for inodes
   A and B, but because they are directories, we don't update their
   last_unlink_trans to N;

7) An fsync against the file (inode C) is done, and because its inode
   has a last_unlink_trans with a value of N we log its parent directory
   (inode A) (through btrfs_log_all_parents(), called from
   btrfs_log_inode_parent()).

8) So we end up with inode B not logged, which now has the old name
   of inode A. At copy_inode_items_to_log(), when logging inode A, we
   did not check if we had any conflicting inode to log because inode
   A has a generation lower than the current transaction (created in
   a past transaction);

9) After a power failure, when replaying the log tree, since we find that
   inode A has a new name that conflicts with the name of inode B in the
   fs tree, we attempt to delete inode B... this is wrong since that
   directory was never deleted before the power failure, and because there
   is a subvolume inside that directory, attempting to delete it will fail
   since replay_dir_deletes() and btrfs_unlink_inode() are not prepared
   to deal with dir items that point to roots instead of inodes.

   When that happens the mount fails and we get a stack trace like the
   following:

   [87.2314] BTRFS info (device dm-0): start tree-log replay
   [87.2318] BTRFS critical (device dm-0): failed to delete reference to subvol, root 5 inode 256 parent 259
   [87.2332] ------------[ cut here ]------------
   [87.2338] BTRFS: Transaction aborted (error -2)
   [87.2346] WARNING: CPU: 1 PID: 638968 at fs/btrfs/inode.c:4345 __btrfs_unlink_inode+0x416/0x440 [btrfs]
   [87.2368] Modules linked in: btrfs loop dm_thin_pool (...)
   [87.2470] CPU: 1 UID: 0 PID: 638968 Comm: mount Tainted: G        W           6.18.0-rc7-btrfs-next-218+ #2 PREEMPT(full)
   [87.2489] Tainted: [W]=WARN
   [87.2494] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.16.2-0-gea1b7a073390-prebuilt.qemu.org 04/01/2014
   [87.2514] RIP: 0010:__btrfs_unlink_inode+0x416/0x440 [btrfs]
   [87.2538] Code: c0 89 04 24 (...)
   [87.2568] RSP: 0018:ffffc0e741f4b9b8 EFLAGS: 00010286
   [87.2574] RAX: 0000000000000000 RBX: ffff9d3ec8a6cf60 RCX: 0000000000000000
   [87.2582] RDX: 0000000000000002 RSI: ffffffff84ab45a1 RDI: 00000000ffffffff
   [87.2591] RBP: ffff9d3ec8a6ef20 R08: 0000000000000000 R09: ffffc0e741f4b840
   [87.2599] R10: ffff9d45dc1fffa8 R11: 0000000000000003 R12: ffff9d3ee26d77e0
   [87.2608] R13: ffffc0e741f4ba98 R14: ffff9d4458040800 R15: ffff9d44b6b7ca10
   [87.2618] FS:  00007f7b9603a840(0000) GS:ffff9d4658982000(0000) knlGS:0000000000000000
   [87.
---truncated---</description><pubDate>Sat, 31 Jan 2026 11:49:13 +0000</pubDate></item><item><title>CVE-2025-71184 | btrfs: fix NULL dereference on root when tracing inode eviction</title><link>https://www.cve.org/CVERecord?id=CVE-2025-71184</link><description>In the Linux kernel, the following vulnerability has been resolved:

btrfs: fix NULL dereference on root when tracing inode eviction

When evicting an inode the first thing we do is to setup tracing for it,
which implies fetching the root's id. But in btrfs_evict_inode() the
root might be NULL, as implied in the next check that we do in
btrfs_evict_inode().

Hence, we either should set the -&gt;root_objectid to 0 in case the root is
NULL, or we move tracing setup after checking that the root is not
NULL. Setting the rootid to 0 at least gives us the possibility to trace
this call even in the case when the root is NULL, so that's the solution
taken here.</description><pubDate>Sat, 31 Jan 2026 11:49:13 +0000</pubDate></item><item><title>CVE-2026-23015 | gpio: mpsse: fix reference leak in gpio_mpsse_probe() error paths</title><link>https://www.cve.org/CVERecord?id=CVE-2026-23015</link><description>In the Linux kernel, the following vulnerability has been resolved:

gpio: mpsse: fix reference leak in gpio_mpsse_probe() error paths

The reference obtained by calling usb_get_dev() is not released in the
gpio_mpsse_probe() error paths. Fix that by using device managed helper
functions. Also remove the usb_put_dev() call in the disconnect function
since now it will be released automatically.</description><pubDate>Sat, 31 Jan 2026 11:49:14 +0000</pubDate></item><item><title>CVE-2026-23016 | inet: frags: drop fraglist conntrack references</title><link>https://www.cve.org/CVERecord?id=CVE-2026-23016</link><description>In the Linux kernel, the following vulnerability has been resolved:

inet: frags: drop fraglist conntrack references

Jakub added a warning in nf_conntrack_cleanup_net_list() to make debugging
leaked skbs/conntrack references more obvious.

syzbot reports this as triggering, and I can also reproduce this via
ip_defrag.sh selftest:

 conntrack cleanup blocked for 60s
 WARNING: net/netfilter/nf_conntrack_core.c:2512
 [..]

conntrack clenups gets stuck because there are skbs with still hold nf_conn
references via their frag_list.

   net.core.skb_defer_max=0 makes the hang disappear.

Eric Dumazet points out that skb_release_head_state() doesn't follow the
fraglist.

ip_defrag.sh can only reproduce this problem since
commit 6471658dc66c ("udp: use skb_attempt_defer_free()"), but AFAICS this
problem could happen with TCP as well if pmtu discovery is off.

The relevant problem path for udp is:
1. netns emits fragmented packets
2. nf_defrag_v6_hook reassembles them (in output hook)
3. reassembled skb is tracked (skb owns nf_conn reference)
4. ip6_output refragments
5. refragmented packets also own nf_conn reference (ip6_fragment
   calls ip6_copy_metadata())
6. on input path, nf_defrag_v6_hook skips defragmentation: the
   fragments already have skb-&gt;nf_conn attached
7. skbs are reassembled via ipv6_frag_rcv()
8. skb_consume_udp -&gt; skb_attempt_defer_free() -&gt; skb ends up
   in pcpu freelist, but still has nf_conn reference.

Possible solutions:
 1 let defrag engine drop nf_conn entry, OR
 2 export kick_defer_list_purge() and call it from the conntrack
   netns exit callback, OR
 3 add skb_has_frag_list() check to skb_attempt_defer_free()

2 &amp; 3 also solve ip_defrag.sh hang but share same drawback:

Such reassembled skbs, queued to socket, can prevent conntrack module
removal until userspace has consumed the packet. While both tcp and udp
stack do call nf_reset_ct() before placing skb on socket queue, that
function doesn't iterate frag_list skbs.

Therefore drop nf_conn entries when they are placed in defrag queue.
Keep the nf_conn entry of the first (offset 0) skb so that reassembled
skb retains nf_conn entry for sake of TX path.

Note that fixes tag is incorrect; it points to the commit introducing the
'ip_defrag.sh reproducible problem': no need to backport this patch to
every stable kernel.</description><pubDate>Sat, 31 Jan 2026 11:49:14 +0000</pubDate></item><item><title>CVE-2026-23017 | idpf: fix error handling in the init_task on load</title><link>https://www.cve.org/CVERecord?id=CVE-2026-23017</link><description>In the Linux kernel, the following vulnerability has been resolved:

idpf: fix error handling in the init_task on load

If the init_task fails during a driver load, we end up without vports and
netdevs, effectively failing the entire process. In that state a
subsequent reset will result in a crash as the service task attempts to
access uninitialized resources. Following trace is from an error in the
init_task where the CREATE_VPORT (op 501) is rejected by the FW:

[40922.763136] idpf 0000:83:00.0: Device HW Reset initiated
[40924.449797] idpf 0000:83:00.0: Transaction failed (op 501)
[40958.148190] idpf 0000:83:00.0: HW reset detected
[40958.161202] BUG: kernel NULL pointer dereference, address: 00000000000000a8
...
[40958.168094] Workqueue: idpf-0000:83:00.0-vc_event idpf_vc_event_task [idpf]
[40958.168865] RIP: 0010:idpf_vc_event_task+0x9b/0x350 [idpf]
...
[40958.177932] Call Trace:
[40958.178491]  
[40958.179040]  process_one_work+0x226/0x6d0
[40958.179609]  worker_thread+0x19e/0x340
[40958.180158]  ? __pfx_worker_thread+0x10/0x10
[40958.180702]  kthread+0x10f/0x250
[40958.181238]  ? __pfx_kthread+0x10/0x10
[40958.181774]  ret_from_fork+0x251/0x2b0
[40958.182307]  ? __pfx_kthread+0x10/0x10
[40958.182834]  ret_from_fork_asm+0x1a/0x30
[40958.183370]  

Fix the error handling in the init_task to make sure the service and
mailbox tasks are disabled if the error happens during load. These are
started in idpf_vc_core_init(), which spawns the init_task and has no way
of knowing if it failed. If the error happens on reset, following
successful driver load, the tasks can still run, as that will allow the
netdevs to attempt recovery through another reset. Stop the PTP callbacks
either way as those will be restarted by the call to idpf_vc_core_init()
during a successful reset.</description><pubDate>Sat, 31 Jan 2026 11:49:14 +0000</pubDate></item><item><title>CVE-2026-23018 | btrfs: release path before initializing extent tree in btrfs_read_locked_inode()</title><link>https://www.cve.org/CVERecord?id=CVE-2026-23018</link><description>In the Linux kernel, the following vulnerability has been resolved:

btrfs: release path before initializing extent tree in btrfs_read_locked_inode()

In btrfs_read_locked_inode() we are calling btrfs_init_file_extent_tree()
while holding a path with a read locked leaf from a subvolume tree, and
btrfs_init_file_extent_tree() may do a GFP_KERNEL allocation, which can
trigger reclaim.

This can create a circular lock dependency which lockdep warns about with
the following splat:

   [6.1433] ======================================================
   [6.1574] WARNING: possible circular locking dependency detected
   [6.1583] 6.18.0+ #4 Tainted: G     U
   [6.1591] ------------------------------------------------------
   [6.1599] kswapd0/117 is trying to acquire lock:
   [6.1606] ffff8d9b6333c5b8 (&amp;amp;delayed_node-&gt;mutex){+.+.}-{3:3}, at: __btrfs_release_delayed_node.part.0+0x39/0x2f0
   [6.1625]
            but task is already holding lock:
   [6.1633] ffffffffa4ab8ce0 (fs_reclaim){+.+.}-{0:0}, at: balance_pgdat+0x195/0xc60
   [6.1646]
            which lock already depends on the new lock.

   [6.1657]
            the existing dependency chain (in reverse order) is:
   [6.1667]
            -&gt; #2 (fs_reclaim){+.+.}-{0:0}:
   [6.1677]        fs_reclaim_acquire+0x9d/0xd0
   [6.1685]        __kmalloc_cache_noprof+0x59/0x750
   [6.1694]        btrfs_init_file_extent_tree+0x90/0x100
   [6.1702]        btrfs_read_locked_inode+0xc3/0x6b0
   [6.1710]        btrfs_iget+0xbb/0xf0
   [6.1716]        btrfs_lookup_dentry+0x3c5/0x8e0
   [6.1724]        btrfs_lookup+0x12/0x30
   [6.1731]        lookup_open.isra.0+0x1aa/0x6a0
   [6.1739]        path_openat+0x5f7/0xc60
   [6.1746]        do_filp_open+0xd6/0x180
   [6.1753]        do_sys_openat2+0x8b/0xe0
   [6.1760]        __x64_sys_openat+0x54/0xa0
   [6.1768]        do_syscall_64+0x97/0x3e0
   [6.1776]        entry_SYSCALL_64_after_hwframe+0x76/0x7e
   [6.1784]
            -&gt; #1 (btrfs-tree-00){++++}-{3:3}:
   [6.1794]        lock_release+0x127/0x2a0
   [6.1801]        up_read+0x1b/0x30
   [6.1808]        btrfs_search_slot+0x8e0/0xff0
   [6.1817]        btrfs_lookup_inode+0x52/0xd0
   [6.1825]        __btrfs_update_delayed_inode+0x73/0x520
   [6.1833]        btrfs_commit_inode_delayed_inode+0x11a/0x120
   [6.1842]        btrfs_log_inode+0x608/0x1aa0
   [6.1849]        btrfs_log_inode_parent+0x249/0xf80
   [6.1857]        btrfs_log_dentry_safe+0x3e/0x60
   [6.1865]        btrfs_sync_file+0x431/0x690
   [6.1872]        do_fsync+0x39/0x80
   [6.1879]        __x64_sys_fsync+0x13/0x20
   [6.1887]        do_syscall_64+0x97/0x3e0
   [6.1894]        entry_SYSCALL_64_after_hwframe+0x76/0x7e
   [6.1903]
            -&gt; #0 (&amp;amp;delayed_node-&gt;mutex){+.+.}-{3:3}:
   [6.1913]        __lock_acquire+0x15e9/0x2820
   [6.1920]        lock_acquire+0xc9/0x2d0
   [6.1927]        __mutex_lock+0xcc/0x10a0
   [6.1934]        __btrfs_release_delayed_node.part.0+0x39/0x2f0
   [6.1944]        btrfs_evict_inode+0x20b/0x4b0
   [6.1952]        evict+0x15a/0x2f0
   [6.1958]        prune_icache_sb+0x91/0xd0
   [6.1966]        super_cache_scan+0x150/0x1d0
   [6.1974]        do_shrink_slab+0x155/0x6f0
   [6.1981]        shrink_slab+0x48e/0x890
   [6.1988]        shrink_one+0x11a/0x1f0
   [6.1995]        shrink_node+0xbfd/0x1320
   [6.1002]        balance_pgdat+0x67f/0xc60
   [6.1321]        kswapd+0x1dc/0x3e0
   [6.1643]        kthread+0xff/0x240
   [6.1965]        ret_from_fork+0x223/0x280
   [6.1287]        ret_from_fork_asm+0x1a/0x30
   [6.1616]
            other info that might help us debug this:

   [6.1561] Chain exists of:
              &amp;amp;delayed_node-&gt;mutex --&gt; btrfs-tree-00 --&gt; fs_reclaim

   [6.1503]  Possible unsafe locking scenario:

   [6.1110]        CPU0                    CPU1
   [6.1411]        ----                    ----
   [6.1707]   lock(fs_reclaim);
   [6.1998]                                lock(btrfs-tree-00);
   [6.1291]                                lock(fs_reclaim);
   [6.1581]   lock(&amp;amp;del
---truncated---</description><pubDate>Sat, 31 Jan 2026 11:49:15 +0000</pubDate></item><item><title>CVE-2026-23019 | net: marvell: prestera: fix NULL dereference on devlink_alloc() failure</title><link>https://www.cve.org/CVERecord?id=CVE-2026-23019</link><description>In the Linux kernel, the following vulnerability has been resolved:

net: marvell: prestera: fix NULL dereference on devlink_alloc() failure

devlink_alloc() may return NULL on allocation failure, but
prestera_devlink_alloc() unconditionally calls devlink_priv() on
the returned pointer.

This leads to a NULL pointer dereference if devlink allocation fails.
Add a check for a NULL devlink pointer and return NULL early to avoid
the crash.</description><pubDate>Sat, 31 Jan 2026 11:49:15 +0000</pubDate></item><item><title>CVE-2026-23020 | net: 3com: 3c59x: fix possible null dereference in vortex_probe1()</title><link>https://www.cve.org/CVERecord?id=CVE-2026-23020</link><description>In the Linux kernel, the following vulnerability has been resolved:

net: 3com: 3c59x: fix possible null dereference in vortex_probe1()

pdev can be null and free_ring: can be called in 1297 with a null
pdev.</description><pubDate>Sat, 31 Jan 2026 11:49:15 +0000</pubDate></item><item><title>CVE-2026-23021 | net: usb: pegasus: fix memory leak in update_eth_regs_async()</title><link>https://www.cve.org/CVERecord?id=CVE-2026-23021</link><description>In the Linux kernel, the following vulnerability has been resolved:

net: usb: pegasus: fix memory leak in update_eth_regs_async()

When asynchronously writing to the device registers and if usb_submit_urb()
fail, the code fail to release allocated to this point resources.</description><pubDate>Sat, 31 Jan 2026 11:49:16 +0000</pubDate></item><item><title>CVE-2026-23022 | idpf: fix memory leak in idpf_vc_core_deinit()</title><link>https://www.cve.org/CVERecord?id=CVE-2026-23022</link><description>In the Linux kernel, the following vulnerability has been resolved:

idpf: fix memory leak in idpf_vc_core_deinit()

Make sure to free hw-&gt;lan_regs. Reported by kmemleak during reset:

unreferenced object 0xff1b913d02a936c0 (size 96):
  comm "kworker/u258:14", pid 2174, jiffies 4294958305
  hex dump (first 32 bytes):
    00 00 00 c0 a8 ba 2d ff 00 00 00 00 00 00 00 00  ......-.........
    00 00 40 08 00 00 00 00 00 00 25 b3 a8 ba 2d ff  ..@.......%...-.
  backtrace (crc 36063c4f):
    __kmalloc_noprof+0x48f/0x890
    idpf_vc_core_init+0x6ce/0x9b0 [idpf]
    idpf_vc_event_task+0x1fb/0x350 [idpf]
    process_one_work+0x226/0x6d0
    worker_thread+0x19e/0x340
    kthread+0x10f/0x250
    ret_from_fork+0x251/0x2b0
    ret_from_fork_asm+0x1a/0x30</description><pubDate>Sat, 31 Jan 2026 11:49:16 +0000</pubDate></item><item><title>CVE-2026-23023 | idpf: fix memory leak in idpf_vport_rel()</title><link>https://www.cve.org/CVERecord?id=CVE-2026-23023</link><description>In the Linux kernel, the following vulnerability has been resolved:

idpf: fix memory leak in idpf_vport_rel()

Free vport-&gt;rx_ptype_lkup in idpf_vport_rel() to avoid leaking memory
during a reset. Reported by kmemleak:

unreferenced object 0xff450acac838a000 (size 4096):
  comm "kworker/u258:5", pid 7732, jiffies 4296830044
  hex dump (first 32 bytes):
    00 00 00 00 00 10 00 00 00 10 00 00 00 00 00 00  ................
    00 00 00 00 00 00 00 00 00 10 00 00 00 00 00 00  ................
  backtrace (crc 3da81902):
    __kmalloc_cache_noprof+0x469/0x7a0
    idpf_send_get_rx_ptype_msg+0x90/0x570 [idpf]
    idpf_init_task+0x1ec/0x8d0 [idpf]
    process_one_work+0x226/0x6d0
    worker_thread+0x19e/0x340
    kthread+0x10f/0x250
    ret_from_fork+0x251/0x2b0
    ret_from_fork_asm+0x1a/0x30</description><pubDate>Sat, 31 Jan 2026 11:49:17 +0000</pubDate></item><item><title>CVE-2026-23024 | idpf: fix memory leak of flow steer list on rmmod</title><link>https://www.cve.org/CVERecord?id=CVE-2026-23024</link><description>In the Linux kernel, the following vulnerability has been resolved:

idpf: fix memory leak of flow steer list on rmmod

The flow steering list maintains entries that are added and removed as
ethtool creates and deletes flow steering rules. Module removal with active
entries causes memory leak as the list is not properly cleaned up.

Prevent this by iterating through the remaining entries in the list and
freeing the associated memory during module removal. Add a spinlock
(flow_steer_list_lock) to protect the list access from multiple threads.</description><pubDate>Sat, 31 Jan 2026 11:49:17 +0000</pubDate></item><item><title>CVE-2026-1251 | SupportCandy  Helpdesk &amp;amp; Customer Support Ticket System &amp;lt;= 3.4.4 - Authenticated (Subscriber+) Insecure Direct Object Reference</title><link>https://www.cve.org/CVERecord?id=CVE-2026-1251</link><description>The SupportCandy  Helpdesk &amp; Customer Support Ticket System plugin for WordPress is vulnerable to Insecure Direct Object Reference in all versions up to, and including, 3.4.4 via the 'add_reply' function due to missing validation on a user controlled key. This makes it possible for authenticated attackers, with subscriber-level access and above, to steal file attachments uploaded by other users by specifying arbitrary attachment IDs in the 'description_attachments' parameter, re-associating those files to their own tickets and removing access from the original owners.</description><pubDate>Sat, 31 Jan 2026 07:04:16 +0000</pubDate></item><item><title>CVE-2026-0683 | SupportCandy  Helpdesk &amp;amp; Customer Support Ticket System &amp;lt;= 3.4.4 - Authenticated (Subscriber+) SQL Injection via Number Field Filter</title><link>https://www.cve.org/CVERecord?id=CVE-2026-0683</link><description>The SupportCandy  Helpdesk &amp; Customer Support Ticket System plugin for WordPress is vulnerable to SQL Injection via the Number-type custom field filter in all versions up to, and including, 3.4.4. This is due to insufficient escaping on the user-supplied operand value when using the equals operator and lack of sufficient preparation on the existing SQL query. This makes it possible for authenticated attackers, with Subscriber-level access and above (customers), to append additional SQL queries into already existing queries that can be used to extract sensitive information from the database.</description><pubDate>Sat, 31 Jan 2026 06:26:57 +0000</pubDate></item><item><title>CVE-2025-15525 | Ajax Load More  Infinite Scroll, Lazy Load &amp;amp; Load More &amp;lt;= 7.8.1 - Incorrect Authorization to Unauthenticated Private/Draft Post Title and Excerpt Exposure</title><link>https://www.cve.org/CVERecord?id=CVE-2025-15525</link><description>The Ajax Load More  Infinite Scroll, Load More, &amp; Lazy Load plugin for WordPress is vulnerable to unauthorized access of data due to incorrect authorization on the parse_custom_args() function in all versions up to, and including, 7.8.1. This makes it possible for unauthenticated attackers to expose the titles and excerpts of private, draft, pending, scheduled, and trashed posts.</description><pubDate>Sat, 31 Jan 2026 05:10:55 +0000</pubDate></item><item><title>CVE-2026-1431 | Booking Calendar &amp;lt;= 10.14.13 - Missing Authorization to Unauthenticated Booking Details Exposure</title><link>https://www.cve.org/CVERecord?id=CVE-2026-1431</link><description>The Booking Calendar plugin for WordPress is vulnerable to unauthorized access of data due to a missing capability check on the wpbc_ajax_WPBC_FLEXTIMELINE_NAV() function in all versions up to, and including, 10.14.13. This makes it possible for unauthenticated attackers to retrieve booking information including customer names, phones and emails.</description><pubDate>Sat, 31 Jan 2026 05:10:55 +0000</pubDate></item><item><title>CVE-2025-15510 | NEX-Forms  Ultimate Forms Plugin for WordPress &amp;lt;= 9.1.8 - Missing Authorization to Unauthenticated Sensitive Information Exposure</title><link>https://www.cve.org/CVERecord?id=CVE-2025-15510</link><description>The NEX-Forms  Ultimate Forms Plugin for WordPress is vulnerable to unauthorized access of data due to a missing capability check on the NF5_Export_Forms class constructor in all versions up to, and including, 9.1.8. This makes it possible for unauthenticated attackers to export form configurations, that may include sensitive data, such as  email addresses, PayPal API credentials, and third-party integration keys by enumerating the nex_forms_Id parameter.</description><pubDate>Sat, 31 Jan 2026 02:42:08 +0000</pubDate></item></channel></rss>